// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: txn.proto

/*
	Package txn is a generated protocol buffer package.

	It is generated from these files:
		txn.proto

	It has these top-level messages:
		TxnIntent
		TxnValue
		LockInfo
		LockError
		UnexpectedVer
		StatusConflict
		TxnError
		PrepareRequest
		PrepareResponse
		DsPrepareRequest
		DsPrepareResponse
		DecideRequest
		DecideResponse
		DsDecideRequest
		DsDecideResponse
		GetLockInfoRequest
		GetLockInfoResponse
		DsGetLockInfoRequest
		DsGetLockInfoResponse
		SelectRequest
		RowValue
		RowIntent
		Row
		SelectResponse
		DsSelectRequest
		DsSelectResponse
*/
package txn

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import kvrpcpb "model/pkg/kvrpcpb"
import metapb "model/pkg/metapb"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OpType int32

const (
	OpType_INSERT OpType = 0
	OpType_DELETE OpType = 1
)

var OpType_name = map[int32]string{
	0: "INSERT",
	1: "DELETE",
}
var OpType_value = map[string]int32{
	"INSERT": 0,
	"DELETE": 1,
}

func (x OpType) String() string {
	return proto.EnumName(OpType_name, int32(x))
}
func (OpType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTxn, []int{0} }

type TxnStatus int32

const (
	TxnStatus_INIT      TxnStatus = 0
	TxnStatus_COMMITTED TxnStatus = 1
	TxnStatus_ABORTED   TxnStatus = 2
)

var TxnStatus_name = map[int32]string{
	0: "INIT",
	1: "COMMITTED",
	2: "ABORTED",
}
var TxnStatus_value = map[string]int32{
	"INIT":      0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}
func (TxnStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorTxn, []int{1} }

type TxnError_ErrType int32

const (
	TxnError_UNKNOWN         TxnError_ErrType = 0
	TxnError_LOCKED          TxnError_ErrType = 1
	TxnError_UNEXPECTED_VER  TxnError_ErrType = 2
	TxnError_STATUS_CONFLICT TxnError_ErrType = 3
)

var TxnError_ErrType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LOCKED",
	2: "UNEXPECTED_VER",
	3: "STATUS_CONFLICT",
}
var TxnError_ErrType_value = map[string]int32{
	"UNKNOWN":         0,
	"LOCKED":          1,
	"UNEXPECTED_VER":  2,
	"STATUS_CONFLICT": 3,
}

func (x TxnError_ErrType) String() string {
	return proto.EnumName(TxnError_ErrType_name, int32(x))
}
func (TxnError_ErrType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTxn, []int{6, 0} }

type TxnIntent struct {
	Typ         OpType `protobuf:"varint,1,opt,name=typ,proto3,enum=txn.OpType" json:"typ,omitempty"`
	Key         []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value       []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	CheckUnique bool   `protobuf:"varint,4,opt,name=check_unique,json=checkUnique,proto3" json:"check_unique,omitempty"`
	ExpectedVer uint64 `protobuf:"varint,5,opt,name=expected_ver,json=expectedVer,proto3" json:"expected_ver,omitempty"`
	IsPrimary   bool   `protobuf:"varint,6,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
}

func (m *TxnIntent) Reset()                    { *m = TxnIntent{} }
func (m *TxnIntent) String() string            { return proto.CompactTextString(m) }
func (*TxnIntent) ProtoMessage()               {}
func (*TxnIntent) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{0} }

func (m *TxnIntent) GetTyp() OpType {
	if m != nil {
		return m.Typ
	}
	return OpType_INSERT
}

func (m *TxnIntent) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TxnIntent) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TxnIntent) GetCheckUnique() bool {
	if m != nil {
		return m.CheckUnique
	}
	return false
}

func (m *TxnIntent) GetExpectedVer() uint64 {
	if m != nil {
		return m.ExpectedVer
	}
	return 0
}

func (m *TxnIntent) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

// data-server端存储结构
type TxnValue struct {
	TxnId      string     `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	Intent     *TxnIntent `protobuf:"bytes,2,opt,name=intent" json:"intent,omitempty"`
	PrimaryKey []byte     `protobuf:"bytes,3,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	ExpiredAt  uint64     `protobuf:"varint,4,opt,name=expired_at,json=expiredAt,proto3" json:"expired_at,omitempty"`
	// only exists in primary row, used as txn record
	TxnStatus     TxnStatus `protobuf:"varint,10,opt,name=txn_status,json=txnStatus,proto3,enum=txn.TxnStatus" json:"txn_status,omitempty"`
	SecondaryKeys [][]byte  `protobuf:"bytes,11,rep,name=secondary_keys,json=secondaryKeys" json:"secondary_keys,omitempty"`
}

func (m *TxnValue) Reset()                    { *m = TxnValue{} }
func (m *TxnValue) String() string            { return proto.CompactTextString(m) }
func (*TxnValue) ProtoMessage()               {}
func (*TxnValue) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{1} }

func (m *TxnValue) GetTxnId() string {
	if m != nil {
		return m.TxnId
	}
	return ""
}

func (m *TxnValue) GetIntent() *TxnIntent {
	if m != nil {
		return m.Intent
	}
	return nil
}

func (m *TxnValue) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *TxnValue) GetExpiredAt() uint64 {
	if m != nil {
		return m.ExpiredAt
	}
	return 0
}

func (m *TxnValue) GetTxnStatus() TxnStatus {
	if m != nil {
		return m.TxnStatus
	}
	return TxnStatus_INIT
}

func (m *TxnValue) GetSecondaryKeys() [][]byte {
	if m != nil {
		return m.SecondaryKeys
	}
	return nil
}

type LockInfo struct {
	TxnId   string `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	Timeout bool   `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// 1) 如果当前key是primary，则is_primary为true且返回status和secondary_keys
	// 2) 如果不是则primary, 则is_primary为false并返回primary key
	IsPrimary     bool      `protobuf:"varint,10,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
	PrimaryKey    []byte    `protobuf:"bytes,11,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	Status        TxnStatus `protobuf:"varint,12,opt,name=status,proto3,enum=txn.TxnStatus" json:"status,omitempty"`
	SecondaryKeys [][]byte  `protobuf:"bytes,13,rep,name=secondary_keys,json=secondaryKeys" json:"secondary_keys,omitempty"`
}

func (m *LockInfo) Reset()                    { *m = LockInfo{} }
func (m *LockInfo) String() string            { return proto.CompactTextString(m) }
func (*LockInfo) ProtoMessage()               {}
func (*LockInfo) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{2} }

func (m *LockInfo) GetTxnId() string {
	if m != nil {
		return m.TxnId
	}
	return ""
}

func (m *LockInfo) GetTimeout() bool {
	if m != nil {
		return m.Timeout
	}
	return false
}

func (m *LockInfo) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *LockInfo) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *LockInfo) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_INIT
}

func (m *LockInfo) GetSecondaryKeys() [][]byte {
	if m != nil {
		return m.SecondaryKeys
	}
	return nil
}

type LockError struct {
	Key  []byte    `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Info *LockInfo `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *LockError) Reset()                    { *m = LockError{} }
func (m *LockError) String() string            { return proto.CompactTextString(m) }
func (*LockError) ProtoMessage()               {}
func (*LockError) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{3} }

func (m *LockError) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LockError) GetInfo() *LockInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// Intent中设置了expected_ver时，version校验不通过，一般是写冲突
type UnexpectedVer struct {
	Key         []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	ExpectedVer uint64 `protobuf:"varint,2,opt,name=expected_ver,json=expectedVer,proto3" json:"expected_ver,omitempty"`
	ActualVer   uint64 `protobuf:"varint,3,opt,name=actual_ver,json=actualVer,proto3" json:"actual_ver,omitempty"`
}

func (m *UnexpectedVer) Reset()                    { *m = UnexpectedVer{} }
func (m *UnexpectedVer) String() string            { return proto.CompactTextString(m) }
func (*UnexpectedVer) ProtoMessage()               {}
func (*UnexpectedVer) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{4} }

func (m *UnexpectedVer) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *UnexpectedVer) GetExpectedVer() uint64 {
	if m != nil {
		return m.ExpectedVer
	}
	return 0
}

func (m *UnexpectedVer) GetActualVer() uint64 {
	if m != nil {
		return m.ActualVer
	}
	return 0
}

// 更新事务状态时，事务状态已经不是INIT，则更新失败，并返回当前的状态
// 比如事务状态已经是ABORTED，则不能更新为COMMITTED
type StatusConflict struct {
	Status TxnStatus `protobuf:"varint,1,opt,name=status,proto3,enum=txn.TxnStatus" json:"status,omitempty"`
}

func (m *StatusConflict) Reset()                    { *m = StatusConflict{} }
func (m *StatusConflict) String() string            { return proto.CompactTextString(m) }
func (*StatusConflict) ProtoMessage()               {}
func (*StatusConflict) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{5} }

func (m *StatusConflict) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_INIT
}

type TxnError struct {
	ErrType        TxnError_ErrType `protobuf:"varint,1,opt,name=err_type,json=errType,proto3,enum=txn.TxnError_ErrType" json:"err_type,omitempty"`
	LockErr        *LockError       `protobuf:"bytes,2,opt,name=lock_err,json=lockErr" json:"lock_err,omitempty"`
	UnexpectedVer  *UnexpectedVer   `protobuf:"bytes,3,opt,name=unexpected_ver,json=unexpectedVer" json:"unexpected_ver,omitempty"`
	StatusConflict *StatusConflict  `protobuf:"bytes,4,opt,name=status_conflict,json=statusConflict" json:"status_conflict,omitempty"`
}

func (m *TxnError) Reset()                    { *m = TxnError{} }
func (m *TxnError) String() string            { return proto.CompactTextString(m) }
func (*TxnError) ProtoMessage()               {}
func (*TxnError) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{6} }

func (m *TxnError) GetErrType() TxnError_ErrType {
	if m != nil {
		return m.ErrType
	}
	return TxnError_UNKNOWN
}

func (m *TxnError) GetLockErr() *LockError {
	if m != nil {
		return m.LockErr
	}
	return nil
}

func (m *TxnError) GetUnexpectedVer() *UnexpectedVer {
	if m != nil {
		return m.UnexpectedVer
	}
	return nil
}

func (m *TxnError) GetStatusConflict() *StatusConflict {
	if m != nil {
		return m.StatusConflict
	}
	return nil
}

// Prepare
type PrepareRequest struct {
	TxnId         string       `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	Local         bool         `protobuf:"varint,2,opt,name=local,proto3" json:"local,omitempty"`
	Intents       []*TxnIntent `protobuf:"bytes,3,rep,name=intents" json:"intents,omitempty"`
	PrimaryKey    []byte       `protobuf:"bytes,4,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	LockTtl       uint64       `protobuf:"varint,5,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	SecondaryKeys [][]byte     `protobuf:"bytes,6,rep,name=secondary_keys,json=secondaryKeys" json:"secondary_keys,omitempty"`
	StrictCheck   bool         `protobuf:"varint,16,opt,name=strict_check,json=strictCheck,proto3" json:"strict_check,omitempty"`
}

func (m *PrepareRequest) Reset()                    { *m = PrepareRequest{} }
func (m *PrepareRequest) String() string            { return proto.CompactTextString(m) }
func (*PrepareRequest) ProtoMessage()               {}
func (*PrepareRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{7} }

func (m *PrepareRequest) GetTxnId() string {
	if m != nil {
		return m.TxnId
	}
	return ""
}

func (m *PrepareRequest) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

func (m *PrepareRequest) GetIntents() []*TxnIntent {
	if m != nil {
		return m.Intents
	}
	return nil
}

func (m *PrepareRequest) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *PrepareRequest) GetLockTtl() uint64 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

func (m *PrepareRequest) GetSecondaryKeys() [][]byte {
	if m != nil {
		return m.SecondaryKeys
	}
	return nil
}

func (m *PrepareRequest) GetStrictCheck() bool {
	if m != nil {
		return m.StrictCheck
	}
	return false
}

type PrepareResponse struct {
	Errors []*TxnError `protobuf:"bytes,1,rep,name=errors" json:"errors,omitempty"`
}

func (m *PrepareResponse) Reset()                    { *m = PrepareResponse{} }
func (m *PrepareResponse) String() string            { return proto.CompactTextString(m) }
func (*PrepareResponse) ProtoMessage()               {}
func (*PrepareResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{8} }

func (m *PrepareResponse) GetErrors() []*TxnError {
	if m != nil {
		return m.Errors
	}
	return nil
}

type DsPrepareRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *PrepareRequest        `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsPrepareRequest) Reset()                    { *m = DsPrepareRequest{} }
func (m *DsPrepareRequest) String() string            { return proto.CompactTextString(m) }
func (*DsPrepareRequest) ProtoMessage()               {}
func (*DsPrepareRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{9} }

func (m *DsPrepareRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsPrepareRequest) GetReq() *PrepareRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type DsPrepareResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *PrepareResponse        `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsPrepareResponse) Reset()                    { *m = DsPrepareResponse{} }
func (m *DsPrepareResponse) String() string            { return proto.CompactTextString(m) }
func (*DsPrepareResponse) ProtoMessage()               {}
func (*DsPrepareResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{10} }

func (m *DsPrepareResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsPrepareResponse) GetResp() *PrepareResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

// Commit or Rollback
type DecideRequest struct {
	TxnId   string    `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	Status  TxnStatus `protobuf:"varint,2,opt,name=status,proto3,enum=txn.TxnStatus" json:"status,omitempty"`
	Keys    [][]byte  `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
	ClearUp bool      `protobuf:"varint,4,opt,name=clear_up,json=clearUp,proto3" json:"clear_up,omitempty"`
}

func (m *DecideRequest) Reset()                    { *m = DecideRequest{} }
func (m *DecideRequest) String() string            { return proto.CompactTextString(m) }
func (*DecideRequest) ProtoMessage()               {}
func (*DecideRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{11} }

func (m *DecideRequest) GetTxnId() string {
	if m != nil {
		return m.TxnId
	}
	return ""
}

func (m *DecideRequest) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_INIT
}

func (m *DecideRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *DecideRequest) GetClearUp() bool {
	if m != nil {
		return m.ClearUp
	}
	return false
}

type DecideResponse struct {
	Errors []*TxnError `protobuf:"bytes,1,rep,name=errors" json:"errors,omitempty"`
}

func (m *DecideResponse) Reset()                    { *m = DecideResponse{} }
func (m *DecideResponse) String() string            { return proto.CompactTextString(m) }
func (*DecideResponse) ProtoMessage()               {}
func (*DecideResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{12} }

func (m *DecideResponse) GetErrors() []*TxnError {
	if m != nil {
		return m.Errors
	}
	return nil
}

type DsDecideRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *DecideRequest         `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsDecideRequest) Reset()                    { *m = DsDecideRequest{} }
func (m *DsDecideRequest) String() string            { return proto.CompactTextString(m) }
func (*DsDecideRequest) ProtoMessage()               {}
func (*DsDecideRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{13} }

func (m *DsDecideRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsDecideRequest) GetReq() *DecideRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type DsDecideResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *DecideResponse         `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsDecideResponse) Reset()                    { *m = DsDecideResponse{} }
func (m *DsDecideResponse) String() string            { return proto.CompactTextString(m) }
func (*DsDecideResponse) ProtoMessage()               {}
func (*DsDecideResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{14} }

func (m *DsDecideResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsDecideResponse) GetResp() *DecideResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

// 查询Lock信息
type GetLockInfoRequest struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	TxnId string `protobuf:"bytes,2,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
}

func (m *GetLockInfoRequest) Reset()                    { *m = GetLockInfoRequest{} }
func (m *GetLockInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLockInfoRequest) ProtoMessage()               {}
func (*GetLockInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{15} }

func (m *GetLockInfoRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GetLockInfoRequest) GetTxnId() string {
	if m != nil {
		return m.TxnId
	}
	return ""
}

type GetLockInfoResponse struct {
	Info *LockInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetLockInfoResponse) Reset()                    { *m = GetLockInfoResponse{} }
func (m *GetLockInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLockInfoResponse) ProtoMessage()               {}
func (*GetLockInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{16} }

func (m *GetLockInfoResponse) GetInfo() *LockInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type DsGetLockInfoRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *GetLockInfoRequest    `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsGetLockInfoRequest) Reset()                    { *m = DsGetLockInfoRequest{} }
func (m *DsGetLockInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*DsGetLockInfoRequest) ProtoMessage()               {}
func (*DsGetLockInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{17} }

func (m *DsGetLockInfoRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsGetLockInfoRequest) GetReq() *GetLockInfoRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type DsGetLockInfoResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *GetLockInfoResponse    `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsGetLockInfoResponse) Reset()                    { *m = DsGetLockInfoResponse{} }
func (m *DsGetLockInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*DsGetLockInfoResponse) ProtoMessage()               {}
func (*DsGetLockInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{18} }

func (m *DsGetLockInfoResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsGetLockInfoResponse) GetResp() *GetLockInfoResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

// Select
type SelectRequest struct {
	Key          []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Scope        *kvrpcpb.Scope         `protobuf:"bytes,2,opt,name=scope" json:"scope,omitempty"`
	FieldList    []*kvrpcpb.SelectField `protobuf:"bytes,3,rep,name=field_list,json=fieldList" json:"field_list,omitempty"`
	WhereFilters []*kvrpcpb.Match       `protobuf:"bytes,4,rep,name=where_filters,json=whereFilters" json:"where_filters,omitempty"`
	GroupBys     []*metapb.Column       `protobuf:"bytes,5,rep,name=group_bys,json=groupBys" json:"group_bys,omitempty"`
	Limit        *kvrpcpb.Limit         `protobuf:"bytes,6,opt,name=limit" json:"limit,omitempty"`
}

func (m *SelectRequest) Reset()                    { *m = SelectRequest{} }
func (m *SelectRequest) String() string            { return proto.CompactTextString(m) }
func (*SelectRequest) ProtoMessage()               {}
func (*SelectRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{19} }

func (m *SelectRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SelectRequest) GetScope() *kvrpcpb.Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *SelectRequest) GetFieldList() []*kvrpcpb.SelectField {
	if m != nil {
		return m.FieldList
	}
	return nil
}

func (m *SelectRequest) GetWhereFilters() []*kvrpcpb.Match {
	if m != nil {
		return m.WhereFilters
	}
	return nil
}

func (m *SelectRequest) GetGroupBys() []*metapb.Column {
	if m != nil {
		return m.GroupBys
	}
	return nil
}

func (m *SelectRequest) GetLimit() *kvrpcpb.Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

type RowValue struct {
	Fields       []byte  `protobuf:"bytes,1,opt,name=fields,proto3" json:"fields,omitempty"`
	AggredCounts []int64 `protobuf:"varint,2,rep,packed,name=aggred_counts,json=aggredCounts" json:"aggred_counts,omitempty"`
	Version      uint64  `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *RowValue) Reset()                    { *m = RowValue{} }
func (m *RowValue) String() string            { return proto.CompactTextString(m) }
func (*RowValue) ProtoMessage()               {}
func (*RowValue) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{20} }

func (m *RowValue) GetFields() []byte {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RowValue) GetAggredCounts() []int64 {
	if m != nil {
		return m.AggredCounts
	}
	return nil
}

func (m *RowValue) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type RowIntent struct {
	TxnId      string    `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	PrimaryKey []byte    `protobuf:"bytes,2,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	Value      *RowValue `protobuf:"bytes,10,opt,name=value" json:"value,omitempty"`
}

func (m *RowIntent) Reset()                    { *m = RowIntent{} }
func (m *RowIntent) String() string            { return proto.CompactTextString(m) }
func (*RowIntent) ProtoMessage()               {}
func (*RowIntent) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{21} }

func (m *RowIntent) GetTxnId() string {
	if m != nil {
		return m.TxnId
	}
	return ""
}

func (m *RowIntent) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *RowIntent) GetValue() *RowValue {
	if m != nil {
		return m.Value
	}
	return nil
}

type Row struct {
	Key    []byte     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value  *RowValue  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Intent *RowIntent `protobuf:"bytes,3,opt,name=intent" json:"intent,omitempty"`
}

func (m *Row) Reset()                    { *m = Row{} }
func (m *Row) String() string            { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()               {}
func (*Row) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{22} }

func (m *Row) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Row) GetValue() *RowValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Row) GetIntent() *RowIntent {
	if m != nil {
		return m.Intent
	}
	return nil
}

type SelectResponse struct {
	Code   int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Rows   []*Row `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
	Offset uint64 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *SelectResponse) Reset()                    { *m = SelectResponse{} }
func (m *SelectResponse) String() string            { return proto.CompactTextString(m) }
func (*SelectResponse) ProtoMessage()               {}
func (*SelectResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{23} }

func (m *SelectResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SelectResponse) GetRows() []*Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *SelectResponse) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type DsSelectRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *SelectRequest         `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsSelectRequest) Reset()                    { *m = DsSelectRequest{} }
func (m *DsSelectRequest) String() string            { return proto.CompactTextString(m) }
func (*DsSelectRequest) ProtoMessage()               {}
func (*DsSelectRequest) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{24} }

func (m *DsSelectRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsSelectRequest) GetReq() *SelectRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type DsSelectResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *SelectResponse         `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsSelectResponse) Reset()                    { *m = DsSelectResponse{} }
func (m *DsSelectResponse) String() string            { return proto.CompactTextString(m) }
func (*DsSelectResponse) ProtoMessage()               {}
func (*DsSelectResponse) Descriptor() ([]byte, []int) { return fileDescriptorTxn, []int{25} }

func (m *DsSelectResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsSelectResponse) GetResp() *SelectResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

func init() {
	proto.RegisterType((*TxnIntent)(nil), "txn.TxnIntent")
	proto.RegisterType((*TxnValue)(nil), "txn.TxnValue")
	proto.RegisterType((*LockInfo)(nil), "txn.LockInfo")
	proto.RegisterType((*LockError)(nil), "txn.LockError")
	proto.RegisterType((*UnexpectedVer)(nil), "txn.UnexpectedVer")
	proto.RegisterType((*StatusConflict)(nil), "txn.StatusConflict")
	proto.RegisterType((*TxnError)(nil), "txn.TxnError")
	proto.RegisterType((*PrepareRequest)(nil), "txn.PrepareRequest")
	proto.RegisterType((*PrepareResponse)(nil), "txn.PrepareResponse")
	proto.RegisterType((*DsPrepareRequest)(nil), "txn.DsPrepareRequest")
	proto.RegisterType((*DsPrepareResponse)(nil), "txn.DsPrepareResponse")
	proto.RegisterType((*DecideRequest)(nil), "txn.DecideRequest")
	proto.RegisterType((*DecideResponse)(nil), "txn.DecideResponse")
	proto.RegisterType((*DsDecideRequest)(nil), "txn.DsDecideRequest")
	proto.RegisterType((*DsDecideResponse)(nil), "txn.DsDecideResponse")
	proto.RegisterType((*GetLockInfoRequest)(nil), "txn.GetLockInfoRequest")
	proto.RegisterType((*GetLockInfoResponse)(nil), "txn.GetLockInfoResponse")
	proto.RegisterType((*DsGetLockInfoRequest)(nil), "txn.DsGetLockInfoRequest")
	proto.RegisterType((*DsGetLockInfoResponse)(nil), "txn.DsGetLockInfoResponse")
	proto.RegisterType((*SelectRequest)(nil), "txn.SelectRequest")
	proto.RegisterType((*RowValue)(nil), "txn.RowValue")
	proto.RegisterType((*RowIntent)(nil), "txn.RowIntent")
	proto.RegisterType((*Row)(nil), "txn.Row")
	proto.RegisterType((*SelectResponse)(nil), "txn.SelectResponse")
	proto.RegisterType((*DsSelectRequest)(nil), "txn.DsSelectRequest")
	proto.RegisterType((*DsSelectResponse)(nil), "txn.DsSelectResponse")
	proto.RegisterEnum("txn.OpType", OpType_name, OpType_value)
	proto.RegisterEnum("txn.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterEnum("txn.TxnError_ErrType", TxnError_ErrType_name, TxnError_ErrType_value)
}
func (m *TxnIntent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnIntent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Typ))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.CheckUnique {
		dAtA[i] = 0x20
		i++
		if m.CheckUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExpectedVer != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.ExpectedVer))
	}
	if m.IsPrimary {
		dAtA[i] = 0x30
		i++
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TxnValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.TxnId)))
		i += copy(dAtA[i:], m.TxnId)
	}
	if m.Intent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Intent.Size()))
		n1, err := m.Intent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	if m.ExpiredAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.ExpiredAt))
	}
	if m.TxnStatus != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.TxnStatus))
	}
	if len(m.SecondaryKeys) > 0 {
		for _, b := range m.SecondaryKeys {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTxn(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *LockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.TxnId)))
		i += copy(dAtA[i:], m.TxnId)
	}
	if m.Timeout {
		dAtA[i] = 0x10
		i++
		if m.Timeout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPrimary {
		dAtA[i] = 0x50
		i++
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	if m.Status != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Status))
	}
	if len(m.SecondaryKeys) > 0 {
		for _, b := range m.SecondaryKeys {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintTxn(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *LockError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Info.Size()))
		n2, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *UnexpectedVer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnexpectedVer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.ExpectedVer != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.ExpectedVer))
	}
	if m.ActualVer != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.ActualVer))
	}
	return i, nil
}

func (m *StatusConflict) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusConflict) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *TxnError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.ErrType))
	}
	if m.LockErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.LockErr.Size()))
		n3, err := m.LockErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.UnexpectedVer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.UnexpectedVer.Size()))
		n4, err := m.UnexpectedVer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.StatusConflict != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.StatusConflict.Size()))
		n5, err := m.StatusConflict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *PrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.TxnId)))
		i += copy(dAtA[i:], m.TxnId)
	}
	if m.Local {
		dAtA[i] = 0x10
		i++
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Intents) > 0 {
		for _, msg := range m.Intents {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	if m.LockTtl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.LockTtl))
	}
	if len(m.SecondaryKeys) > 0 {
		for _, b := range m.SecondaryKeys {
			dAtA[i] = 0x32
			i++
			i = encodeVarintTxn(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.StrictCheck {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.StrictCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PrepareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DsPrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsPrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n6, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Req.Size()))
		n7, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *DsPrepareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsPrepareResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n8, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Resp.Size()))
		n9, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DecideRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecideRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.TxnId)))
		i += copy(dAtA[i:], m.TxnId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Status))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTxn(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.ClearUp {
		dAtA[i] = 0x20
		i++
		if m.ClearUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DecideResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecideResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DsDecideRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsDecideRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n10, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Req.Size()))
		n11, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DsDecideResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsDecideResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n12, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Resp.Size()))
		n13, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *GetLockInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.TxnId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.TxnId)))
		i += copy(dAtA[i:], m.TxnId)
	}
	return i, nil
}

func (m *GetLockInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Info.Size()))
		n14, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *DsGetLockInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsGetLockInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n15, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Req.Size()))
		n16, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DsGetLockInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsGetLockInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n17, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Resp.Size()))
		n18, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SelectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Scope != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Scope.Size()))
		n19, err := m.Scope.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.FieldList) > 0 {
		for _, msg := range m.FieldList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WhereFilters) > 0 {
		for _, msg := range m.WhereFilters {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GroupBys) > 0 {
		for _, msg := range m.GroupBys {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Limit != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Limit.Size()))
		n20, err := m.Limit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *RowValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Fields)))
		i += copy(dAtA[i:], m.Fields)
	}
	if len(m.AggredCounts) > 0 {
		dAtA22 := make([]byte, len(m.AggredCounts)*10)
		var j21 int
		for _, num1 := range m.AggredCounts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *RowIntent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowIntent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.TxnId)))
		i += copy(dAtA[i:], m.TxnId)
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	if m.Value != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Value.Size()))
		n23, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *Row) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Row) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Value.Size()))
		n24, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Intent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Intent.Size()))
		n25, err := m.Intent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SelectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Code))
	}
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Offset))
	}
	return i, nil
}

func (m *DsSelectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsSelectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n26, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Req.Size()))
		n27, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *DsSelectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsSelectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Header.Size()))
		n28, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Resp.Size()))
		n29, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func encodeVarintTxn(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TxnIntent) Size() (n int) {
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovTxn(uint64(m.Typ))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CheckUnique {
		n += 2
	}
	if m.ExpectedVer != 0 {
		n += 1 + sovTxn(uint64(m.ExpectedVer))
	}
	if m.IsPrimary {
		n += 2
	}
	return n
}

func (m *TxnValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Intent != nil {
		l = m.Intent.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.ExpiredAt != 0 {
		n += 1 + sovTxn(uint64(m.ExpiredAt))
	}
	if m.TxnStatus != 0 {
		n += 1 + sovTxn(uint64(m.TxnStatus))
	}
	if len(m.SecondaryKeys) > 0 {
		for _, b := range m.SecondaryKeys {
			l = len(b)
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	return n
}

func (m *LockInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Timeout {
		n += 2
	}
	if m.IsPrimary {
		n += 2
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTxn(uint64(m.Status))
	}
	if len(m.SecondaryKeys) > 0 {
		for _, b := range m.SecondaryKeys {
			l = len(b)
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	return n
}

func (m *LockError) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *UnexpectedVer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.ExpectedVer != 0 {
		n += 1 + sovTxn(uint64(m.ExpectedVer))
	}
	if m.ActualVer != 0 {
		n += 1 + sovTxn(uint64(m.ActualVer))
	}
	return n
}

func (m *StatusConflict) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTxn(uint64(m.Status))
	}
	return n
}

func (m *TxnError) Size() (n int) {
	var l int
	_ = l
	if m.ErrType != 0 {
		n += 1 + sovTxn(uint64(m.ErrType))
	}
	if m.LockErr != nil {
		l = m.LockErr.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.UnexpectedVer != nil {
		l = m.UnexpectedVer.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.StatusConflict != nil {
		l = m.StatusConflict.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *PrepareRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Local {
		n += 2
	}
	if len(m.Intents) > 0 {
		for _, e := range m.Intents {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.LockTtl != 0 {
		n += 1 + sovTxn(uint64(m.LockTtl))
	}
	if len(m.SecondaryKeys) > 0 {
		for _, b := range m.SecondaryKeys {
			l = len(b)
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.StrictCheck {
		n += 3
	}
	return n
}

func (m *PrepareResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	return n
}

func (m *DsPrepareRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *DsPrepareResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *DecideRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTxn(uint64(m.Status))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.ClearUp {
		n += 2
	}
	return n
}

func (m *DecideResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	return n
}

func (m *DsDecideRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *DsDecideResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *GetLockInfoRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *GetLockInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *DsGetLockInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *DsGetLockInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *SelectRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Scope != nil {
		l = m.Scope.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if len(m.FieldList) > 0 {
		for _, e := range m.FieldList {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if len(m.WhereFilters) > 0 {
		for _, e := range m.WhereFilters {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if len(m.GroupBys) > 0 {
		for _, e := range m.GroupBys {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *RowValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Fields)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if len(m.AggredCounts) > 0 {
		l = 0
		for _, e := range m.AggredCounts {
			l += sovTxn(uint64(e))
		}
		n += 1 + sovTxn(uint64(l)) + l
	}
	if m.Version != 0 {
		n += 1 + sovTxn(uint64(m.Version))
	}
	return n
}

func (m *RowIntent) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *Row) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Intent != nil {
		l = m.Intent.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *SelectResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTxn(uint64(m.Code))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.Offset != 0 {
		n += 1 + sovTxn(uint64(m.Offset))
	}
	return n
}

func (m *DsSelectRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func (m *DsSelectResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	return n
}

func sovTxn(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTxn(x uint64) (n int) {
	return sovTxn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnIntent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnIntent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnIntent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= (OpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckUnique = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedVer", wireType)
			}
			m.ExpectedVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Intent == nil {
				m.Intent = &TxnIntent{}
			}
			if err := m.Intent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAt", wireType)
			}
			m.ExpiredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnStatus", wireType)
			}
			m.TxnStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnStatus |= (TxnStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryKeys = append(m.SecondaryKeys, make([]byte, postIndex-iNdEx))
			copy(m.SecondaryKeys[len(m.SecondaryKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TxnStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryKeys = append(m.SecondaryKeys, make([]byte, postIndex-iNdEx))
			copy(m.SecondaryKeys[len(m.SecondaryKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &LockInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnexpectedVer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnexpectedVer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnexpectedVer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedVer", wireType)
			}
			m.ExpectedVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualVer", wireType)
			}
			m.ActualVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusConflict) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusConflict: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusConflict: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TxnStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrType", wireType)
			}
			m.ErrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrType |= (TxnError_ErrType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockErr == nil {
				m.LockErr = &LockError{}
			}
			if err := m.LockErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnexpectedVer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnexpectedVer == nil {
				m.UnexpectedVer = &UnexpectedVer{}
			}
			if err := m.UnexpectedVer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusConflict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatusConflict == nil {
				m.StatusConflict = &StatusConflict{}
			}
			if err := m.StatusConflict.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intents = append(m.Intents, &TxnIntent{})
			if err := m.Intents[len(m.Intents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryKeys = append(m.SecondaryKeys, make([]byte, postIndex-iNdEx))
			copy(m.SecondaryKeys[len(m.SecondaryKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrictCheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &TxnError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsPrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsPrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsPrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &PrepareRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsPrepareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsPrepareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsPrepareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &PrepareResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecideRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecideRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecideRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TxnStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearUp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecideResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecideResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecideResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &TxnError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsDecideRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsDecideRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsDecideRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &DecideRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsDecideResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsDecideResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsDecideResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &DecideResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &LockInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsGetLockInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsGetLockInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsGetLockInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &GetLockInfoRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsGetLockInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsGetLockInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsGetLockInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &GetLockInfoResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &kvrpcpb.Scope{}
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldList = append(m.FieldList, &kvrpcpb.SelectField{})
			if err := m.FieldList[len(m.FieldList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhereFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhereFilters = append(m.WhereFilters, &kvrpcpb.Match{})
			if err := m.WhereFilters[len(m.WhereFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBys = append(m.GroupBys, &metapb.Column{})
			if err := m.GroupBys[len(m.GroupBys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &kvrpcpb.Limit{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields[:0], dAtA[iNdEx:postIndex]...)
			if m.Fields == nil {
				m.Fields = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AggredCounts = append(m.AggredCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTxn
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AggredCounts = append(m.AggredCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AggredCounts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowIntent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowIntent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowIntent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &RowValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Row) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Row: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Row: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &RowValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Intent == nil {
				m.Intent = &RowIntent{}
			}
			if err := m.Intent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &Row{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsSelectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsSelectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsSelectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &SelectRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsSelectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsSelectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsSelectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &SelectResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTxn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTxn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTxn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxn   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("txn.proto", fileDescriptorTxn) }

var fileDescriptorTxn = []byte{
	// 1349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x72, 0x1b, 0xc5,
	0x13, 0xcf, 0x6a, 0xf5, 0xd9, 0xfa, 0xb0, 0xfe, 0x63, 0x27, 0xd9, 0x7f, 0x8a, 0x18, 0x65, 0xf3,
	0x81, 0x12, 0xc0, 0x01, 0xe7, 0x40, 0xa8, 0x82, 0x2a, 0x12, 0x49, 0x01, 0x95, 0x1d, 0x39, 0x35,
	0x96, 0x0d, 0xc5, 0x65, 0x6b, 0xb3, 0x1a, 0xd9, 0x5b, 0x5e, 0xef, 0xae, 0x67, 0x66, 0x6d, 0xe9,
	0xc0, 0x8d, 0x87, 0xe0, 0x25, 0x38, 0xf3, 0x0a, 0x14, 0x27, 0xde, 0x00, 0x2a, 0x9c, 0x79, 0x07,
	0x6a, 0x3e, 0x56, 0xd6, 0xca, 0x72, 0x28, 0x53, 0xb9, 0x4d, 0xf7, 0xf4, 0x4c, 0xf7, 0xaf, 0xfb,
	0xb7, 0x3d, 0xbd, 0x50, 0xe1, 0x93, 0x70, 0x23, 0xa6, 0x11, 0x8f, 0x90, 0xc9, 0x27, 0xe1, 0xad,
	0xb5, 0x83, 0xe8, 0x20, 0x92, 0xf2, 0x63, 0xb1, 0x52, 0x5b, 0xb7, 0xea, 0x47, 0xa7, 0x34, 0xf6,
	0xe2, 0xd7, 0x5a, 0xac, 0x1d, 0x13, 0xee, 0xa6, 0x92, 0xfd, 0x8b, 0x01, 0x95, 0xe1, 0x24, 0xec,
	0x87, 0x9c, 0x84, 0x1c, 0xdd, 0x06, 0x93, 0x4f, 0x63, 0xcb, 0x68, 0x19, 0xed, 0xc6, 0x66, 0x75,
	0x43, 0x5c, 0xbf, 0x13, 0x0f, 0xa7, 0x31, 0xc1, 0x42, 0x8f, 0x9a, 0x60, 0x1e, 0x91, 0xa9, 0x95,
	0x6b, 0x19, 0xed, 0x1a, 0x16, 0x4b, 0xb4, 0x06, 0x85, 0x53, 0x37, 0x48, 0x88, 0x65, 0x4a, 0x9d,
	0x12, 0xd0, 0x1d, 0xa8, 0x79, 0x87, 0xc4, 0x3b, 0x72, 0x92, 0xd0, 0x3f, 0x49, 0x88, 0x95, 0x6f,
	0x19, 0xed, 0x32, 0xae, 0x4a, 0xdd, 0x9e, 0x54, 0x09, 0x13, 0x32, 0x89, 0x89, 0xc7, 0xc9, 0xc8,
	0x39, 0x25, 0xd4, 0x2a, 0xb4, 0x8c, 0x76, 0x1e, 0x57, 0x53, 0xdd, 0x3e, 0xa1, 0xe8, 0x36, 0x80,
	0xcf, 0x9c, 0x98, 0xfa, 0xc7, 0x2e, 0x9d, 0x5a, 0x45, 0x79, 0x47, 0xc5, 0x67, 0xaf, 0x94, 0xc2,
	0xfe, 0xc3, 0x80, 0xf2, 0x70, 0x12, 0xee, 0x4b, 0x8f, 0xd7, 0xa1, 0xc8, 0x27, 0xa1, 0xe3, 0x8f,
	0x64, 0xec, 0x15, 0x5c, 0xe0, 0x93, 0xb0, 0x3f, 0x42, 0x0f, 0xa0, 0xe8, 0x4b, 0x64, 0x32, 0xe6,
	0xea, 0x66, 0x43, 0x42, 0x9a, 0xe1, 0xc5, 0x7a, 0x17, 0xbd, 0x0f, 0x55, 0xed, 0xc7, 0x11, 0x00,
	0x15, 0x18, 0xd0, 0xaa, 0x2d, 0x32, 0x15, 0xb1, 0x90, 0x49, 0xec, 0x53, 0x32, 0x72, 0x5c, 0x2e,
	0xf1, 0xe4, 0x71, 0x45, 0x6b, 0x9e, 0x71, 0xf4, 0x31, 0x80, 0x70, 0xcf, 0xb8, 0xcb, 0x13, 0x66,
	0x81, 0x4c, 0xdf, 0xcc, 0xd7, 0xae, 0xd4, 0x62, 0x51, 0x2c, 0xb5, 0x44, 0xf7, 0xa1, 0xc1, 0x88,
	0x17, 0x85, 0x23, 0xed, 0x90, 0x59, 0xd5, 0x96, 0xd9, 0xae, 0xe1, 0xfa, 0x4c, 0xbb, 0x45, 0xa6,
	0xcc, 0xfe, 0xcd, 0x80, 0xf2, 0x76, 0xe4, 0x1d, 0xf5, 0xc3, 0x71, 0x74, 0x19, 0x42, 0x0b, 0x4a,
	0xdc, 0x3f, 0x26, 0x51, 0xa2, 0x20, 0x96, 0x71, 0x2a, 0x2e, 0xa4, 0x0f, 0x16, 0xd2, 0xb7, 0x08,
	0xb9, 0x7a, 0x01, 0xf2, 0x03, 0x28, 0x6a, 0x3c, 0xb5, 0xa5, 0x78, 0xf4, 0xee, 0x12, 0x30, 0xf5,
	0x65, 0x60, 0xbe, 0x82, 0x8a, 0xc0, 0xd2, 0xa3, 0x34, 0xa2, 0x29, 0x91, 0x8c, 0x73, 0x22, 0xdd,
	0x81, 0xbc, 0x1f, 0x8e, 0x23, 0x5d, 0xa7, 0xba, 0xf4, 0x95, 0x62, 0xc7, 0x72, 0xcb, 0xf6, 0xa0,
	0xbe, 0x17, 0xce, 0x13, 0x64, 0xd9, 0x2d, 0x59, 0x56, 0xe5, 0x96, 0xb2, 0xca, 0xf5, 0x78, 0xe2,
	0x06, 0xd2, 0xc0, 0x54, 0x95, 0x54, 0x9a, 0x7d, 0x42, 0xed, 0xa7, 0xd0, 0x50, 0xf8, 0x3a, 0x51,
	0x38, 0x0e, 0x7c, 0x8f, 0xcf, 0xe5, 0xc1, 0x78, 0x5b, 0x1e, 0xec, 0x9f, 0x73, 0x92, 0x8f, 0x0a,
	0xe0, 0x27, 0x50, 0x26, 0x94, 0x3a, 0x7c, 0x1a, 0x13, 0x7d, 0xec, 0x7a, 0x7a, 0x4c, 0x1a, 0x6c,
	0xf4, 0x28, 0x95, 0xdf, 0x55, 0x89, 0xa8, 0x05, 0x7a, 0x08, 0xe5, 0x20, 0xf2, 0x8e, 0x1c, 0x42,
	0x69, 0x86, 0xac, 0xb3, 0xa4, 0xe1, 0x52, 0xa0, 0x96, 0xe8, 0x73, 0x68, 0x24, 0x61, 0x06, 0xa7,
	0x29, 0x0f, 0x20, 0x79, 0x20, 0x93, 0x23, 0x5c, 0x4f, 0x32, 0x29, 0xfb, 0x02, 0x56, 0x54, 0xb8,
	0x8e, 0xa7, 0xf1, 0x49, 0x32, 0x57, 0x37, 0x57, 0xe5, 0xd9, 0x2c, 0x74, 0xdc, 0x60, 0x19, 0xd9,
	0xde, 0x82, 0x92, 0x8e, 0x1b, 0x55, 0xa1, 0xb4, 0x37, 0xd8, 0x1a, 0xec, 0x7c, 0x3b, 0x68, 0x5e,
	0x43, 0x00, 0xc5, 0xed, 0x9d, 0xce, 0x56, 0xaf, 0xdb, 0x34, 0x10, 0x82, 0xc6, 0xde, 0xa0, 0xf7,
	0xdd, 0xab, 0x5e, 0x67, 0xd8, 0xeb, 0x3a, 0xfb, 0x3d, 0xdc, 0xcc, 0xa1, 0x55, 0x58, 0xd9, 0x1d,
	0x3e, 0x1b, 0xee, 0xed, 0x3a, 0x9d, 0x9d, 0xc1, 0x8b, 0xed, 0x7e, 0x67, 0xd8, 0x34, 0xed, 0xbf,
	0x0d, 0x68, 0xbc, 0xa2, 0x24, 0x76, 0x29, 0xc1, 0xe4, 0x24, 0x21, 0x8c, 0x5f, 0xc6, 0xf1, 0x35,
	0x28, 0x04, 0x91, 0xe7, 0x06, 0x9a, 0xe1, 0x4a, 0x40, 0x6d, 0x28, 0xa9, 0xaf, 0x97, 0x59, 0x66,
	0xcb, 0x5c, 0xf2, 0x71, 0xa7, 0xdb, 0x8b, 0x54, 0xcf, 0x5f, 0xa0, 0xfa, 0xff, 0x75, 0xee, 0x39,
	0x0f, 0x74, 0x23, 0x92, 0xb9, 0x1e, 0xf2, 0x60, 0x09, 0xbb, 0x8b, 0x4b, 0xd8, 0x2d, 0x88, 0xc7,
	0x38, 0xf5, 0x3d, 0xee, 0xc8, 0x26, 0x67, 0x35, 0x55, 0xc7, 0x53, 0xba, 0x8e, 0x50, 0xd9, 0x4f,
	0x61, 0x65, 0x06, 0x97, 0xc5, 0x51, 0xc8, 0x08, 0xba, 0x0f, 0x45, 0x22, 0x4a, 0x2b, 0xa8, 0x65,
	0xce, 0x68, 0x9f, 0x72, 0x04, 0xeb, 0x4d, 0xdb, 0x87, 0x66, 0x97, 0x2d, 0xa4, 0x6a, 0x03, 0x8a,
	0x87, 0xc4, 0x1d, 0x11, 0x2a, 0x53, 0x55, 0xdd, 0xbc, 0xb1, 0x91, 0x76, 0x79, 0x6d, 0xf1, 0x8d,
	0xdc, 0xc5, 0xda, 0x0a, 0xdd, 0x07, 0x93, 0x92, 0x13, 0xcd, 0x2c, 0x55, 0xec, 0xec, 0x8d, 0x58,
	0xec, 0xdb, 0x21, 0xfc, 0x6f, 0xce, 0x95, 0x0e, 0xf3, 0xf1, 0x82, 0xaf, 0x9b, 0x73, 0xbe, 0x94,
	0xc9, 0x82, 0xb3, 0x36, 0xe4, 0x29, 0x61, 0xb1, 0xf6, 0xb6, 0x96, 0xf5, 0xa6, 0x4e, 0x60, 0x69,
	0x61, 0xff, 0x00, 0xf5, 0x2e, 0xf1, 0xfc, 0xd1, 0xbf, 0x51, 0xe0, 0xfc, 0x23, 0xcc, 0xbd, 0xb5,
	0x19, 0x21, 0xc8, 0xcb, 0x22, 0x99, 0xb2, 0x48, 0x72, 0x2d, 0xaa, 0xeb, 0x05, 0xc4, 0xa5, 0x4e,
	0x12, 0xeb, 0x97, 0xa8, 0x24, 0xe5, 0xbd, 0xd8, 0xfe, 0x0c, 0x1a, 0xa9, 0xfb, 0xab, 0x95, 0xe4,
	0x00, 0x56, 0xba, 0x2c, 0x1b, 0xf9, 0x55, 0x2b, 0x72, 0x6f, 0xbe, 0x22, 0xea, 0xd3, 0xcd, 0x5c,
	0xa8, 0x0a, 0x12, 0x88, 0xda, 0x2f, 0xc4, 0x78, 0xe5, 0x7a, 0x7c, 0x90, 0xa9, 0xc7, 0x6a, 0xc6,
	0x57, 0xa6, 0x1c, 0x5f, 0x02, 0xfa, 0x9a, 0xf0, 0x59, 0xdf, 0xd5, 0xc8, 0x2e, 0xf6, 0xd9, 0xf3,
	0x2a, 0xe5, 0xe6, 0xaa, 0x64, 0x3f, 0x85, 0xd5, 0xcc, 0x71, 0x1d, 0x6f, 0xda, 0xdb, 0x8d, 0xcb,
	0x7b, 0xfb, 0x09, 0xac, 0x75, 0xd9, 0x12, 0xd7, 0x57, 0x4d, 0xea, 0xc3, 0xf9, 0xa4, 0xde, 0x94,
	0x9e, 0x2e, 0xde, 0xaa, 0x32, 0x7b, 0x0a, 0xd7, 0x17, 0x5c, 0xfe, 0xd7, 0xf4, 0x7e, 0x94, 0x49,
	0xaf, 0x75, 0xd1, 0x6b, 0x26, 0xc7, 0x3f, 0xe6, 0xa0, 0xbe, 0x4b, 0x02, 0xe2, 0xf1, 0xcb, 0xf3,
	0x7b, 0x0f, 0x0a, 0xcc, 0x8b, 0x62, 0x32, 0x7b, 0x09, 0xd2, 0x08, 0x76, 0x85, 0x16, 0xab, 0x4d,
	0xf4, 0x04, 0x60, 0xec, 0x93, 0x60, 0xe4, 0x04, 0x3e, 0xe3, 0xba, 0x09, 0xae, 0x9d, 0x9b, 0x4a,
	0x1f, 0x2f, 0x84, 0x01, 0xae, 0x48, 0xbb, 0x6d, 0x9f, 0x71, 0xf4, 0x04, 0xea, 0x67, 0x87, 0x84,
	0x12, 0x67, 0xec, 0x07, 0x9c, 0x50, 0x66, 0xe5, 0x75, 0xf3, 0x4c, 0xcf, 0xbd, 0x74, 0xb9, 0x77,
	0x88, 0x6b, 0xd2, 0xe8, 0x85, 0xb2, 0x41, 0x1f, 0x42, 0xe5, 0x80, 0x46, 0x49, 0xec, 0xbc, 0x9e,
	0x32, 0xab, 0xa0, 0x0f, 0xe8, 0x39, 0xb2, 0x13, 0x05, 0xc9, 0x71, 0x88, 0xcb, 0xd2, 0xe0, 0xf9,
	0x94, 0x89, 0xe0, 0x03, 0xff, 0xd8, 0xe7, 0x72, 0x64, 0x9b, 0xbf, 0x79, 0x5b, 0x68, 0xb1, 0xda,
	0xb4, 0x5d, 0x28, 0xe3, 0xe8, 0x4c, 0x4d, 0x6f, 0x37, 0xa0, 0x28, 0x03, 0x64, 0x3a, 0x07, 0x5a,
	0x42, 0x77, 0xa1, 0xee, 0x1e, 0x1c, 0x88, 0xa1, 0xcb, 0x8b, 0x12, 0xd1, 0xe8, 0x73, 0x2d, 0xb3,
	0x6d, 0xe2, 0x9a, 0x52, 0x76, 0xa4, 0x4e, 0x4c, 0x40, 0xa7, 0x84, 0x32, 0x3f, 0x0a, 0xf5, 0x6b,
	0x9e, 0x8a, 0xf6, 0x21, 0x54, 0x70, 0x74, 0xa6, 0x47, 0xdb, 0x4b, 0x1a, 0xcb, 0xc2, 0xdb, 0x90,
	0xbb, 0xf0, 0x36, 0xdc, 0x4d, 0x27, 0x5c, 0x98, 0x63, 0x6f, 0x1a, 0xb9, 0x1e, 0x78, 0xed, 0x11,
	0x98, 0x38, 0x3a, 0x5b, 0x52, 0xc8, 0xd9, 0xe9, 0xdc, 0xe5, 0xa7, 0xe7, 0xa6, 0x54, 0x73, 0xee,
	0xe1, 0x9f, 0x85, 0x9e, 0x4e, 0xa9, 0xf6, 0xf7, 0xd0, 0x48, 0x89, 0xa3, 0xa9, 0x8a, 0x20, 0xef,
	0x45, 0x23, 0x35, 0x62, 0x14, 0xb0, 0x5c, 0xa3, 0xf7, 0x20, 0x4f, 0xa3, 0x33, 0x95, 0xab, 0xea,
	0x66, 0x39, 0xbd, 0x0b, 0x4b, 0xad, 0x48, 0x75, 0x34, 0x1e, 0x33, 0xc2, 0x75, 0xb2, 0xb4, 0xa4,
	0x1a, 0x5a, 0x96, 0x96, 0xef, 0xa0, 0xa1, 0x65, 0x2e, 0x9c, 0x6b, 0x68, 0x0b, 0x30, 0xde, 0x49,
	0x43, 0xcb, 0xde, 0xa9, 0x3e, 0xb6, 0x47, 0x2d, 0x28, 0xaa, 0x1f, 0x18, 0x31, 0xa3, 0xf4, 0x07,
	0xbb, 0x3d, 0x3c, 0x54, 0xf3, 0x4a, 0xb7, 0xb7, 0xdd, 0x1b, 0xf6, 0x9a, 0xc6, 0xa3, 0x4f, 0xe5,
	0xff, 0x8f, 0x1e, 0xcc, 0xcb, 0x90, 0xef, 0x0f, 0xfa, 0xc2, 0xa4, 0x0e, 0x95, 0xce, 0xce, 0xcb,
	0x97, 0xfd, 0xe1, 0x50, 0x4e, 0x35, 0x55, 0x28, 0x3d, 0x7b, 0xbe, 0x83, 0x85, 0x90, 0x7b, 0xde,
	0xfc, 0xf5, 0xcd, 0xba, 0xf1, 0xfb, 0x9b, 0x75, 0xe3, 0xcf, 0x37, 0xeb, 0xc6, 0x4f, 0x7f, 0xad,
	0x5f, 0x7b, 0x5d, 0x94, 0x3f, 0x53, 0x4f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x1e, 0xc7, 0x35,
	0xc9, 0x91, 0x0d, 0x00, 0x00,
}
