// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eventpb.proto

/*
	Package eventpb is a generated protocol buffer package.

	It is generated from these files:
		eventpb.proto

	It has these top-level messages:
		EventRangeSplitAck
		EventRangeSplitKey
		EventRangeDeleteAck
		EventRaftErr
		EventStoreErr
		EventNodeBuildAck
		EventEventStatistics
		Event
*/
package eventpb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"

	metapb "model/pkg/metapb"

	_ "github.com/gogo/protobuf/gogoproto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EventType int32

const (
	EventType_RangeSplitAck   EventType = 0
	EventType_RaftErr         EventType = 1
	EventType_NodeBuildAck    EventType = 2
	EventType_RangeDeleteAck  EventType = 3
	EventType_EventStatistics EventType = 4
	EventType_RangeSplitKey   EventType = 5
	EventType_StoreErr        EventType = 6
)

var EventType_name = map[int32]string{
	0: "RangeSplitAck",
	1: "RaftErr",
	2: "NodeBuildAck",
	3: "RangeDeleteAck",
	4: "EventStatistics",
	5: "RangeSplitKey",
	6: "StoreErr",
}
var EventType_value = map[string]int32{
	"RangeSplitAck":   0,
	"RaftErr":         1,
	"NodeBuildAck":    2,
	"RangeDeleteAck":  3,
	"EventStatistics": 4,
	"RangeSplitKey":   5,
	"StoreErr":        6,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}
func (EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{0} }

type StatisticsType int32

const (
	StatisticsType_RaftSplit     StatisticsType = 0
	StatisticsType_ApplySnapshot StatisticsType = 1
	StatisticsType_LeaderLose    StatisticsType = 2
	StatisticsType_PeerAdd       StatisticsType = 3
	StatisticsType_PeerRemove    StatisticsType = 4
	StatisticsType_LeaderReign   StatisticsType = 5
)

var StatisticsType_name = map[int32]string{
	0: "RaftSplit",
	1: "ApplySnapshot",
	2: "LeaderLose",
	3: "PeerAdd",
	4: "PeerRemove",
	5: "LeaderReign",
}
var StatisticsType_value = map[string]int32{
	"RaftSplit":     0,
	"ApplySnapshot": 1,
	"LeaderLose":    2,
	"PeerAdd":       3,
	"PeerRemove":    4,
	"LeaderReign":   5,
}

func (x StatisticsType) String() string {
	return proto.EnumName(StatisticsType_name, int32(x))
}
func (StatisticsType) EnumDescriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{1} }

type EventRangeSplitAck struct {
	TaskId     uint64        `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	Range      *metapb.Range `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	LeftRange  *metapb.Range `protobuf:"bytes,3,opt,name=left_range,json=leftRange" json:"left_range,omitempty"`
	RightRange *metapb.Range `protobuf:"bytes,4,opt,name=right_range,json=rightRange" json:"right_range,omitempty"`
}

func (m *EventRangeSplitAck) Reset()                    { *m = EventRangeSplitAck{} }
func (m *EventRangeSplitAck) String() string            { return proto.CompactTextString(m) }
func (*EventRangeSplitAck) ProtoMessage()               {}
func (*EventRangeSplitAck) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{0} }

func (m *EventRangeSplitAck) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *EventRangeSplitAck) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *EventRangeSplitAck) GetLeftRange() *metapb.Range {
	if m != nil {
		return m.LeftRange
	}
	return nil
}

func (m *EventRangeSplitAck) GetRightRange() *metapb.Range {
	if m != nil {
		return m.RightRange
	}
	return nil
}

type EventRangeSplitKey struct {
	TaskId   uint64        `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	Range    *metapb.Range `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	SplitKey []byte        `protobuf:"bytes,3,opt,name=split_key,json=splitKey,proto3" json:"split_key,omitempty"`
}

func (m *EventRangeSplitKey) Reset()                    { *m = EventRangeSplitKey{} }
func (m *EventRangeSplitKey) String() string            { return proto.CompactTextString(m) }
func (*EventRangeSplitKey) ProtoMessage()               {}
func (*EventRangeSplitKey) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{1} }

func (m *EventRangeSplitKey) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *EventRangeSplitKey) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *EventRangeSplitKey) GetSplitKey() []byte {
	if m != nil {
		return m.SplitKey
	}
	return nil
}

type EventRangeDeleteAck struct {
	TaskId uint64        `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	Range  *metapb.Range `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
}

func (m *EventRangeDeleteAck) Reset()                    { *m = EventRangeDeleteAck{} }
func (m *EventRangeDeleteAck) String() string            { return proto.CompactTextString(m) }
func (*EventRangeDeleteAck) ProtoMessage()               {}
func (*EventRangeDeleteAck) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{2} }

func (m *EventRangeDeleteAck) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *EventRangeDeleteAck) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type EventRaftErr struct {
	NodeId  uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeId uint64 `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Error   string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *EventRaftErr) Reset()                    { *m = EventRaftErr{} }
func (m *EventRaftErr) String() string            { return proto.CompactTextString(m) }
func (*EventRaftErr) ProtoMessage()               {}
func (*EventRaftErr) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{3} }

func (m *EventRaftErr) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *EventRaftErr) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *EventRaftErr) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type EventStoreErr struct {
	NodeId  uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeId uint64 `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Error   string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *EventStoreErr) Reset()                    { *m = EventStoreErr{} }
func (m *EventStoreErr) String() string            { return proto.CompactTextString(m) }
func (*EventStoreErr) ProtoMessage()               {}
func (*EventStoreErr) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{4} }

func (m *EventStoreErr) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *EventStoreErr) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *EventStoreErr) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type EventNodeBuildAck struct {
	Ip  string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Err string `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *EventNodeBuildAck) Reset()                    { *m = EventNodeBuildAck{} }
func (m *EventNodeBuildAck) String() string            { return proto.CompactTextString(m) }
func (*EventNodeBuildAck) ProtoMessage()               {}
func (*EventNodeBuildAck) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{5} }

func (m *EventNodeBuildAck) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *EventNodeBuildAck) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventNodeBuildAck) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type EventEventStatistics struct {
	DbName         string         `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName      string         `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	RangeId        uint64         `protobuf:"varint,3,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	NodeId         uint64         `protobuf:"varint,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StartTime      int64          `protobuf:"varint,5,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime        int64          `protobuf:"varint,6,opt,name=endTime,proto3" json:"endTime,omitempty"`
	StatisticsType StatisticsType `protobuf:"varint,7,opt,name=statisticsType,proto3,enum=eventpb.StatisticsType" json:"statisticsType,omitempty"`
}

func (m *EventEventStatistics) Reset()                    { *m = EventEventStatistics{} }
func (m *EventEventStatistics) String() string            { return proto.CompactTextString(m) }
func (*EventEventStatistics) ProtoMessage()               {}
func (*EventEventStatistics) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{6} }

func (m *EventEventStatistics) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *EventEventStatistics) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *EventEventStatistics) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *EventEventStatistics) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *EventEventStatistics) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *EventEventStatistics) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *EventEventStatistics) GetStatisticsType() StatisticsType {
	if m != nil {
		return m.StatisticsType
	}
	return StatisticsType_RaftSplit
}

type Event struct {
	Type                 EventType             `protobuf:"varint,1,opt,name=type,proto3,enum=eventpb.EventType" json:"type,omitempty"`
	EventRangeSplitAck   *EventRangeSplitAck   `protobuf:"bytes,2,opt,name=event_range_split_ack,json=eventRangeSplitAck" json:"event_range_split_ack,omitempty"`
	EventRaftErr         *EventRaftErr         `protobuf:"bytes,3,opt,name=event_raft_err,json=eventRaftErr" json:"event_raft_err,omitempty"`
	EventNodeBuildAck    *EventNodeBuildAck    `protobuf:"bytes,4,opt,name=event_node_build_ack,json=eventNodeBuildAck" json:"event_node_build_ack,omitempty"`
	EventRangeDeleteAck  *EventRangeDeleteAck  `protobuf:"bytes,5,opt,name=event_range_delete_ack,json=eventRangeDeleteAck" json:"event_range_delete_ack,omitempty"`
	EventEventStatistics *EventEventStatistics `protobuf:"bytes,6,opt,name=event_event_statistics,json=eventEventStatistics" json:"event_event_statistics,omitempty"`
	EventRangeSplitKey   *EventRangeSplitKey   `protobuf:"bytes,7,opt,name=event_range_split_key,json=eventRangeSplitKey" json:"event_range_split_key,omitempty"`
	EventStoreErr        *EventStoreErr        `protobuf:"bytes,8,opt,name=event_store_err,json=eventStoreErr" json:"event_store_err,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorEventpb, []int{7} }

func (m *Event) GetType() EventType {
	if m != nil {
		return m.Type
	}
	return EventType_RangeSplitAck
}

func (m *Event) GetEventRangeSplitAck() *EventRangeSplitAck {
	if m != nil {
		return m.EventRangeSplitAck
	}
	return nil
}

func (m *Event) GetEventRaftErr() *EventRaftErr {
	if m != nil {
		return m.EventRaftErr
	}
	return nil
}

func (m *Event) GetEventNodeBuildAck() *EventNodeBuildAck {
	if m != nil {
		return m.EventNodeBuildAck
	}
	return nil
}

func (m *Event) GetEventRangeDeleteAck() *EventRangeDeleteAck {
	if m != nil {
		return m.EventRangeDeleteAck
	}
	return nil
}

func (m *Event) GetEventEventStatistics() *EventEventStatistics {
	if m != nil {
		return m.EventEventStatistics
	}
	return nil
}

func (m *Event) GetEventRangeSplitKey() *EventRangeSplitKey {
	if m != nil {
		return m.EventRangeSplitKey
	}
	return nil
}

func (m *Event) GetEventStoreErr() *EventStoreErr {
	if m != nil {
		return m.EventStoreErr
	}
	return nil
}

func init() {
	proto.RegisterType((*EventRangeSplitAck)(nil), "eventpb.EventRangeSplitAck")
	proto.RegisterType((*EventRangeSplitKey)(nil), "eventpb.EventRangeSplitKey")
	proto.RegisterType((*EventRangeDeleteAck)(nil), "eventpb.EventRangeDeleteAck")
	proto.RegisterType((*EventRaftErr)(nil), "eventpb.EventRaftErr")
	proto.RegisterType((*EventStoreErr)(nil), "eventpb.EventStoreErr")
	proto.RegisterType((*EventNodeBuildAck)(nil), "eventpb.EventNodeBuildAck")
	proto.RegisterType((*EventEventStatistics)(nil), "eventpb.EventEventStatistics")
	proto.RegisterType((*Event)(nil), "eventpb.Event")
	proto.RegisterEnum("eventpb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("eventpb.StatisticsType", StatisticsType_name, StatisticsType_value)
}
func (m *EventRangeSplitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRangeSplitAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.TaskId))
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.Range.Size()))
		n1, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.LeftRange != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.LeftRange.Size()))
		n2, err := m.LeftRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.RightRange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.RightRange.Size()))
		n3, err := m.RightRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *EventRangeSplitKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRangeSplitKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.TaskId))
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.Range.Size()))
		n4, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.SplitKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.SplitKey)))
		i += copy(dAtA[i:], m.SplitKey)
	}
	return i, nil
}

func (m *EventRangeDeleteAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRangeDeleteAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.TaskId))
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.Range.Size()))
		n5, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *EventRaftErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRaftErr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.NodeId))
	}
	if m.RangeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.RangeId))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *EventStoreErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStoreErr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.NodeId))
	}
	if m.RangeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.RangeId))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *EventNodeBuildAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNodeBuildAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Err) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.Err)))
		i += copy(dAtA[i:], m.Err)
	}
	return i, nil
}

func (m *EventEventStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEventStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DbName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if len(m.TableName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if m.RangeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.NodeId))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EndTime))
	}
	if m.StatisticsType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.StatisticsType))
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.Type))
	}
	if m.EventRangeSplitAck != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventRangeSplitAck.Size()))
		n6, err := m.EventRangeSplitAck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.EventRaftErr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventRaftErr.Size()))
		n7, err := m.EventRaftErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.EventNodeBuildAck != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventNodeBuildAck.Size()))
		n8, err := m.EventNodeBuildAck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.EventRangeDeleteAck != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventRangeDeleteAck.Size()))
		n9, err := m.EventRangeDeleteAck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.EventEventStatistics != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventEventStatistics.Size()))
		n10, err := m.EventEventStatistics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.EventRangeSplitKey != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventRangeSplitKey.Size()))
		n11, err := m.EventRangeSplitKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.EventStoreErr != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEventpb(dAtA, i, uint64(m.EventStoreErr.Size()))
		n12, err := m.EventStoreErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func encodeVarintEventpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EventRangeSplitAck) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovEventpb(uint64(m.TaskId))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.LeftRange != nil {
		l = m.LeftRange.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.RightRange != nil {
		l = m.RightRange.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func (m *EventRangeSplitKey) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovEventpb(uint64(m.TaskId))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func (m *EventRangeDeleteAck) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovEventpb(uint64(m.TaskId))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func (m *EventRaftErr) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovEventpb(uint64(m.NodeId))
	}
	if m.RangeId != 0 {
		n += 1 + sovEventpb(uint64(m.RangeId))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func (m *EventStoreErr) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovEventpb(uint64(m.NodeId))
	}
	if m.RangeId != 0 {
		n += 1 + sovEventpb(uint64(m.RangeId))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func (m *EventNodeBuildAck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func (m *EventEventStatistics) Size() (n int) {
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.RangeId != 0 {
		n += 1 + sovEventpb(uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovEventpb(uint64(m.NodeId))
	}
	if m.StartTime != 0 {
		n += 1 + sovEventpb(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovEventpb(uint64(m.EndTime))
	}
	if m.StatisticsType != 0 {
		n += 1 + sovEventpb(uint64(m.StatisticsType))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovEventpb(uint64(m.Type))
	}
	if m.EventRangeSplitAck != nil {
		l = m.EventRangeSplitAck.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.EventRaftErr != nil {
		l = m.EventRaftErr.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.EventNodeBuildAck != nil {
		l = m.EventNodeBuildAck.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.EventRangeDeleteAck != nil {
		l = m.EventRangeDeleteAck.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.EventEventStatistics != nil {
		l = m.EventEventStatistics.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.EventRangeSplitKey != nil {
		l = m.EventRangeSplitKey.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	if m.EventStoreErr != nil {
		l = m.EventStoreErr.Size()
		n += 1 + l + sovEventpb(uint64(l))
	}
	return n
}

func sovEventpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEventpb(x uint64) (n int) {
	return sovEventpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventRangeSplitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRangeSplitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRangeSplitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftRange == nil {
				m.LeftRange = &metapb.Range{}
			}
			if err := m.LeftRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightRange == nil {
				m.RightRange = &metapb.Range{}
			}
			if err := m.RightRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRangeSplitKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRangeSplitKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRangeSplitKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRangeDeleteAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRangeDeleteAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRangeDeleteAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRaftErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRaftErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRaftErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStoreErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStoreErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStoreErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNodeBuildAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNodeBuildAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNodeBuildAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEventStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEventStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEventStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatisticsType", wireType)
			}
			m.StatisticsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatisticsType |= (StatisticsType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventRangeSplitAck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventRangeSplitAck == nil {
				m.EventRangeSplitAck = &EventRangeSplitAck{}
			}
			if err := m.EventRangeSplitAck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventRaftErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventRaftErr == nil {
				m.EventRaftErr = &EventRaftErr{}
			}
			if err := m.EventRaftErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNodeBuildAck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventNodeBuildAck == nil {
				m.EventNodeBuildAck = &EventNodeBuildAck{}
			}
			if err := m.EventNodeBuildAck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventRangeDeleteAck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventRangeDeleteAck == nil {
				m.EventRangeDeleteAck = &EventRangeDeleteAck{}
			}
			if err := m.EventRangeDeleteAck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventEventStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventEventStatistics == nil {
				m.EventEventStatistics = &EventEventStatistics{}
			}
			if err := m.EventEventStatistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventRangeSplitKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventRangeSplitKey == nil {
				m.EventRangeSplitKey = &EventRangeSplitKey{}
			}
			if err := m.EventRangeSplitKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventStoreErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEventpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventStoreErr == nil {
				m.EventStoreErr = &EventStoreErr{}
			}
			if err := m.EventStoreErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEventpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEventpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEventpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEventpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEventpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEventpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEventpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEventpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEventpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEventpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("eventpb.proto", fileDescriptorEventpb) }

var fileDescriptorEventpb = []byte{
	// 745 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0xdd, 0x6a, 0x13, 0x41,
	0x14, 0x80, 0xbb, 0xf9, 0xdf, 0x93, 0x9f, 0x4e, 0xa7, 0x69, 0x1b, 0xfb, 0x13, 0x42, 0x04, 0x09,
	0x45, 0x22, 0xc4, 0x4b, 0x41, 0x69, 0xb1, 0x48, 0x49, 0x29, 0x3a, 0xe9, 0x85, 0x5e, 0x85, 0x4d,
	0xf7, 0x34, 0x5d, 0xf2, 0xb3, 0xcb, 0xec, 0x58, 0xc8, 0x13, 0xf8, 0x0a, 0x3e, 0x86, 0xaf, 0xe0,
	0x9d, 0x97, 0x3e, 0x82, 0xd4, 0xc7, 0xf0, 0x46, 0xe6, 0xcc, 0x6e, 0x9a, 0x4d, 0x82, 0x37, 0xf5,
	0x26, 0xcc, 0x99, 0x73, 0xce, 0x37, 0xe7, 0x77, 0x03, 0x65, 0xbc, 0xc3, 0xa9, 0x0a, 0x06, 0xed,
	0x40, 0xfa, 0xca, 0xe7, 0xf9, 0x48, 0xdc, 0x2f, 0x4d, 0x50, 0x39, 0xf1, 0xf5, 0x7e, 0x75, 0xe8,
	0x0f, 0x7d, 0x3a, 0xbe, 0xd0, 0x27, 0x73, 0xdb, 0xfc, 0x66, 0x01, 0x3f, 0xd3, 0xf6, 0xc2, 0x99,
	0x0e, 0xb1, 0x17, 0x8c, 0x3d, 0x75, 0x72, 0x3d, 0xe2, 0x7b, 0x90, 0x57, 0x4e, 0x38, 0xea, 0x7b,
	0x6e, 0xcd, 0x6a, 0x58, 0xad, 0x8c, 0xc8, 0x69, 0xf1, 0xdc, 0xe5, 0x4f, 0x21, 0x2b, 0xb5, 0x65,
	0x2d, 0xd5, 0xb0, 0x5a, 0xc5, 0x4e, 0xb9, 0x1d, 0xbd, 0x41, 0xee, 0xc2, 0xe8, 0xf8, 0x73, 0x80,
	0x31, 0xde, 0xa8, 0xbe, 0xb1, 0x4c, 0xaf, 0xb3, 0xb4, 0xb5, 0x01, 0x1d, 0x79, 0x1b, 0x8a, 0xd2,
	0x1b, 0xde, 0xc6, 0xe6, 0x99, 0x75, 0xe6, 0x40, 0x16, 0x74, 0x6e, 0xfa, 0x2b, 0x11, 0x77, 0x71,
	0xf6, 0xc8, 0x88, 0x0f, 0xc0, 0x0e, 0x35, 0xa9, 0x3f, 0xc2, 0x19, 0x05, 0x5c, 0x12, 0x85, 0x30,
	0x42, 0x37, 0x7b, 0xb0, 0xfd, 0xf0, 0xe0, 0x5b, 0x1c, 0xa3, 0xc2, 0x47, 0xd7, 0xa8, 0xf9, 0x11,
	0x4a, 0x11, 0xf4, 0x46, 0x9d, 0x49, 0xa9, 0x69, 0x53, 0xdf, 0xc5, 0x05, 0x9a, 0x16, 0xcf, 0x5d,
	0xfe, 0x04, 0x0a, 0xe4, 0xa1, 0x35, 0x29, 0xd2, 0xe4, 0x49, 0x3e, 0x77, 0x79, 0x15, 0xb2, 0x28,
	0xa5, 0x2f, 0x29, 0x62, 0x5b, 0x18, 0xa1, 0xf9, 0x09, 0xca, 0x44, 0xee, 0x29, 0x5f, 0xe2, 0xff,
	0x45, 0xbf, 0x83, 0x2d, 0x42, 0x5f, 0xfa, 0x2e, 0x9e, 0x7e, 0xf6, 0xc6, 0xae, 0xae, 0x43, 0x05,
	0x52, 0x5e, 0x40, 0x64, 0x5b, 0xa4, 0xbc, 0x80, 0x33, 0x48, 0xeb, 0x2a, 0xa6, 0xe8, 0x42, 0x1f,
	0xf5, 0x0d, 0xca, 0x18, 0xa5, 0x8f, 0xcd, 0x3f, 0x16, 0x54, 0x89, 0x14, 0x45, 0xea, 0x28, 0x2f,
	0x54, 0xde, 0x75, 0xa8, 0x63, 0x75, 0x07, 0xfd, 0xa9, 0x33, 0xc1, 0x88, 0x98, 0x73, 0x07, 0x97,
	0xce, 0x04, 0xf9, 0x11, 0x80, 0x72, 0x06, 0x63, 0x34, 0x3a, 0x03, 0xb7, 0xe9, 0x86, 0xd4, 0x8b,
	0xa9, 0xa4, 0x93, 0xa9, 0x2c, 0xa4, 0x9f, 0x49, 0xa4, 0x7f, 0x08, 0x76, 0xa8, 0x1c, 0xa9, 0xae,
	0xbc, 0x09, 0xd6, 0xb2, 0x0d, 0xab, 0x95, 0x16, 0x0f, 0x17, 0xbc, 0x06, 0x79, 0x9c, 0xba, 0xa4,
	0xcb, 0x91, 0x2e, 0x16, 0xf9, 0x1b, 0xa8, 0x84, 0xf3, 0x88, 0xaf, 0x66, 0x01, 0xd6, 0xf2, 0x0d,
	0xab, 0x55, 0xe9, 0xec, 0xb5, 0xe3, 0x45, 0xec, 0x25, 0xd4, 0x62, 0xc9, 0xbc, 0xf9, 0x3d, 0x03,
	0x59, 0x4a, 0x9c, 0x3f, 0x83, 0x8c, 0xd2, 0x00, 0x8b, 0x00, 0x7c, 0x0e, 0x20, 0x2d, 0xf9, 0x92,
	0x9e, 0x5f, 0xc2, 0x0e, 0xa9, 0xcc, 0x8e, 0xf4, 0xcd, 0xac, 0x3a, 0xd7, 0xa3, 0x68, 0xc4, 0x0e,
	0x92, 0x8e, 0x89, 0x5d, 0x16, 0x1c, 0x57, 0xf7, 0xfb, 0x15, 0x54, 0x62, 0xde, 0x8d, 0xea, 0xc7,
	0xcd, 0x29, 0x76, 0x76, 0x96, 0x41, 0x34, 0x9c, 0xa2, 0x84, 0x8b, 0xa3, 0xda, 0x85, 0xaa, 0x71,
	0xa6, 0xb2, 0x0e, 0xf4, 0x1c, 0x50, 0x2c, 0x66, 0x73, 0xf7, 0x93, 0x88, 0xc5, 0x51, 0x11, 0x5b,
	0xb8, 0x32, 0x3d, 0x1f, 0x60, 0x77, 0x31, 0x33, 0x97, 0xd6, 0x8b, 0x70, 0x59, 0xc2, 0x1d, 0xae,
	0x49, 0x6d, 0xbe, 0x83, 0x62, 0x1b, 0xd7, 0x2c, 0x66, 0x2f, 0x46, 0x9a, 0xdf, 0x87, 0xe2, 0x53,
	0x23, 0x8b, 0x9d, 0xa3, 0x24, 0x72, 0x69, 0x04, 0x85, 0x49, 0x6e, 0x79, 0x30, 0xd7, 0x76, 0x40,
	0xcf, 0x79, 0xfe, 0xdf, 0x1d, 0xe8, 0xe2, 0x6c, 0xa5, 0x03, 0xfa, 0x7b, 0xf5, 0x1a, 0x36, 0xe3,
	0xf0, 0x7c, 0x89, 0xd4, 0x82, 0x02, 0x91, 0x76, 0x93, 0xa4, 0x78, 0x8b, 0x85, 0xf9, 0xca, 0xc7,
	0xe2, 0xf1, 0x17, 0x0b, 0xec, 0xf9, 0x94, 0xf0, 0x2d, 0x28, 0x27, 0x1a, 0xcc, 0x36, 0x78, 0x11,
	0xf2, 0x51, 0xc3, 0x98, 0xc5, 0x19, 0x94, 0x16, 0xab, 0xce, 0x52, 0x9c, 0x43, 0x25, 0x59, 0x36,
	0x96, 0xe6, 0xdb, 0xb0, 0xb9, 0x94, 0x36, 0xcb, 0x24, 0xd1, 0x5d, 0x9c, 0xb1, 0x2c, 0x2f, 0x41,
	0x21, 0x8e, 0x83, 0xe5, 0x8e, 0x03, 0xa8, 0x24, 0xe7, 0x9d, 0x97, 0xc1, 0xd6, 0x4f, 0x93, 0x07,
	0xdb, 0xd0, 0x84, 0x93, 0x20, 0x18, 0xcf, 0x7a, 0x53, 0x27, 0x08, 0x6f, 0x7d, 0xc5, 0x2c, 0x5e,
	0x01, 0xb8, 0x40, 0xc7, 0x45, 0x79, 0xe1, 0x87, 0xc8, 0x52, 0x3a, 0xd8, 0xf7, 0x88, 0xf2, 0xc4,
	0x75, 0x59, 0x5a, 0x2b, 0xb5, 0x20, 0x70, 0xe2, 0xdf, 0x21, 0xcb, 0xf0, 0x4d, 0x28, 0x1a, 0x63,
	0x81, 0xde, 0x70, 0xca, 0xb2, 0xa7, 0xec, 0xc7, 0x7d, 0xdd, 0xfa, 0x79, 0x5f, 0xb7, 0x7e, 0xdd,
	0xd7, 0xad, 0xaf, 0xbf, 0xeb, 0x1b, 0x83, 0x1c, 0xfd, 0x9b, 0xbd, 0xfc, 0x1b, 0x00, 0x00, 0xff,
	0xff, 0x13, 0x3b, 0x21, 0x04, 0x0b, 0x07, 0x00, 0x00,
}
