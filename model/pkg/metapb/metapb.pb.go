// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metapb.proto

/*
	Package metapb is a generated protocol buffer package.

	It is generated from these files:
		metapb.proto

	It has these top-level messages:
		Cluster
		NodeLabel
		Node
		Peer
		Replica
		RangeEpoch
		Range
		Leader
		Route
		DataBase
		Column
		Primary
		TableEpoch
		Table
*/
package metapb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"
)

import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 1. 无论什么条件下，除了已经Logout的节点，新旧ds加入集群后，ms都应该将其初始化为Initial状态，
// 由ds自检完成后，通过NodeLogin上报正式启动数据读写服务
// 2. Logout的节点，需要手动Initial
type NodeState int32

const (
	NodeState_N_Invalid NodeState = 0
	// 工作状态，可以提供服务
	NodeState_N_Login NodeState = 1
	// 此状态下节点的range已经全部迁移，必须手动login
	NodeState_N_Logout NodeState = 2
	// 此状态下节点不分配新的range，不迁移range
	NodeState_N_Offline NodeState = 3
	// 此状态下节点不分配新的range，开始逐步迁移range
	NodeState_N_Tombstone NodeState = 4
	// 节点升级
	NodeState_N_Upgrade NodeState = 5
	// 初始状态
	NodeState_N_Initial NodeState = 6
)

var NodeState_name = map[int32]string{
	0: "N_Invalid",
	1: "N_Login",
	2: "N_Logout",
	3: "N_Offline",
	4: "N_Tombstone",
	5: "N_Upgrade",
	6: "N_Initial",
}
var NodeState_value = map[string]int32{
	"N_Invalid":   0,
	"N_Login":     1,
	"N_Logout":    2,
	"N_Offline":   3,
	"N_Tombstone": 4,
	"N_Upgrade":   5,
	"N_Initial":   6,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}
func (NodeState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

type RangeState int32

const (
	RangeState_R_Invalid  RangeState = 0
	RangeState_R_Init     RangeState = 1
	RangeState_R_Normal   RangeState = 2
	RangeState_R_Split    RangeState = 3
	RangeState_R_Merge    RangeState = 4
	RangeState_R_Remove   RangeState = 5
	RangeState_R_LoadSnap RangeState = 6
	RangeState_R_Abnormal RangeState = 7
	RangeState_R_Offline  RangeState = 8
)

var RangeState_name = map[int32]string{
	0: "R_Invalid",
	1: "R_Init",
	2: "R_Normal",
	3: "R_Split",
	4: "R_Merge",
	5: "R_Remove",
	6: "R_LoadSnap",
	7: "R_Abnormal",
	8: "R_Offline",
}
var RangeState_value = map[string]int32{
	"R_Invalid":  0,
	"R_Init":     1,
	"R_Normal":   2,
	"R_Split":    3,
	"R_Merge":    4,
	"R_Remove":   5,
	"R_LoadSnap": 6,
	"R_Abnormal": 7,
	"R_Offline":  8,
}

func (x RangeState) String() string {
	return proto.EnumName(RangeState_name, int32(x))
}
func (RangeState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

type ReplicaRole int32

const (
	ReplicaRole_Role_Invalid ReplicaRole = 0
	// 同步副本
	ReplicaRole_Role_Sync_Replica ReplicaRole = 1
	// 异步副本，不参与raft选举
	ReplicaRole_Role_Async_Replica ReplicaRole = 2
)

var ReplicaRole_name = map[int32]string{
	0: "Role_Invalid",
	1: "Role_Sync_Replica",
	2: "Role_Async_Replica",
}
var ReplicaRole_value = map[string]int32{
	"Role_Invalid":       0,
	"Role_Sync_Replica":  1,
	"Role_Async_Replica": 2,
}

func (x ReplicaRole) String() string {
	return proto.EnumName(ReplicaRole_name, int32(x))
}
func (ReplicaRole) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

type DataType int32

const (
	DataType_Invalid DataType = 0
	// 8 bit interger
	DataType_Tinyint DataType = 1
	// 16 bit interger
	DataType_Smallint DataType = 2
	// 32 bit interger
	DataType_Int DataType = 3
	// 64 bit interger
	DataType_BigInt DataType = 4
	// 32 bit float
	DataType_Float DataType = 5
	// 64 bit float
	DataType_Double DataType = 6
	// string UTF-8 max size 64 KB
	DataType_Varchar DataType = 7
	// Blob max size 64 KB
	DataType_Binary DataType = 8
	// DataTime 从1970年1月1日以来的天数
	DataType_Date DataType = 9
	// DataTime 从1970年1月1日以来的秒数，精确到纳秒
	DataType_TimeStamp DataType = 10
)

var DataType_name = map[int32]string{
	0:  "Invalid",
	1:  "Tinyint",
	2:  "Smallint",
	3:  "Int",
	4:  "BigInt",
	5:  "Float",
	6:  "Double",
	7:  "Varchar",
	8:  "Binary",
	9:  "Date",
	10: "TimeStamp",
}
var DataType_value = map[string]int32{
	"Invalid":   0,
	"Tinyint":   1,
	"Smallint":  2,
	"Int":       3,
	"BigInt":    4,
	"Float":     5,
	"Double":    6,
	"Varchar":   7,
	"Binary":    8,
	"Date":      9,
	"TimeStamp": 10,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}
func (DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

type TableStatus int32

const (
	TableStatus_TableInvalid TableStatus = 0
	// 初始状态，table刚刚创建，分片还不能提供服务
	TableStatus_TableInit TableStatus = 1
	// 准备状态，等待table的初始分片补足三个副本
	TableStatus_TablePrepare TableStatus = 2
	// 正常状态，可以提供完全的服务
	TableStatus_TableRunning TableStatus = 3
	// 标记删除，元数据都保留，允许分片参与调度,但不能分裂
	TableStatus_TableDelete TableStatus = 4
	// 正在删除
	TableStatus_TableDeleting TableStatus = 5
)

var TableStatus_name = map[int32]string{
	0: "TableInvalid",
	1: "TableInit",
	2: "TablePrepare",
	3: "TableRunning",
	4: "TableDelete",
	5: "TableDeleting",
}
var TableStatus_value = map[string]int32{
	"TableInvalid":  0,
	"TableInit":     1,
	"TablePrepare":  2,
	"TableRunning":  3,
	"TableDelete":   4,
	"TableDeleting": 5,
}

func (x TableStatus) String() string {
	return proto.EnumName(TableStatus_name, int32(x))
}
func (TableStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

type Cluster struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// max peer count for a Range.
	// master server will do the auto-balance if Range peer count mismatches.
	MaxPeerCount uint32 `protobuf:"varint,2,opt,name=max_peer_count,json=maxPeerCount,proto3" json:"max_peer_count,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

func (m *Cluster) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Cluster) GetMaxPeerCount() uint32 {
	if m != nil {
		return m.MaxPeerCount
	}
	return 0
}

// Case insensitive key/value for replica constraints.
type NodeLabel struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *NodeLabel) Reset()                    { *m = NodeLabel{} }
func (m *NodeLabel) String() string            { return proto.CompactTextString(m) }
func (*NodeLabel) ProtoMessage()               {}
func (*NodeLabel) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

func (m *NodeLabel) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *NodeLabel) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Node struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// rpc 服务地址
	ServerAddr string `protobuf:"bytes,2,opt,name=server_addr,json=serverAddr,proto3" json:"server_addr,omitempty"`
	// raft　服务地址
	RaftAddr string `protobuf:"bytes,3,opt,name=raft_addr,json=raftAddr,proto3" json:"raft_addr,omitempty"`
	// http 管理地址
	HttpAddr string       `protobuf:"bytes,4,opt,name=http_addr,json=httpAddr,proto3" json:"http_addr,omitempty"`
	State    NodeState    `protobuf:"varint,5,opt,name=state,proto3,enum=metapb.NodeState" json:"state,omitempty"`
	Version  string       `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	Labels   []*NodeLabel `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetServerAddr() string {
	if m != nil {
		return m.ServerAddr
	}
	return ""
}

func (m *Node) GetRaftAddr() string {
	if m != nil {
		return m.RaftAddr
	}
	return ""
}

func (m *Node) GetHttpAddr() string {
	if m != nil {
		return m.HttpAddr
	}
	return ""
}

func (m *Node) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeState_N_Invalid
}

func (m *Node) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Node) GetLabels() []*NodeLabel {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Peer struct {
	Id     uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NodeId uint64      `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Role   ReplicaRole `protobuf:"varint,3,opt,name=role,proto3,enum=metapb.ReplicaRole" json:"role,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

func (m *Peer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Peer) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Peer) GetRole() ReplicaRole {
	if m != nil {
		return m.Role
	}
	return ReplicaRole_Role_Invalid
}

type Replica struct {
	RangeId  uint64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Peer     *Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	StartKey []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *Replica) Reset()                    { *m = Replica{} }
func (m *Replica) String() string            { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()               {}
func (*Replica) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

func (m *Replica) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Replica) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Replica) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Replica) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type RangeEpoch struct {
	// Conf change version, auto increment when add or remove peer
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Range version, auto increment when split or merge
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *RangeEpoch) Reset()                    { *m = RangeEpoch{} }
func (m *RangeEpoch) String() string            { return proto.CompactTextString(m) }
func (*RangeEpoch) ProtoMessage()               {}
func (*RangeEpoch) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{5} }

func (m *RangeEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *RangeEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Range struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Range key range [start_key, end_key).
	// key的组成 prefix + table_id + real key
	StartKey    []byte      `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey      []byte      `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	RangeEpoch  *RangeEpoch `protobuf:"bytes,4,opt,name=range_epoch,json=rangeEpoch" json:"range_epoch,omitempty"`
	Peers       []*Peer     `protobuf:"bytes,5,rep,name=peers" json:"peers,omitempty"`
	TableId     uint64      `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryKeys []*Column   `protobuf:"bytes,7,rep,name=primary_keys,json=primaryKeys" json:"primary_keys,omitempty"`
}

func (m *Range) Reset()                    { *m = Range{} }
func (m *Range) String() string            { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()               {}
func (*Range) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{6} }

func (m *Range) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Range) GetRangeEpoch() *RangeEpoch {
	if m != nil {
		return m.RangeEpoch
	}
	return nil
}

func (m *Range) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Range) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *Range) GetPrimaryKeys() []*Column {
	if m != nil {
		return m.PrimaryKeys
	}
	return nil
}

type Leader struct {
	RangeId  uint64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	NodeId   uint64 `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr string `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
}

func (m *Leader) Reset()                    { *m = Leader{} }
func (m *Leader) String() string            { return proto.CompactTextString(m) }
func (*Leader) ProtoMessage()               {}
func (*Leader) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{7} }

func (m *Leader) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Leader) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Leader) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

type Route struct {
	Range  *Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	Leader *Peer  `protobuf:"bytes,2,opt,name=leader" json:"leader,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{8} }

func (m *Route) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Route) GetLeader() *Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

type DataBase struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id         uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Properties string `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`
	Version    uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	CreateTime int64  `protobuf:"varint,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
}

func (m *DataBase) Reset()                    { *m = DataBase{} }
func (m *DataBase) String() string            { return proto.CompactTextString(m) }
func (*DataBase) ProtoMessage()               {}
func (*DataBase) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{9} }

func (m *DataBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataBase) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DataBase) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *DataBase) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DataBase) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

type Column struct {
	// max size 128 bytes
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 列名映射的ID,客户端不可见
	Id       uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	DataType DataType `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=metapb.DataType" json:"data_type,omitempty"`
	// 针对int类型,是否是无符号类型
	Unsigned bool `protobuf:"varint,4,opt,name=unsigned,proto3" json:"unsigned,omitempty"`
	// 针对float和varchar类型
	Scale int32 `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	// 针对float类型
	Precision int32 `protobuf:"varint,6,opt,name=precision,proto3" json:"precision,omitempty"`
	// 是否可以为空
	Nullable bool `protobuf:"varint,7,opt,name=nullable,proto3" json:"nullable,omitempty"`
	// 是否主键
	PrimaryKey uint64 `protobuf:"varint,8,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// 列的顺序
	Ordinal int32 `protobuf:"varint,9,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	// 索引 Binary不支持索引，其他类型列默认均是索引列
	Index        bool   `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	DefaultValue []byte `protobuf:"bytes,11,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Properties   string `protobuf:"bytes,12,opt,name=properties,proto3" json:"properties,omitempty"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{10} }

func (m *Column) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Column) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Column) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DataType_Invalid
}

func (m *Column) GetUnsigned() bool {
	if m != nil {
		return m.Unsigned
	}
	return false
}

func (m *Column) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Column) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Column) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Column) GetPrimaryKey() uint64 {
	if m != nil {
		return m.PrimaryKey
	}
	return 0
}

func (m *Column) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

func (m *Column) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *Column) GetDefaultValue() []byte {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *Column) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

type Primary struct {
	ColumnName string   `protobuf:"bytes,1,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	Next       *Primary `protobuf:"bytes,2,opt,name=next" json:"next,omitempty"`
}

func (m *Primary) Reset()                    { *m = Primary{} }
func (m *Primary) String() string            { return proto.CompactTextString(m) }
func (*Primary) ProtoMessage()               {}
func (*Primary) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{11} }

func (m *Primary) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *Primary) GetNext() *Primary {
	if m != nil {
		return m.Next
	}
	return nil
}

type TableEpoch struct {
	// Conf change version, auto increment when add or remove column
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Route version, auto increment when split or merge
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *TableEpoch) Reset()                    { *m = TableEpoch{} }
func (m *TableEpoch) String() string            { return proto.CompactTextString(m) }
func (*TableEpoch) ProtoMessage()               {}
func (*TableEpoch) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{12} }

func (m *TableEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *TableEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Table struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DbName string `protobuf:"bytes,2,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	DbId   uint64 `protobuf:"varint,3,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	Id     uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// 必须有主键
	// repeated string primary_key = 4;
	Properties string      `protobuf:"bytes,5,opt,name=properties,proto3" json:"properties,omitempty"`
	Columns    []*Column   `protobuf:"bytes,6,rep,name=columns" json:"columns,omitempty"`
	Epoch      *TableEpoch `protobuf:"bytes,7,opt,name=epoch" json:"epoch,omitempty"`
	Regxs      []*Column   `protobuf:"bytes,8,rep,name=regxs" json:"regxs,omitempty"`
	CreateTime int64       `protobuf:"varint,9,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// 默认不检查主键重复
	PkDupCheck bool `protobuf:"varint,10,opt,name=pk_dup_check,json=pkDupCheck,proto3" json:"pk_dup_check,omitempty"`
	// table status
	Status TableStatus `protobuf:"varint,11,opt,name=status,proto3,enum=metapb.TableStatus" json:"status,omitempty"`
	// table expand area
	// now when status is TableDelete, expand is the delete flag time
	Expand []byte `protobuf:"bytes,12,opt,name=expand,proto3" json:"expand,omitempty"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{13} }

func (m *Table) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Table) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *Table) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Table) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Table) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Table) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *Table) GetEpoch() *TableEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *Table) GetRegxs() []*Column {
	if m != nil {
		return m.Regxs
	}
	return nil
}

func (m *Table) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Table) GetPkDupCheck() bool {
	if m != nil {
		return m.PkDupCheck
	}
	return false
}

func (m *Table) GetStatus() TableStatus {
	if m != nil {
		return m.Status
	}
	return TableStatus_TableInvalid
}

func (m *Table) GetExpand() []byte {
	if m != nil {
		return m.Expand
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*NodeLabel)(nil), "metapb.NodeLabel")
	proto.RegisterType((*Node)(nil), "metapb.Node")
	proto.RegisterType((*Peer)(nil), "metapb.Peer")
	proto.RegisterType((*Replica)(nil), "metapb.Replica")
	proto.RegisterType((*RangeEpoch)(nil), "metapb.RangeEpoch")
	proto.RegisterType((*Range)(nil), "metapb.Range")
	proto.RegisterType((*Leader)(nil), "metapb.Leader")
	proto.RegisterType((*Route)(nil), "metapb.Route")
	proto.RegisterType((*DataBase)(nil), "metapb.DataBase")
	proto.RegisterType((*Column)(nil), "metapb.Column")
	proto.RegisterType((*Primary)(nil), "metapb.Primary")
	proto.RegisterType((*TableEpoch)(nil), "metapb.TableEpoch")
	proto.RegisterType((*Table)(nil), "metapb.Table")
	proto.RegisterEnum("metapb.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("metapb.RangeState", RangeState_name, RangeState_value)
	proto.RegisterEnum("metapb.ReplicaRole", ReplicaRole_name, ReplicaRole_value)
	proto.RegisterEnum("metapb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("metapb.TableStatus", TableStatus_name, TableStatus_value)
}
func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.MaxPeerCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.MaxPeerCount))
	}
	return i, nil
}

func (m *NodeLabel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeLabel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.ServerAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ServerAddr)))
		i += copy(dAtA[i:], m.ServerAddr)
	}
	if len(m.RaftAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RaftAddr)))
		i += copy(dAtA[i:], m.RaftAddr)
	}
	if len(m.HttpAddr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.HttpAddr)))
		i += copy(dAtA[i:], m.HttpAddr)
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Role))
	}
	return i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeId))
	}
	if m.Peer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Peer.Size()))
		n1, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *RangeEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.RangeEpoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeEpoch.Size()))
		n2, err := m.RangeEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TableId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.TableId))
	}
	if len(m.PrimaryKeys) > 0 {
		for _, msg := range m.PrimaryKeys {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Leader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.NodeAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.NodeAddr)))
		i += copy(dAtA[i:], m.NodeAddr)
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Range.Size()))
		n3, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Leader != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Leader.Size()))
		n4, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *DataBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if m.Version != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	return i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.DataType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DataType))
	}
	if m.Unsigned {
		dAtA[i] = 0x20
		i++
		if m.Unsigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Scale != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Scale))
	}
	if m.Precision != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Precision))
	}
	if m.Nullable {
		dAtA[i] = 0x38
		i++
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrimaryKey != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Ordinal))
	}
	if m.Index {
		dAtA[i] = 0x50
		i++
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DefaultValue) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DefaultValue)))
		i += copy(dAtA[i:], m.DefaultValue)
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	return i, nil
}

func (m *Primary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColumnName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ColumnName)))
		i += copy(dAtA[i:], m.ColumnName)
	}
	if m.Next != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Next.Size()))
		n5, err := m.Next.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *TableEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DbName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if m.DbId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DbId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Epoch != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Epoch.Size()))
		n6, err := m.Epoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Regxs) > 0 {
		for _, msg := range m.Regxs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	if m.PkDupCheck {
		dAtA[i] = 0x50
		i++
		if m.PkDupCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Status != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	}
	if len(m.Expand) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expand)))
		i += copy(dAtA[i:], m.Expand)
	}
	return i, nil
}

func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.MaxPeerCount != 0 {
		n += 1 + sovMetapb(uint64(m.MaxPeerCount))
	}
	return n
}

func (m *NodeLabel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.ServerAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.RaftAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.HttpAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	return n
}

func (m *Peer) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	if m.Role != 0 {
		n += 1 + sovMetapb(uint64(m.Role))
	}
	return n
}

func (m *Replica) Size() (n int) {
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovMetapb(uint64(m.RangeId))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *RangeEpoch) Size() (n int) {
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	return n
}

func (m *Range) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RangeEpoch != nil {
		l = m.RangeEpoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.TableId != 0 {
		n += 1 + sovMetapb(uint64(m.TableId))
	}
	if len(m.PrimaryKeys) > 0 {
		for _, e := range m.PrimaryKeys {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	return n
}

func (m *Leader) Size() (n int) {
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovMetapb(uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *DataBase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	return n
}

func (m *Column) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.DataType != 0 {
		n += 1 + sovMetapb(uint64(m.DataType))
	}
	if m.Unsigned {
		n += 2
	}
	if m.Scale != 0 {
		n += 1 + sovMetapb(uint64(m.Scale))
	}
	if m.Precision != 0 {
		n += 1 + sovMetapb(uint64(m.Precision))
	}
	if m.Nullable {
		n += 2
	}
	if m.PrimaryKey != 0 {
		n += 1 + sovMetapb(uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		n += 1 + sovMetapb(uint64(m.Ordinal))
	}
	if m.Index {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Primary) Size() (n int) {
	var l int
	_ = l
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *TableEpoch) Size() (n int) {
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	return n
}

func (m *Table) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMetapb(uint64(m.DbId))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Regxs) > 0 {
		for _, e := range m.Regxs {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	if m.PkDupCheck {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovMetapb(uint64(m.Status))
	}
	l = len(m.Expand)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeerCount", wireType)
			}
			m.MaxPeerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeerCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeLabel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeLabel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeLabel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (NodeState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &NodeLabel{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (ReplicaRole(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEpoch == nil {
				m.RangeEpoch = &RangeEpoch{}
			}
			if err := m.RangeEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKeys = append(m.PrimaryKeys, &Column{})
			if err := m.PrimaryKeys[len(m.PrimaryKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= (DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unsigned = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			m.PrimaryKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = append(m.DefaultValue[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultValue == nil {
				m.DefaultValue = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Primary{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &TableEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regxs = append(m.Regxs, &Column{})
			if err := m.Regxs[len(m.Regxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkDupCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PkDupCheck = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TableStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expand = append(m.Expand[:0], dAtA[iNdEx:postIndex]...)
			if m.Expand == nil {
				m.Expand = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("metapb.proto", fileDescriptorMetapb) }

var fileDescriptorMetapb = []byte{
	// 1288 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x1b, 0xc5,
	0x17, 0xaf, 0xed, 0xfd, 0xb0, 0x8f, 0x9d, 0x74, 0x3b, 0xed, 0xbf, 0xf5, 0xbf, 0x45, 0x21, 0x72,
	0x2b, 0x35, 0x04, 0x51, 0x44, 0xfa, 0x00, 0x28, 0x4d, 0x40, 0x8a, 0x1a, 0xdc, 0x6a, 0x1c, 0x2a,
	0xb8, 0x5a, 0x8d, 0x3d, 0x27, 0xce, 0x2a, 0xeb, 0xd9, 0xd5, 0xec, 0xac, 0x15, 0x4b, 0xbc, 0x00,
	0x12, 0x17, 0x5c, 0xf2, 0x48, 0x5c, 0xf2, 0x02, 0x08, 0x54, 0x5e, 0x81, 0x3b, 0x6e, 0xd0, 0x99,
	0xd9, 0x75, 0xec, 0x7c, 0x20, 0x24, 0xae, 0xb2, 0xe7, 0xf7, 0x3b, 0x3e, 0xe7, 0x77, 0x3e, 0x66,
	0x26, 0xd0, 0x9b, 0xa1, 0x11, 0xf9, 0xf8, 0x45, 0xae, 0x33, 0x93, 0xb1, 0xc0, 0x59, 0x8f, 0x1f,
	0x4c, 0xb3, 0x69, 0x66, 0xa1, 0x4f, 0xe9, 0xcb, 0xb1, 0x83, 0xcf, 0x21, 0x3c, 0x48, 0xcb, 0xc2,
	0xa0, 0x66, 0x9b, 0xd0, 0x4c, 0x64, 0xbf, 0xb1, 0xdd, 0xd8, 0xf1, 0x78, 0x33, 0x91, 0xec, 0x19,
	0x6c, 0xce, 0xc4, 0x45, 0x9c, 0x23, 0xea, 0x78, 0x92, 0x95, 0xca, 0xf4, 0x9b, 0xdb, 0x8d, 0x9d,
	0x0d, 0xde, 0x9b, 0x89, 0x8b, 0xb7, 0x88, 0xfa, 0x80, 0xb0, 0xc1, 0x4b, 0xe8, 0x0c, 0x33, 0x89,
	0xc7, 0x62, 0x8c, 0x29, 0x8b, 0xa0, 0x75, 0x8e, 0x0b, 0x1b, 0xa3, 0xc3, 0xe9, 0x93, 0x3d, 0x00,
	0x7f, 0x2e, 0xd2, 0x12, 0xed, 0x6f, 0x3b, 0xdc, 0x19, 0x83, 0xdf, 0x1a, 0xe0, 0xd1, 0xaf, 0xae,
	0xe5, 0xfc, 0x10, 0xba, 0x05, 0xea, 0x39, 0xea, 0x58, 0x48, 0xa9, 0xab, 0x1f, 0x81, 0x83, 0xf6,
	0xa5, 0xd4, 0xec, 0x09, 0x74, 0xb4, 0x38, 0x35, 0x8e, 0x6e, 0x59, 0xba, 0x4d, 0x40, 0x4d, 0x9e,
	0x19, 0x93, 0x3b, 0xd2, 0x73, 0x24, 0x01, 0x96, 0x7c, 0x0e, 0x7e, 0x61, 0x84, 0xc1, 0xbe, 0xbf,
	0xdd, 0xd8, 0xd9, 0xdc, 0xbb, 0xf7, 0xa2, 0xea, 0x12, 0xe9, 0x18, 0x11, 0xc1, 0x1d, 0xcf, 0xfa,
	0x10, 0xce, 0x51, 0x17, 0x49, 0xa6, 0xfa, 0x81, 0x8d, 0x51, 0x9b, 0xec, 0x23, 0x08, 0x52, 0xaa,
	0xb3, 0xe8, 0x87, 0xdb, 0xad, 0x9d, 0xee, 0x7a, 0x0c, 0xdb, 0x01, 0x5e, 0x39, 0x0c, 0xbe, 0x01,
	0x8f, 0x7a, 0x74, 0xad, 0xc0, 0x47, 0x10, 0xaa, 0x4c, 0x62, 0x9c, 0x48, 0x5b, 0x9c, 0xc7, 0x03,
	0x32, 0x8f, 0x24, 0x7b, 0x0e, 0x9e, 0xce, 0x52, 0xb4, 0x35, 0x6d, 0xee, 0xdd, 0xaf, 0x23, 0x73,
	0xcc, 0xd3, 0x64, 0x22, 0x78, 0x96, 0x22, 0xb7, 0x0e, 0x83, 0xef, 0x20, 0xac, 0x40, 0xf6, 0x7f,
	0x68, 0x6b, 0xa1, 0xa6, 0x36, 0x9a, 0x4b, 0x11, 0x5a, 0xfb, 0x48, 0xb2, 0x6d, 0xf0, 0x68, 0x70,
	0x36, 0x49, 0x77, 0xaf, 0x57, 0x87, 0x23, 0x4d, 0xdc, 0x32, 0xd4, 0xac, 0xc2, 0x08, 0x6d, 0x62,
	0x9a, 0x18, 0x65, 0xed, 0xf1, 0xb6, 0x05, 0x5e, 0xe3, 0x82, 0x64, 0xa2, 0x92, 0x96, 0xf2, 0x2c,
	0x15, 0xa0, 0x92, 0xaf, 0x71, 0x31, 0xd8, 0x07, 0xe0, 0x94, 0xe2, 0x8b, 0x3c, 0x9b, 0x9c, 0x91,
	0x80, 0x49, 0xa6, 0x4e, 0xe3, 0x39, 0xea, 0x5a, 0x00, 0xd9, 0xef, 0x50, 0xaf, 0x76, 0xd1, 0x15,
	0x5a, 0x9b, 0x83, 0x3f, 0x1b, 0xe0, 0xdb, 0x18, 0xd7, 0x9a, 0xb3, 0x26, 0xa9, 0x79, 0xbb, 0xa4,
	0xd6, 0xaa, 0x24, 0xf6, 0x12, 0xba, 0xae, 0x0b, 0x48, 0x9a, 0xac, 0xde, 0xee, 0x1e, 0x5b, 0x36,
	0x70, 0xa9, 0x96, 0x83, 0xbe, 0x54, 0x3e, 0x00, 0x9f, 0xba, 0x50, 0xf4, 0x7d, 0x3b, 0xc9, 0xf5,
	0x06, 0x39, 0x8a, 0xaa, 0x33, 0x62, 0x9c, 0xda, 0xf6, 0x06, 0xae, 0x06, 0x6b, 0x1f, 0x49, 0xf6,
	0x19, 0xf4, 0x72, 0x9d, 0xcc, 0x84, 0x5e, 0x90, 0xa0, 0x7a, 0x1f, 0x36, 0xeb, 0x28, 0x07, 0x59,
	0x5a, 0xce, 0x14, 0xef, 0x56, 0x3e, 0xaf, 0x71, 0x51, 0x0c, 0xbe, 0x85, 0xe0, 0x18, 0x85, 0x44,
	0xfd, 0x4f, 0x63, 0xbb, 0x75, 0x3d, 0x9e, 0x40, 0xc7, 0x12, 0xab, 0x7b, 0x4f, 0x00, 0xad, 0xf6,
	0x80, 0x83, 0xcf, 0xb3, 0xd2, 0x20, 0x7b, 0x0a, 0xbe, 0x8d, 0x64, 0xc3, 0x76, 0xf7, 0x36, 0xd6,
	0x9a, 0xc0, 0x1d, 0xc7, 0x9e, 0x41, 0x90, 0x5a, 0x21, 0x37, 0x2e, 0x47, 0xc5, 0x0d, 0xbe, 0x6f,
	0x40, 0xfb, 0x50, 0x18, 0xf1, 0x4a, 0x14, 0xc8, 0x18, 0x78, 0x4a, 0xcc, 0xb0, 0x3a, 0xd8, 0xf6,
	0xbb, 0x1a, 0x5e, 0x73, 0x39, 0xbc, 0x2d, 0x80, 0x5c, 0x67, 0x39, 0x6a, 0x93, 0x60, 0x51, 0x49,
	0x5c, 0x41, 0x56, 0x17, 0xc2, 0x5b, 0x5b, 0x08, 0x3a, 0xf4, 0x13, 0x8d, 0xc2, 0x60, 0x6c, 0x92,
	0x99, 0x3b, 0x9f, 0x2d, 0x0e, 0x0e, 0x3a, 0x49, 0x66, 0x38, 0xf8, 0xb5, 0x09, 0x81, 0x6b, 0xe9,
	0xbf, 0x52, 0xf2, 0x09, 0x74, 0xa4, 0x30, 0x22, 0x36, 0x8b, 0xbc, 0x3e, 0x4f, 0x51, 0x5d, 0x23,
	0x95, 0x74, 0xb2, 0xc8, 0x91, 0xb7, 0x65, 0xf5, 0xc5, 0x1e, 0x43, 0xbb, 0x54, 0x45, 0x32, 0x55,
	0x28, 0xad, 0xb2, 0x36, 0x5f, 0xda, 0x74, 0x7d, 0x15, 0x13, 0x91, 0x3a, 0x51, 0x3e, 0x77, 0x06,
	0xfb, 0x00, 0x3a, 0xb9, 0xc6, 0x49, 0xb2, 0xbc, 0x23, 0x7c, 0x7e, 0x09, 0x50, 0x3c, 0x55, 0xa6,
	0x29, 0x6d, 0x4a, 0x3f, 0x74, 0xf1, 0x6a, 0x9b, 0x4a, 0x5d, 0xd9, 0x9b, 0x7e, 0xdb, 0x6a, 0x86,
	0xcb, 0x35, 0xa1, 0x2e, 0x65, 0x5a, 0x26, 0x4a, 0xa4, 0xfd, 0x8e, 0x0d, 0x5c, 0x9b, 0x24, 0x25,
	0x51, 0x12, 0x2f, 0xfa, 0x60, 0x63, 0x3a, 0x83, 0x3d, 0x85, 0x0d, 0x89, 0xa7, 0xa2, 0x4c, 0x4d,
	0xec, 0xee, 0xd9, 0xae, 0x3d, 0x1b, 0xbd, 0x0a, 0x7c, 0x47, 0xd8, 0x95, 0xd1, 0xf4, 0xae, 0x8e,
	0x66, 0xf0, 0x06, 0xc2, 0xb7, 0x4e, 0x82, 0x9d, 0x85, 0xed, 0x74, 0xbc, 0xd2, 0x66, 0x70, 0xd0,
	0x90, 0x9a, 0xfd, 0x14, 0x3c, 0x85, 0x17, 0xa6, 0xda, 0x9d, 0xbb, 0xcb, 0xdd, 0x71, 0xbf, 0xe7,
	0x96, 0xa4, 0x5b, 0xe2, 0x84, 0xea, 0xfd, 0x0f, 0xb7, 0xc4, 0x5f, 0x4d, 0xf0, 0x6d, 0x8c, 0x1b,
	0x47, 0xfe, 0x08, 0x42, 0x39, 0x76, 0x12, 0xdd, 0x1b, 0x11, 0xc8, 0xb1, 0x95, 0x77, 0x1f, 0x7c,
	0x39, 0xa6, 0xe3, 0xd3, 0xb2, 0xe1, 0x3c, 0x39, 0x3e, 0x92, 0xd5, 0x82, 0x78, 0xb7, 0xac, 0xaa,
	0x7f, 0x6d, 0x55, 0x77, 0x20, 0x74, 0x15, 0x17, 0xfd, 0xe0, 0xc6, 0x83, 0x5d, 0xd3, 0x6c, 0x07,
	0x7c, 0x77, 0xeb, 0x84, 0xeb, 0xb7, 0xce, 0x65, 0xf5, 0xdc, 0x39, 0xb0, 0x67, 0xe0, 0x6b, 0x9c,
	0x5e, 0x14, 0xfd, 0xf6, 0x8d, 0x11, 0x1d, 0x79, 0xf5, 0x28, 0x74, 0xae, 0x1e, 0x05, 0xb6, 0x0d,
	0xbd, 0xfc, 0x3c, 0x96, 0x65, 0x1e, 0x4f, 0xce, 0x70, 0x72, 0x5e, 0x2d, 0x03, 0xe4, 0xe7, 0x87,
	0x65, 0x7e, 0x40, 0x08, 0xfb, 0x18, 0x02, 0x7a, 0xc7, 0xca, 0xc2, 0xae, 0xc2, 0xca, 0x53, 0x62,
	0x35, 0x8d, 0x2c, 0xc5, 0x2b, 0x17, 0xf6, 0x10, 0x02, 0xbc, 0xc8, 0x85, 0x92, 0x76, 0x2b, 0xe8,
	0x4e, 0xb5, 0xd6, 0x6e, 0xe1, 0x5e, 0x75, 0xfb, 0x2e, 0xb2, 0x0d, 0xe8, 0x0c, 0xe3, 0x23, 0x35,
	0x17, 0x69, 0x22, 0xa3, 0x3b, 0xac, 0x0b, 0xe1, 0x30, 0x3e, 0xce, 0xa6, 0x89, 0x8a, 0x1a, 0xac,
	0x07, 0x6d, 0x6b, 0x64, 0xa5, 0x89, 0x9a, 0xce, 0xf3, 0xcd, 0xe9, 0x69, 0x9a, 0x28, 0x8c, 0x5a,
	0xec, 0x2e, 0x74, 0x87, 0xf1, 0x49, 0x36, 0x1b, 0x17, 0x26, 0x53, 0x18, 0x79, 0x8e, 0xff, 0x3a,
	0x9f, 0x6a, 0x21, 0x31, 0xf2, 0xeb, 0xc0, 0x89, 0x49, 0x44, 0x1a, 0x05, 0xbb, 0x3f, 0x34, 0xaa,
	0xc7, 0x65, 0x99, 0x96, 0xaf, 0xa4, 0x05, 0x08, 0xb8, 0x75, 0x76, 0x59, 0x79, 0x3c, 0xcc, 0xf4,
	0x4c, 0xa4, 0x51, 0x93, 0x04, 0xf1, 0x78, 0x94, 0xa7, 0x89, 0x89, 0x5a, 0xce, 0xf8, 0x0a, 0xf5,
	0x94, 0xf2, 0x59, 0x3f, 0x8e, 0xb3, 0x6c, 0x4e, 0xe9, 0x36, 0x01, 0x78, 0x7c, 0x9c, 0x09, 0x39,
	0x52, 0x22, 0x8f, 0x02, 0x67, 0xef, 0x8f, 0x95, 0x8b, 0x13, 0xba, 0x84, 0xb5, 0xfa, 0xf6, 0xee,
	0x10, 0xba, 0x2b, 0xaf, 0x2f, 0x8b, 0xa0, 0x47, 0x7f, 0x57, 0x14, 0xfd, 0x0f, 0xee, 0x59, 0x64,
	0xb4, 0x50, 0x93, 0xb8, 0x72, 0x8d, 0x1a, 0xec, 0x21, 0x30, 0x0b, 0xef, 0x17, 0xab, 0x78, 0x73,
	0xf7, 0xc7, 0xea, 0x46, 0xb5, 0x97, 0x4e, 0x17, 0xc2, 0xb5, 0x8e, 0x9e, 0x24, 0x6a, 0x91, 0xa8,
	0xaa, 0xb6, 0xd1, 0x4c, 0xa4, 0x29, 0x59, 0x4d, 0x16, 0x42, 0xeb, 0x48, 0x51, 0x5d, 0x00, 0xc1,
	0xab, 0x64, 0x4a, 0xdf, 0x1e, 0xeb, 0x80, 0xff, 0x65, 0x9a, 0x09, 0x13, 0xf9, 0x04, 0x1f, 0x66,
	0xe5, 0x38, 0xc5, 0x28, 0xa0, 0x30, 0xef, 0x84, 0x9e, 0x9c, 0x09, 0x1d, 0x85, 0xce, 0x5f, 0x09,
	0xbd, 0x88, 0xda, 0xac, 0x0d, 0xde, 0xa1, 0x30, 0x18, 0x75, 0xa8, 0x44, 0x5a, 0xa3, 0x91, 0x11,
	0xb3, 0x3c, 0x82, 0xdd, 0x39, 0x74, 0x57, 0xb6, 0x82, 0x4a, 0xb4, 0xe6, 0xa5, 0x32, 0xf2, 0x77,
	0x88, 0xed, 0x7b, 0xed, 0xf0, 0x56, 0x63, 0x2e, 0x34, 0x46, 0xcd, 0x25, 0xc2, 0x4b, 0xa5, 0x12,
	0x35, 0x75, 0x43, 0xb7, 0xc8, 0x21, 0xa6, 0x68, 0x68, 0x08, 0xf7, 0x60, 0xe3, 0x12, 0x20, 0x1f,
	0xff, 0x55, 0xf4, 0xf3, 0xfb, 0xad, 0xc6, 0x2f, 0xef, 0xb7, 0x1a, 0xbf, 0xbf, 0xdf, 0x6a, 0xfc,
	0xf4, 0xc7, 0xd6, 0x9d, 0x71, 0x60, 0xff, 0x1d, 0x7d, 0xf9, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb0, 0x37, 0x92, 0x48, 0xbc, 0x0a, 0x00, 0x00,
}
