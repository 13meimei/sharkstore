// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metapb.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 1. 无论什么条件下，除了已经Logout的节点，新旧ds加入集群后，ms都应该将其初始化为Initial状态，
// 由ds自检完成后，通过NodeLogin上报正式启动数据读写服务
// 2. Logout的节点，需要手动Initial
type NodeState int32

const (
	NodeState_N_Invalid NodeState = 0
	// 工作状态，可以提供服务
	NodeState_N_Login NodeState = 1
	// 此状态下节点的range已经全部迁移，必须手动login
	NodeState_N_Logout NodeState = 2
	// 此状态下节点不分配新的range，不迁移range
	NodeState_N_Offline NodeState = 3
	// 此状态下节点不分配新的range，开始逐步迁移range
	NodeState_N_Tombstone NodeState = 4
	// 节点升级
	NodeState_N_Upgrade NodeState = 5
	// 初始状态
	NodeState_N_Initial NodeState = 6
)

var NodeState_name = map[int32]string{
	0: "N_Invalid",
	1: "N_Login",
	2: "N_Logout",
	3: "N_Offline",
	4: "N_Tombstone",
	5: "N_Upgrade",
	6: "N_Initial",
}

var NodeState_value = map[string]int32{
	"N_Invalid":   0,
	"N_Login":     1,
	"N_Logout":    2,
	"N_Offline":   3,
	"N_Tombstone": 4,
	"N_Upgrade":   5,
	"N_Initial":   6,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}

func (NodeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}

type RangeState int32

const (
	RangeState_R_Invalid  RangeState = 0
	RangeState_R_Init     RangeState = 1
	RangeState_R_Normal   RangeState = 2
	RangeState_R_Split    RangeState = 3
	RangeState_R_Merge    RangeState = 4
	RangeState_R_Remove   RangeState = 5
	RangeState_R_LoadSnap RangeState = 6
	RangeState_R_Abnormal RangeState = 7
	RangeState_R_Offline  RangeState = 8
)

var RangeState_name = map[int32]string{
	0: "R_Invalid",
	1: "R_Init",
	2: "R_Normal",
	3: "R_Split",
	4: "R_Merge",
	5: "R_Remove",
	6: "R_LoadSnap",
	7: "R_Abnormal",
	8: "R_Offline",
}

var RangeState_value = map[string]int32{
	"R_Invalid":  0,
	"R_Init":     1,
	"R_Normal":   2,
	"R_Split":    3,
	"R_Merge":    4,
	"R_Remove":   5,
	"R_LoadSnap": 6,
	"R_Abnormal": 7,
	"R_Offline":  8,
}

func (x RangeState) String() string {
	return proto.EnumName(RangeState_name, int32(x))
}

func (RangeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}

type PeerType int32

const (
	PeerType_PeerType_Invalid PeerType = 0
	// 正常副本
	PeerType_PeerType_Normal PeerType = 1
	// learner副本，不参与raft选举, 复制不计作大多数
	PeerType_PeerType_Learner PeerType = 2
)

var PeerType_name = map[int32]string{
	0: "PeerType_Invalid",
	1: "PeerType_Normal",
	2: "PeerType_Learner",
}

var PeerType_value = map[string]int32{
	"PeerType_Invalid": 0,
	"PeerType_Normal":  1,
	"PeerType_Learner": 2,
}

func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}

func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}

type DataType int32

const (
	DataType_Invalid DataType = 0
	// 8 bit interger
	DataType_Tinyint DataType = 1
	// 16 bit interger
	DataType_Smallint DataType = 2
	// 32 bit interger
	DataType_Int DataType = 3
	// 64 bit interger
	DataType_BigInt DataType = 4
	// 32 bit float
	DataType_Float DataType = 5
	// 64 bit float
	DataType_Double DataType = 6
	// string UTF-8 max size 64 KB
	DataType_Varchar DataType = 7
	// Blob max size 64 KB
	DataType_Binary DataType = 8
	// DataTime 从1970年1月1日以来的天数
	DataType_Date DataType = 9
	// DataTime 从1970年1月1日以来的秒数，精确到纳秒
	DataType_TimeStamp DataType = 10
)

var DataType_name = map[int32]string{
	0:  "Invalid",
	1:  "Tinyint",
	2:  "Smallint",
	3:  "Int",
	4:  "BigInt",
	5:  "Float",
	6:  "Double",
	7:  "Varchar",
	8:  "Binary",
	9:  "Date",
	10: "TimeStamp",
}

var DataType_value = map[string]int32{
	"Invalid":   0,
	"Tinyint":   1,
	"Smallint":  2,
	"Int":       3,
	"BigInt":    4,
	"Float":     5,
	"Double":    6,
	"Varchar":   7,
	"Binary":    8,
	"Date":      9,
	"TimeStamp": 10,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}

type TableStatus int32

const (
	TableStatus_TableInvalid TableStatus = 0
	// 初始状态，table刚刚创建，分片还不能提供服务
	TableStatus_TableInit TableStatus = 1
	// 准备状态，等待table的初始分片补足三个副本
	TableStatus_TablePrepare TableStatus = 2
	// 正常状态，可以提供完全的服务
	TableStatus_TableRunning TableStatus = 3
	// 标记删除，元数据都保留，允许分片参与调度,但不能分裂
	TableStatus_TableDelete TableStatus = 4
	// 正在删除
	TableStatus_TableDeleting TableStatus = 5
)

var TableStatus_name = map[int32]string{
	0: "TableInvalid",
	1: "TableInit",
	2: "TablePrepare",
	3: "TableRunning",
	4: "TableDelete",
	5: "TableDeleting",
}

var TableStatus_value = map[string]int32{
	"TableInvalid":  0,
	"TableInit":     1,
	"TablePrepare":  2,
	"TableRunning":  3,
	"TableDelete":   4,
	"TableDeleting": 5,
}

func (x TableStatus) String() string {
	return proto.EnumName(TableStatus_name, int32(x))
}

func (TableStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}

type Cluster struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// max peer count for a Range.
	// master server will do the auto-balance if Range peer count mismatches.
	MaxPeerCount         uint32   `protobuf:"varint,2,opt,name=max_peer_count,json=maxPeerCount,proto3" json:"max_peer_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Cluster) GetMaxPeerCount() uint32 {
	if m != nil {
		return m.MaxPeerCount
	}
	return 0
}

// Case insensitive key/value for replica constraints.
type NodeLabel struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeLabel) Reset()         { *m = NodeLabel{} }
func (m *NodeLabel) String() string { return proto.CompactTextString(m) }
func (*NodeLabel) ProtoMessage()    {}
func (*NodeLabel) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}
func (m *NodeLabel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeLabel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeLabel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeLabel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeLabel.Merge(m, src)
}
func (m *NodeLabel) XXX_Size() int {
	return m.Size()
}
func (m *NodeLabel) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeLabel.DiscardUnknown(m)
}

var xxx_messageInfo_NodeLabel proto.InternalMessageInfo

func (m *NodeLabel) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *NodeLabel) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Node struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// rpc 服务地址
	ServerAddr string `protobuf:"bytes,2,opt,name=server_addr,json=serverAddr,proto3" json:"server_addr,omitempty"`
	// raft　服务地址
	RaftAddr string `protobuf:"bytes,3,opt,name=raft_addr,json=raftAddr,proto3" json:"raft_addr,omitempty"`
	// 管理地址
	AdminAddr            string       `protobuf:"bytes,4,opt,name=admin_addr,json=adminAddr,proto3" json:"admin_addr,omitempty"`
	State                NodeState    `protobuf:"varint,5,opt,name=state,proto3,enum=metapb.NodeState" json:"state,omitempty"`
	Version              string       `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	Labels               []*NodeLabel `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetServerAddr() string {
	if m != nil {
		return m.ServerAddr
	}
	return ""
}

func (m *Node) GetRaftAddr() string {
	if m != nil {
		return m.RaftAddr
	}
	return ""
}

func (m *Node) GetAdminAddr() string {
	if m != nil {
		return m.AdminAddr
	}
	return ""
}

func (m *Node) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeState_N_Invalid
}

func (m *Node) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Node) GetLabels() []*NodeLabel {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Peer struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NodeId               uint64   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Type                 PeerType `protobuf:"varint,3,opt,name=type,proto3,enum=metapb.PeerType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Peer) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Peer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerType_PeerType_Invalid
}

type PeerStatus struct {
	Peer                 *Peer    `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Commit               uint64   `protobuf:"varint,3,opt,name=commit,proto3" json:"commit,omitempty"`
	DownSeconds          uint64   `protobuf:"varint,4,opt,name=down_seconds,json=downSeconds,proto3" json:"down_seconds,omitempty"`
	Snapshotting         bool     `protobuf:"varint,5,opt,name=snapshotting,proto3" json:"snapshotting,omitempty"`
	Applied              uint64   `protobuf:"varint,6,opt,name=applied,proto3" json:"applied,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerStatus) Reset()         { *m = PeerStatus{} }
func (m *PeerStatus) String() string { return proto.CompactTextString(m) }
func (*PeerStatus) ProtoMessage()    {}
func (*PeerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}
func (m *PeerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerStatus.Merge(m, src)
}
func (m *PeerStatus) XXX_Size() int {
	return m.Size()
}
func (m *PeerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PeerStatus proto.InternalMessageInfo

func (m *PeerStatus) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *PeerStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PeerStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *PeerStatus) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

func (m *PeerStatus) GetSnapshotting() bool {
	if m != nil {
		return m.Snapshotting
	}
	return false
}

func (m *PeerStatus) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

type Replica struct {
	RangeId              uint64   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Peer                 *Peer    `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer,omitempty"`
	StartKey             []byte   `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey               []byte   `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Replica) Reset()         { *m = Replica{} }
func (m *Replica) String() string { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()    {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.Size()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Replica) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Replica) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Replica) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type RangeEpoch struct {
	// Conf change version, auto increment when add or remove peer
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Range version, auto increment when split or merge
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RangeEpoch) Reset()         { *m = RangeEpoch{} }
func (m *RangeEpoch) String() string { return proto.CompactTextString(m) }
func (*RangeEpoch) ProtoMessage()    {}
func (*RangeEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}
func (m *RangeEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeEpoch.Merge(m, src)
}
func (m *RangeEpoch) XXX_Size() int {
	return m.Size()
}
func (m *RangeEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_RangeEpoch proto.InternalMessageInfo

func (m *RangeEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *RangeEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Range struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Range key range [start_key, end_key).
	// key的组成 prefix + table_id + real key
	StartKey             []byte      `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey               []byte      `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	RangeEpoch           *RangeEpoch `protobuf:"bytes,4,opt,name=range_epoch,json=rangeEpoch,proto3" json:"range_epoch,omitempty"`
	Peers                []*Peer     `protobuf:"bytes,5,rep,name=peers,proto3" json:"peers,omitempty"`
	TableId              uint64      `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryKeys          []*Column   `protobuf:"bytes,7,rep,name=primary_keys,json=primaryKeys,proto3" json:"primary_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Range) GetRangeEpoch() *RangeEpoch {
	if m != nil {
		return m.RangeEpoch
	}
	return nil
}

func (m *Range) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Range) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *Range) GetPrimaryKeys() []*Column {
	if m != nil {
		return m.PrimaryKeys
	}
	return nil
}

type Leader struct {
	RangeId              uint64   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	NodeId               uint64   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr             string   `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Leader) Reset()         { *m = Leader{} }
func (m *Leader) String() string { return proto.CompactTextString(m) }
func (*Leader) ProtoMessage()    {}
func (*Leader) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}
func (m *Leader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Leader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Leader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Leader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Leader.Merge(m, src)
}
func (m *Leader) XXX_Size() int {
	return m.Size()
}
func (m *Leader) XXX_DiscardUnknown() {
	xxx_messageInfo_Leader.DiscardUnknown(m)
}

var xxx_messageInfo_Leader proto.InternalMessageInfo

func (m *Leader) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Leader) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Leader) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

type Route struct {
	Range                *Range   `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Leader               *Peer    `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Route) GetLeader() *Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

type DataBase struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id                   uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Properties           string   `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`
	Version              uint64   `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	CreateTime           int64    `protobuf:"varint,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DataBase) Reset()         { *m = DataBase{} }
func (m *DataBase) String() string { return proto.CompactTextString(m) }
func (*DataBase) ProtoMessage()    {}
func (*DataBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{10}
}
func (m *DataBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataBase.Merge(m, src)
}
func (m *DataBase) XXX_Size() int {
	return m.Size()
}
func (m *DataBase) XXX_DiscardUnknown() {
	xxx_messageInfo_DataBase.DiscardUnknown(m)
}

var xxx_messageInfo_DataBase proto.InternalMessageInfo

func (m *DataBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataBase) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DataBase) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *DataBase) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DataBase) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

type Column struct {
	// max size 128 bytes
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 列名映射的ID,客户端不可见
	Id       uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	DataType DataType `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=metapb.DataType" json:"data_type,omitempty"`
	// 针对int类型,是否是无符号类型
	Unsigned bool `protobuf:"varint,4,opt,name=unsigned,proto3" json:"unsigned,omitempty"`
	// 针对float和varchar类型
	Scale int32 `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	// 针对float类型
	Precision int32 `protobuf:"varint,6,opt,name=precision,proto3" json:"precision,omitempty"`
	// 是否可以为空
	Nullable bool `protobuf:"varint,7,opt,name=nullable,proto3" json:"nullable,omitempty"`
	// 是否主键
	PrimaryKey uint64 `protobuf:"varint,8,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// 列的顺序
	Ordinal int32 `protobuf:"varint,9,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	// 索引 Binary不支持索引，其他类型列默认均是索引列
	Index        bool   `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	DefaultValue []byte `protobuf:"bytes,11,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Properties   string `protobuf:"bytes,12,opt,name=properties,proto3" json:"properties,omitempty"`
	//自增
	AutoIncrement bool `protobuf:"varint,13,opt,name=auto_increment,json=autoIncrement,proto3" json:"auto_increment,omitempty"`
	// 唯一键
	Unique               bool     `protobuf:"varint,14,opt,name=unique,proto3" json:"unique,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{11}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Column) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Column) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DataType_Invalid
}

func (m *Column) GetUnsigned() bool {
	if m != nil {
		return m.Unsigned
	}
	return false
}

func (m *Column) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Column) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Column) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Column) GetPrimaryKey() uint64 {
	if m != nil {
		return m.PrimaryKey
	}
	return 0
}

func (m *Column) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

func (m *Column) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *Column) GetDefaultValue() []byte {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *Column) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Column) GetAutoIncrement() bool {
	if m != nil {
		return m.AutoIncrement
	}
	return false
}

func (m *Column) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

type Primary struct {
	ColumnName           string   `protobuf:"bytes,1,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	Next                 *Primary `protobuf:"bytes,2,opt,name=next,proto3" json:"next,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Primary) Reset()         { *m = Primary{} }
func (m *Primary) String() string { return proto.CompactTextString(m) }
func (*Primary) ProtoMessage()    {}
func (*Primary) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{12}
}
func (m *Primary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Primary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Primary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Primary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Primary.Merge(m, src)
}
func (m *Primary) XXX_Size() int {
	return m.Size()
}
func (m *Primary) XXX_DiscardUnknown() {
	xxx_messageInfo_Primary.DiscardUnknown(m)
}

var xxx_messageInfo_Primary proto.InternalMessageInfo

func (m *Primary) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *Primary) GetNext() *Primary {
	if m != nil {
		return m.Next
	}
	return nil
}

type TableEpoch struct {
	// Conf change version, auto increment when add or remove column
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Route version, auto increment when split or merge
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableEpoch) Reset()         { *m = TableEpoch{} }
func (m *TableEpoch) String() string { return proto.CompactTextString(m) }
func (*TableEpoch) ProtoMessage()    {}
func (*TableEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{13}
}
func (m *TableEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableEpoch.Merge(m, src)
}
func (m *TableEpoch) XXX_Size() int {
	return m.Size()
}
func (m *TableEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_TableEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_TableEpoch proto.InternalMessageInfo

func (m *TableEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *TableEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Table struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DbName string `protobuf:"bytes,2,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	DbId   uint64 `protobuf:"varint,3,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	Id     uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// 必须有主键
	//repeated string primary_key = 4;
	Properties string      `protobuf:"bytes,5,opt,name=properties,proto3" json:"properties,omitempty"`
	Columns    []*Column   `protobuf:"bytes,6,rep,name=columns,proto3" json:"columns,omitempty"`
	Epoch      *TableEpoch `protobuf:"bytes,7,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Regxs      []*Column   `protobuf:"bytes,8,rep,name=regxs,proto3" json:"regxs,omitempty"`
	CreateTime int64       `protobuf:"varint,9,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// 默认不检查主键重复
	PkDupCheck bool `protobuf:"varint,10,opt,name=pk_dup_check,json=pkDupCheck,proto3" json:"pk_dup_check,omitempty"`
	// table status
	Status TableStatus `protobuf:"varint,11,opt,name=status,proto3,enum=metapb.TableStatus" json:"status,omitempty"`
	// table expand area
	// now when status is TableDelete, expand is the delete flag time
	Expand               []byte   `protobuf:"bytes,12,opt,name=expand,proto3" json:"expand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{14}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

func (m *Table) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Table) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *Table) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Table) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Table) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Table) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *Table) GetEpoch() *TableEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *Table) GetRegxs() []*Column {
	if m != nil {
		return m.Regxs
	}
	return nil
}

func (m *Table) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Table) GetPkDupCheck() bool {
	if m != nil {
		return m.PkDupCheck
	}
	return false
}

func (m *Table) GetStatus() TableStatus {
	if m != nil {
		return m.Status
	}
	return TableStatus_TableInvalid
}

func (m *Table) GetExpand() []byte {
	if m != nil {
		return m.Expand
	}
	return nil
}

func init() {
	proto.RegisterEnum("metapb.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("metapb.RangeState", RangeState_name, RangeState_value)
	proto.RegisterEnum("metapb.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("metapb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("metapb.TableStatus", TableStatus_name, TableStatus_value)
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*NodeLabel)(nil), "metapb.NodeLabel")
	proto.RegisterType((*Node)(nil), "metapb.Node")
	proto.RegisterType((*Peer)(nil), "metapb.Peer")
	proto.RegisterType((*PeerStatus)(nil), "metapb.PeerStatus")
	proto.RegisterType((*Replica)(nil), "metapb.Replica")
	proto.RegisterType((*RangeEpoch)(nil), "metapb.RangeEpoch")
	proto.RegisterType((*Range)(nil), "metapb.Range")
	proto.RegisterType((*Leader)(nil), "metapb.Leader")
	proto.RegisterType((*Route)(nil), "metapb.Route")
	proto.RegisterType((*DataBase)(nil), "metapb.DataBase")
	proto.RegisterType((*Column)(nil), "metapb.Column")
	proto.RegisterType((*Primary)(nil), "metapb.Primary")
	proto.RegisterType((*TableEpoch)(nil), "metapb.TableEpoch")
	proto.RegisterType((*Table)(nil), "metapb.Table")
}

func init() { proto.RegisterFile("metapb.proto", fileDescriptor_77b4d575d5a68dda) }

var fileDescriptor_77b4d575d5a68dda = []byte{
	// 1396 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcd, 0x6e, 0xdc, 0x46,
	0x12, 0xf6, 0xcc, 0xf0, 0x67, 0xa6, 0x66, 0x34, 0xa6, 0xdb, 0xc6, 0x7a, 0xd6, 0xde, 0xd5, 0x6a,
	0xc7, 0x5e, 0xac, 0x56, 0x8b, 0xf5, 0x22, 0xf2, 0x03, 0x04, 0xb6, 0x94, 0x00, 0x82, 0x14, 0xd9,
	0x68, 0xc9, 0x06, 0x72, 0x22, 0x7a, 0xa6, 0x4b, 0x23, 0x42, 0x64, 0x93, 0x69, 0x36, 0x15, 0x0d,
	0x90, 0x17, 0x08, 0x90, 0x43, 0x8e, 0x39, 0xe4, 0x55, 0x72, 0xcf, 0x31, 0x8f, 0x90, 0x38, 0xaf,
	0x90, 0x5b, 0x2e, 0x41, 0x75, 0x93, 0xf3, 0x63, 0x49, 0x41, 0x80, 0xdc, 0x58, 0x5f, 0x15, 0xab,
	0xbf, 0xfa, 0xaa, 0xba, 0x48, 0x18, 0x64, 0x68, 0x44, 0x31, 0x79, 0x56, 0xe8, 0xdc, 0xe4, 0x2c,
	0x70, 0xd6, 0xa3, 0x07, 0xb3, 0x7c, 0x96, 0x5b, 0xe8, 0xff, 0xf4, 0xe4, 0xbc, 0xe3, 0x0f, 0x21,
	0xdc, 0x4b, 0xab, 0xd2, 0xa0, 0x66, 0x43, 0x68, 0x27, 0x72, 0xd4, 0xda, 0x6a, 0x6d, 0x7b, 0xbc,
	0x9d, 0x48, 0xf6, 0x14, 0x86, 0x99, 0xb8, 0x8a, 0x0b, 0x44, 0x1d, 0x4f, 0xf3, 0x4a, 0x99, 0x51,
	0x7b, 0xab, 0xb5, 0xbd, 0xc1, 0x07, 0x99, 0xb8, 0x7a, 0x8d, 0xa8, 0xf7, 0x08, 0x1b, 0x3f, 0x87,
	0xde, 0x71, 0x2e, 0xf1, 0x48, 0x4c, 0x30, 0x65, 0x11, 0x74, 0x2e, 0x70, 0x6e, 0x73, 0xf4, 0x38,
	0x3d, 0xb2, 0x07, 0xe0, 0x5f, 0x8a, 0xb4, 0x42, 0xfb, 0x6e, 0x8f, 0x3b, 0x63, 0xfc, 0x53, 0x0b,
	0x3c, 0x7a, 0xeb, 0xda, 0x99, 0xff, 0x80, 0x7e, 0x89, 0xfa, 0x12, 0x75, 0x2c, 0xa4, 0xd4, 0xf5,
	0x4b, 0xe0, 0xa0, 0x17, 0x52, 0x6a, 0xf6, 0x18, 0x7a, 0x5a, 0x9c, 0x19, 0xe7, 0xee, 0x58, 0x77,
	0x97, 0x00, 0xeb, 0xfc, 0x3b, 0x80, 0x90, 0x59, 0xa2, 0x9c, 0xd7, 0xb3, 0xde, 0x9e, 0x45, 0xac,
	0xfb, 0xdf, 0xe0, 0x97, 0x46, 0x18, 0x1c, 0xf9, 0x5b, 0xad, 0xed, 0xe1, 0xee, 0xbd, 0x67, 0xb5,
	0x4e, 0xc4, 0xe4, 0x84, 0x1c, 0xdc, 0xf9, 0xd9, 0x08, 0xc2, 0x4b, 0xd4, 0x65, 0x92, 0xab, 0x51,
	0x60, 0x93, 0x34, 0x26, 0xfb, 0x0f, 0x04, 0x29, 0x55, 0x5a, 0x8e, 0xc2, 0xad, 0xce, 0x76, 0x7f,
	0x3d, 0x87, 0xd5, 0x80, 0xd7, 0x01, 0xe3, 0x37, 0xe0, 0x91, 0x4a, 0xd7, 0x4a, 0x7c, 0x08, 0xa1,
	0xca, 0x25, 0xc6, 0x89, 0xb4, 0xe5, 0x79, 0x3c, 0x20, 0xf3, 0x80, 0xf4, 0xf6, 0xcc, 0xbc, 0x40,
	0x5b, 0xd5, 0x70, 0x37, 0x6a, 0x32, 0x53, 0x92, 0xd3, 0x79, 0x81, 0xdc, 0x7a, 0xc7, 0xdf, 0xb5,
	0x00, 0x08, 0x22, 0xc2, 0x55, 0xc9, 0xb6, 0xc0, 0xa3, 0x06, 0xd9, 0xfc, 0xfd, 0xdd, 0xc1, 0xea,
	0x4b, 0xdc, 0x7a, 0xa8, 0x03, 0x89, 0x92, 0x78, 0x55, 0x9f, 0xe6, 0x0c, 0xf6, 0x17, 0x08, 0xa6,
	0x79, 0x96, 0x25, 0xc6, 0x1e, 0xe7, 0xf1, 0xda, 0x62, 0xff, 0x84, 0x81, 0xcc, 0x3f, 0x57, 0x71,
	0x89, 0xd3, 0x5c, 0xc9, 0xd2, 0x8a, 0xe8, 0xf1, 0x3e, 0x61, 0x27, 0x0e, 0x62, 0x63, 0x18, 0x94,
	0x4a, 0x14, 0xe5, 0x79, 0x6e, 0x4c, 0xa2, 0x66, 0x56, 0xcd, 0x2e, 0x5f, 0xc3, 0x48, 0x41, 0x51,
	0x14, 0x69, 0x82, 0xd2, 0x2a, 0xe8, 0xf1, 0xc6, 0x1c, 0x7f, 0x01, 0x21, 0xc7, 0x22, 0x4d, 0xa6,
	0x82, 0xfd, 0x15, 0xba, 0x5a, 0xa8, 0x99, 0x95, 0xc2, 0xe9, 0x13, 0x5a, 0xfb, 0x40, 0x2e, 0xca,
	0x6a, 0xdf, 0x5a, 0xd6, 0x63, 0xe8, 0x95, 0x46, 0x68, 0x13, 0xd3, 0xc0, 0x51, 0x0d, 0x03, 0xde,
	0xb5, 0xc0, 0x21, 0xce, 0x49, 0x63, 0x54, 0xd2, 0xba, 0x3c, 0xeb, 0x0a, 0x50, 0xc9, 0x43, 0x9c,
	0x8f, 0x5f, 0x00, 0x70, 0x3a, 0xe2, 0xa3, 0x22, 0x9f, 0x9e, 0x13, 0x81, 0x69, 0xae, 0xce, 0xe2,
	0xcb, 0x5a, 0x40, 0x8f, 0x87, 0x64, 0xbf, 0x45, 0xbd, 0x3a, 0x02, 0x4e, 0xb7, 0xc6, 0x1c, 0xff,
	0xd2, 0x02, 0xdf, 0xe6, 0xb8, 0xd6, 0xd9, 0x35, 0x4a, 0xed, 0xdb, 0x29, 0x75, 0x56, 0x29, 0xb1,
	0xe7, 0xd0, 0x77, 0x2a, 0x20, 0x71, 0xb2, 0x7c, 0xfb, 0xbb, 0xac, 0xa9, 0x78, 0xc9, 0x96, 0x83,
	0x5e, 0x32, 0x1f, 0x83, 0x4f, 0x2a, 0x94, 0x23, 0xdf, 0x8e, 0xe1, 0xba, 0x40, 0xce, 0x45, 0xd5,
	0x19, 0x31, 0x49, 0xad, 0xbc, 0x75, 0x13, 0xac, 0x7d, 0x20, 0xd9, 0x07, 0x30, 0x28, 0x74, 0x92,
	0x09, 0x3d, 0x27, 0x42, 0xcd, 0x30, 0x0f, 0x9b, 0x2c, 0x7b, 0x79, 0x5a, 0x65, 0x8a, 0xf7, 0xeb,
	0x98, 0x43, 0x9c, 0x97, 0xe3, 0x4f, 0x21, 0x38, 0x42, 0x21, 0x51, 0xff, 0x5e, 0xdb, 0x6e, 0x9d,
	0xed, 0xc7, 0xd0, 0xb3, 0x8e, 0xd5, 0x6b, 0x4b, 0x00, 0xdd, 0xcb, 0x31, 0x07, 0x9f, 0xe7, 0x95,
	0x41, 0xf6, 0x04, 0x7c, 0x9b, 0xa9, 0x9e, 0xe6, 0x8d, 0x35, 0x11, 0xb8, 0xf3, 0xb1, 0xa7, 0x10,
	0xa4, 0x96, 0xc8, 0x8d, 0xc3, 0x51, 0xfb, 0xc6, 0x5f, 0xb6, 0xa0, 0xbb, 0x2f, 0x8c, 0x78, 0x29,
	0x4a, 0x64, 0x0c, 0x3c, 0x25, 0x32, 0xac, 0xf7, 0x92, 0x7d, 0xae, 0x9b, 0xd7, 0x5e, 0x34, 0x6f,
	0x13, 0xa0, 0xd0, 0x79, 0x81, 0xda, 0x24, 0x58, 0xd6, 0x14, 0x57, 0x90, 0xd5, 0x81, 0xf0, 0xd6,
	0x06, 0x82, 0x76, 0xd6, 0x54, 0xa3, 0x30, 0x18, 0x9b, 0x24, 0x73, 0xcb, 0xa5, 0xc3, 0xc1, 0x41,
	0xa7, 0x49, 0x86, 0xe3, 0x6f, 0x3b, 0x10, 0x38, 0x49, 0xff, 0x10, 0x93, 0xff, 0x41, 0x4f, 0x0a,
	0x23, 0xe2, 0x9b, 0x96, 0x01, 0x95, 0x64, 0x97, 0x41, 0x57, 0xd6, 0x4f, 0xec, 0x11, 0x74, 0x2b,
	0x55, 0x26, 0x33, 0x85, 0xd2, 0x32, 0xeb, 0xf2, 0x85, 0x4d, 0x77, 0xbf, 0x9c, 0x8a, 0xd4, 0x91,
	0xf2, 0xb9, 0x33, 0xd8, 0xdf, 0xa0, 0x57, 0x68, 0x9c, 0x26, 0x8b, 0x05, 0xe7, 0xf3, 0x25, 0x40,
	0xf9, 0x54, 0x95, 0xa6, 0x34, 0x29, 0xa3, 0xd0, 0xe5, 0x6b, 0x6c, 0x2a, 0x75, 0x65, 0x6e, 0x46,
	0x5d, 0xcb, 0x19, 0x96, 0x63, 0x42, 0x2a, 0xe5, 0x5a, 0x26, 0x4a, 0xa4, 0xa3, 0x9e, 0x4d, 0xdc,
	0x98, 0xcb, 0x35, 0x04, 0x36, 0x67, 0xbd, 0x86, 0x9e, 0xc0, 0x86, 0xc4, 0x33, 0x51, 0xa5, 0x26,
	0x76, 0x9f, 0x89, 0xbe, 0xbd, 0x1b, 0x83, 0x1a, 0x7c, 0x4b, 0xd8, 0x7b, 0xad, 0x19, 0x5c, 0x6b,
	0xcd, 0xbf, 0x60, 0x28, 0x2a, 0x93, 0xc7, 0x89, 0x9a, 0x6a, 0xcc, 0x50, 0x99, 0xd1, 0x86, 0x3d,
	0x63, 0x83, 0xd0, 0x83, 0x06, 0xa4, 0x95, 0x57, 0xa9, 0xe4, 0xb3, 0x0a, 0x47, 0x43, 0xeb, 0xae,
	0xad, 0xf1, 0x2b, 0x08, 0x5f, 0xbb, 0x0a, 0x6c, 0x2b, 0x6d, 0xa3, 0xe2, 0x95, 0x2e, 0x81, 0x83,
	0x8e, 0xa9, 0x57, 0x4f, 0xc0, 0x53, 0x78, 0x65, 0xea, 0xd1, 0xbb, 0xbb, 0x18, 0x3d, 0xf7, 0x3e,
	0xb7, 0x4e, 0x5a, 0x32, 0xa7, 0x24, 0xd7, 0x9f, 0x58, 0x32, 0xbf, 0xb6, 0xc1, 0xb7, 0x39, 0x6e,
	0x9c, 0x98, 0x87, 0x10, 0xca, 0x89, 0xa3, 0xe8, 0xbe, 0x90, 0x81, 0x9c, 0x58, 0x7a, 0xf7, 0xc1,
	0x97, 0x13, 0xba, 0x7d, 0x6e, 0xa9, 0x7b, 0x72, 0x72, 0x20, 0xeb, 0xf9, 0xf2, 0x6e, 0x99, 0x74,
	0xff, 0x9a, 0x9c, 0xdb, 0x10, 0xba, 0x8a, 0xcb, 0x51, 0x70, 0xe3, 0x5e, 0x68, 0xdc, 0x6c, 0x1b,
	0x7c, 0xb7, 0xb4, 0xc2, 0xf5, 0xa5, 0xb5, 0xac, 0x9e, 0xbb, 0x00, 0xf6, 0x14, 0x7c, 0x8d, 0xb3,
	0xab, 0x72, 0xd4, 0xbd, 0x31, 0xa3, 0x73, 0xbe, 0x7f, 0x93, 0x7a, 0xef, 0xdf, 0x24, 0xb6, 0x05,
	0x83, 0xe2, 0x22, 0x96, 0x55, 0x11, 0x4f, 0xcf, 0x71, 0x7a, 0x51, 0xcf, 0x12, 0x14, 0x17, 0xfb,
	0x55, 0xb1, 0x47, 0x08, 0xfb, 0x2f, 0x04, 0xa5, 0xfd, 0x32, 0xda, 0x49, 0x1a, 0xee, 0xde, 0x5f,
	0xe3, 0xe4, 0x3e, 0x9a, 0xbc, 0x0e, 0xa1, 0x89, 0xc0, 0xab, 0x42, 0x28, 0x69, 0x87, 0x8a, 0x56,
	0xb2, 0xb5, 0x76, 0x4a, 0xf7, 0x4f, 0x63, 0xff, 0x09, 0xd8, 0x06, 0xf4, 0x8e, 0xe3, 0x03, 0x75,
	0x29, 0xd2, 0x44, 0x46, 0x77, 0x58, 0x1f, 0xc2, 0xe3, 0xf8, 0x28, 0x9f, 0x25, 0x2a, 0x6a, 0xb1,
	0x01, 0x74, 0xad, 0x91, 0x57, 0x26, 0x6a, 0xbb, 0xc8, 0x57, 0x67, 0x67, 0x69, 0xa2, 0x30, 0xea,
	0xb0, 0xbb, 0xd0, 0x3f, 0x8e, 0x4f, 0xf3, 0x6c, 0x52, 0x9a, 0x5c, 0x61, 0xe4, 0x39, 0xff, 0x9b,
	0x62, 0xa6, 0x85, 0xc4, 0xc8, 0x6f, 0x12, 0x27, 0x26, 0x11, 0x69, 0x14, 0xec, 0x7c, 0xd5, 0xaa,
	0xbf, 0x4d, 0x8b, 0x63, 0xf9, 0xca, 0xb1, 0x00, 0x01, 0xb7, 0xc1, 0xee, 0x54, 0x1e, 0x1f, 0xe7,
	0x3a, 0x13, 0x69, 0xd4, 0x26, 0x42, 0x3c, 0x3e, 0x29, 0xd2, 0xc4, 0x44, 0x1d, 0x67, 0x7c, 0x82,
	0x7a, 0x46, 0xe7, 0xd9, 0x38, 0x8e, 0x59, 0x7e, 0x49, 0xc7, 0x0d, 0x01, 0x78, 0x7c, 0x94, 0x0b,
	0x79, 0xa2, 0x44, 0x11, 0x05, 0xce, 0x7e, 0x31, 0x51, 0x2e, 0x4f, 0xe8, 0x0e, 0x6c, 0xd8, 0x77,
	0x77, 0x0e, 0xa1, 0xdb, 0xfc, 0x79, 0xb0, 0x07, 0x10, 0x35, 0xcf, 0x2b, 0x94, 0xee, 0xc3, 0xdd,
	0x05, 0x5a, 0xb3, 0x69, 0xad, 0x85, 0x1e, 0xa1, 0xd0, 0x0a, 0x75, 0xd4, 0xde, 0xf9, 0xba, 0xde,
	0xc6, 0x36, 0x5b, 0x1f, 0xc2, 0x35, 0x39, 0x4f, 0x13, 0x35, 0x4f, 0x54, 0x5d, 0xd8, 0x49, 0x26,
	0xd2, 0x94, 0xac, 0x36, 0x0b, 0xa1, 0x73, 0xa0, 0xa8, 0x28, 0x80, 0xe0, 0x65, 0x32, 0xa3, 0x67,
	0x8f, 0xf5, 0xc0, 0xff, 0x38, 0xcd, 0x85, 0x89, 0x7c, 0x82, 0xf7, 0xf3, 0x6a, 0x92, 0x62, 0x14,
	0x50, 0x9a, 0xb7, 0x42, 0x4f, 0xcf, 0x85, 0x8e, 0x42, 0x17, 0xaf, 0x84, 0x9e, 0x47, 0x5d, 0xd6,
	0x05, 0x6f, 0x5f, 0x18, 0x8c, 0x7a, 0x54, 0x1f, 0xcd, 0xd0, 0x89, 0x11, 0x59, 0x11, 0xc1, 0xce,
	0x25, 0xf4, 0x57, 0x46, 0x82, 0x45, 0x30, 0xb0, 0xe6, 0x92, 0x19, 0xc5, 0x3b, 0xc4, 0x8a, 0xde,
	0x04, 0xbc, 0xd6, 0x58, 0x08, 0x8d, 0x51, 0x7b, 0x81, 0xf0, 0x4a, 0xa9, 0x44, 0xcd, 0x5c, 0xc7,
	0x2d, 0xb2, 0x8f, 0x29, 0x1a, 0xea, 0xc0, 0x3d, 0xd8, 0x58, 0x02, 0x14, 0xe3, 0xbf, 0x8c, 0xbe,
	0x7f, 0xb7, 0xd9, 0xfa, 0xe1, 0xdd, 0x66, 0xeb, 0xc7, 0x77, 0x9b, 0xad, 0x6f, 0x7e, 0xde, 0xbc,
	0x33, 0x09, 0xec, 0x9f, 0xf8, 0xf3, 0xdf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4c, 0x63, 0xfc, 0x67,
	0xb7, 0x0b, 0x00, 0x00,
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.MaxPeerCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.MaxPeerCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeLabel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeLabel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.ServerAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ServerAddr)))
		i += copy(dAtA[i:], m.ServerAddr)
	}
	if len(m.RaftAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RaftAddr)))
		i += copy(dAtA[i:], m.RaftAddr)
	}
	if len(m.AdminAddr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.AdminAddr)))
		i += copy(dAtA[i:], m.AdminAddr)
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Peer.Size()))
		n1, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Index))
	}
	if m.Commit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Commit))
	}
	if m.DownSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DownSeconds))
	}
	if m.Snapshotting {
		dAtA[i] = 0x28
		i++
		if m.Snapshotting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Applied != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Applied))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeId))
	}
	if m.Peer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Peer.Size()))
		n2, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RangeEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.RangeEpoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeEpoch.Size()))
		n3, err := m.RangeEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TableId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.TableId))
	}
	if len(m.PrimaryKeys) > 0 {
		for _, msg := range m.PrimaryKeys {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Leader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.NodeAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.NodeAddr)))
		i += copy(dAtA[i:], m.NodeAddr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Range.Size()))
		n4, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Leader != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Leader.Size()))
		n5, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if m.Version != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.DataType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DataType))
	}
	if m.Unsigned {
		dAtA[i] = 0x20
		i++
		if m.Unsigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Scale != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Scale))
	}
	if m.Precision != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Precision))
	}
	if m.Nullable {
		dAtA[i] = 0x38
		i++
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrimaryKey != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Ordinal))
	}
	if m.Index {
		dAtA[i] = 0x50
		i++
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DefaultValue) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DefaultValue)))
		i += copy(dAtA[i:], m.DefaultValue)
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if m.AutoIncrement {
		dAtA[i] = 0x68
		i++
		if m.AutoIncrement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Unique {
		dAtA[i] = 0x70
		i++
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Primary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColumnName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ColumnName)))
		i += copy(dAtA[i:], m.ColumnName)
	}
	if m.Next != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Next.Size()))
		n6, err := m.Next.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DbName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if m.DbId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DbId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Epoch != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Epoch.Size()))
		n7, err := m.Epoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Regxs) > 0 {
		for _, msg := range m.Regxs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	if m.PkDupCheck {
		dAtA[i] = 0x50
		i++
		if m.PkDupCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Status != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	}
	if len(m.Expand) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expand)))
		i += copy(dAtA[i:], m.Expand)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.MaxPeerCount != 0 {
		n += 1 + sovMetapb(uint64(m.MaxPeerCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeLabel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.ServerAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.RaftAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.AdminAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	if m.Type != 0 {
		n += 1 + sovMetapb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMetapb(uint64(m.Index))
	}
	if m.Commit != 0 {
		n += 1 + sovMetapb(uint64(m.Commit))
	}
	if m.DownSeconds != 0 {
		n += 1 + sovMetapb(uint64(m.DownSeconds))
	}
	if m.Snapshotting {
		n += 2
	}
	if m.Applied != 0 {
		n += 1 + sovMetapb(uint64(m.Applied))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovMetapb(uint64(m.RangeId))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RangeEpoch != nil {
		l = m.RangeEpoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.TableId != 0 {
		n += 1 + sovMetapb(uint64(m.TableId))
	}
	if len(m.PrimaryKeys) > 0 {
		for _, e := range m.PrimaryKeys {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Leader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovMetapb(uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.DataType != 0 {
		n += 1 + sovMetapb(uint64(m.DataType))
	}
	if m.Unsigned {
		n += 2
	}
	if m.Scale != 0 {
		n += 1 + sovMetapb(uint64(m.Scale))
	}
	if m.Precision != 0 {
		n += 1 + sovMetapb(uint64(m.Precision))
	}
	if m.Nullable {
		n += 2
	}
	if m.PrimaryKey != 0 {
		n += 1 + sovMetapb(uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		n += 1 + sovMetapb(uint64(m.Ordinal))
	}
	if m.Index {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.AutoIncrement {
		n += 2
	}
	if m.Unique {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Primary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMetapb(uint64(m.DbId))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Regxs) > 0 {
		for _, e := range m.Regxs {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	if m.PkDupCheck {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovMetapb(uint64(m.Status))
	}
	l = len(m.Expand)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeerCount", wireType)
			}
			m.MaxPeerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeerCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeLabel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeLabel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeLabel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (NodeState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &NodeLabel{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PeerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshotting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshotting = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEpoch == nil {
				m.RangeEpoch = &RangeEpoch{}
			}
			if err := m.RangeEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKeys = append(m.PrimaryKeys, &Column{})
			if err := m.PrimaryKeys[len(m.PrimaryKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= (DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unsigned = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			m.PrimaryKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = append(m.DefaultValue[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultValue == nil {
				m.DefaultValue = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncrement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncrement = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Primary{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &TableEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regxs = append(m.Regxs, &Column{})
			if err := m.Regxs[len(m.Regxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkDupCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PkDupCheck = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TableStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expand = append(m.Expand[:0], dAtA[iNdEx:postIndex]...)
			if m.Expand == nil {
				m.Expand = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)
