// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: watchpb.proto

/*
	Package watchpb is a generated protocol buffer package.

	It is generated from these files:
		watchpb.proto

	It has these top-level messages:
		Event
		WatchKeyValue
		DsWatchRequest
		WatchCreateRequest
		DsWatchResponse
		WatchResponse
		DsKvWatchPutRequest
		DsKvWatchPutResponse
		KvWatchPutRequest
		DsKvWatchDeleteRequest
		DsKvWatchDeleteResponse
		KvWatchDeleteRequest
		KvWatchResponse
		DsKvWatchGetMultiRequest
		DsKvWatchGetMultiResponse
*/
package watchpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import kvrpcpb "model/pkg/kvrpcpb"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EventType int32

const (
	EventType_PUT    EventType = 0
	EventType_DELETE EventType = 1
)

var EventType_name = map[int32]string{
	0: "PUT",
	1: "DELETE",
}
var EventType_value = map[string]int32{
	"PUT":    0,
	"DELETE": 1,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}
func (EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{0} }

type ScopeValue int32

const (
	ScopeValue_RESPONSE_PART ScopeValue = 0
	ScopeValue_RESPONSE_ALL  ScopeValue = 1
)

var ScopeValue_name = map[int32]string{
	0: "RESPONSE_PART",
	1: "RESPONSE_ALL",
}
var ScopeValue_value = map[string]int32{
	"RESPONSE_PART": 0,
	"RESPONSE_ALL":  1,
}

func (x ScopeValue) String() string {
	return proto.EnumName(ScopeValue_name, int32(x))
}
func (ScopeValue) EnumDescriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{1} }

type FilterType int32

const (
	// filter out put event.
	FilterType_NOPUT FilterType = 0
	// filter out delete event.
	FilterType_NODELETE FilterType = 1
)

var FilterType_name = map[int32]string{
	0: "NOPUT",
	1: "NODELETE",
}
var FilterType_value = map[string]int32{
	"NOPUT":    0,
	"NODELETE": 1,
}

func (x FilterType) String() string {
	return proto.EnumName(FilterType_name, int32(x))
}
func (FilterType) EnumDescriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{2} }

type Event struct {
	// type is the kind of event. If type is a PUT, it indicates
	// new data has been stored to the key. If type is a DELETE,
	// it indicates the key was deleted.
	Type EventType `protobuf:"varint,1,opt,name=type,proto3,enum=watchpb.EventType" json:"type,omitempty"`
	// kv holds the KeyValue for the event.
	// A PUT event contains current kv pair.
	// A PUT event with kv.Version=1 indicates the creation of a key.
	// A DELETE/EXPIRE event contains the deleted key with
	// its modification revision set to the revision of deletion.
	Kv *WatchKeyValue `protobuf:"bytes,2,opt,name=kv" json:"kv,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{0} }

func (m *Event) GetType() EventType {
	if m != nil {
		return m.Type
	}
	return EventType_PUT
}

func (m *Event) GetKv() *WatchKeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

// simple key
type WatchKeyValue struct {
	TableId int64 `protobuf:"varint,1,opt,name=tableId,proto3" json:"tableId,omitempty"`
	// key is the key in bytes. An empty key is not allowed.
	Key [][]byte `protobuf:"bytes,2,rep,name=key" json:"key,omitempty"`
	// version is the version of the key. A deletion resets
	// the version to zero and any modification of the key
	// increases its version.
	Version int64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// value is the value held by the key, in bytes.
	Value []byte `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// expire time
	ExpireAt uint64 `protobuf:"varint,5,opt,name=expireAt,proto3" json:"expireAt,omitempty"`
	// reserve
	Ext []byte `protobuf:"bytes,6,opt,name=ext,proto3" json:"ext,omitempty"`
}

func (m *WatchKeyValue) Reset()                    { *m = WatchKeyValue{} }
func (m *WatchKeyValue) String() string            { return proto.CompactTextString(m) }
func (*WatchKeyValue) ProtoMessage()               {}
func (*WatchKeyValue) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{1} }

func (m *WatchKeyValue) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *WatchKeyValue) GetKey() [][]byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WatchKeyValue) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *WatchKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WatchKeyValue) GetExpireAt() uint64 {
	if m != nil {
		return m.ExpireAt
	}
	return 0
}

func (m *WatchKeyValue) GetExt() []byte {
	if m != nil {
		return m.Ext
	}
	return nil
}

// create watch simple key
type DsWatchRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *WatchCreateRequest    `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsWatchRequest) Reset()                    { *m = DsWatchRequest{} }
func (m *DsWatchRequest) String() string            { return proto.CompactTextString(m) }
func (*DsWatchRequest) ProtoMessage()               {}
func (*DsWatchRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{2} }

func (m *DsWatchRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsWatchRequest) GetReq() *WatchCreateRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type WatchCreateRequest struct {
	// key is the key to register for watching.
	Kv *WatchKeyValue `protobuf:"bytes,1,opt,name=kv" json:"kv,omitempty"`
	// start_revision is an optional revision to watch from (inclusive). No start_revision is "now".
	StartVersion int64 `protobuf:"varint,2,opt,name=startVersion,proto3" json:"startVersion,omitempty"`
	// filters filter the events at server side before it sends back to the watcher.
	Filters []FilterType `protobuf:"varint,3,rep,packed,name=filters,enum=watchpb.FilterType" json:"filters,omitempty"`
	// If watch_id is provided and non-zero, it will be assigned to this watcher.
	// Since creating a watcher in etcd is not a synchronous operation,
	// this can be used ensure that ordering is correct when creating multiple
	// watchers on the same stream. Creating a watcher with an ID already in
	// use on the stream will cause an error to be returned.
	WatchId int64 `protobuf:"varint,4,opt,name=watchId,proto3" json:"watchId,omitempty"`
	// TTL
	ExpireAt int64 `protobuf:"varint,5,opt,name=expireAt,proto3" json:"expireAt,omitempty"`
	Prefix   bool  `protobuf:"varint,6,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// longPull timeOut
	// timeUnit millisecond
	LongPull int64 `protobuf:"varint,7,opt,name=longPull,proto3" json:"longPull,omitempty"`
}

func (m *WatchCreateRequest) Reset()                    { *m = WatchCreateRequest{} }
func (m *WatchCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchCreateRequest) ProtoMessage()               {}
func (*WatchCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{3} }

func (m *WatchCreateRequest) GetKv() *WatchKeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *WatchCreateRequest) GetStartVersion() int64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *WatchCreateRequest) GetFilters() []FilterType {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *WatchCreateRequest) GetWatchId() int64 {
	if m != nil {
		return m.WatchId
	}
	return 0
}

func (m *WatchCreateRequest) GetExpireAt() int64 {
	if m != nil {
		return m.ExpireAt
	}
	return 0
}

func (m *WatchCreateRequest) GetPrefix() bool {
	if m != nil {
		return m.Prefix
	}
	return false
}

func (m *WatchCreateRequest) GetLongPull() int64 {
	if m != nil {
		return m.LongPull
	}
	return 0
}

// watch simple key response
type DsWatchResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *WatchResponse          `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsWatchResponse) Reset()                    { *m = DsWatchResponse{} }
func (m *DsWatchResponse) String() string            { return proto.CompactTextString(m) }
func (*DsWatchResponse) ProtoMessage()               {}
func (*DsWatchResponse) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{4} }

func (m *DsWatchResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsWatchResponse) GetResp() *WatchResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

// common watch response
type WatchResponse struct {
	// watch_id is the ID of the watcher that corresponds to the response.
	WatchId int64    `protobuf:"varint,1,opt,name=watchId,proto3" json:"watchId,omitempty"`
	Code    int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Scope   int32    `protobuf:"varint,6,opt,name=scope,proto3" json:"scope,omitempty"`
	Events  []*Event `protobuf:"bytes,9,rep,name=events" json:"events,omitempty"`
}

func (m *WatchResponse) Reset()                    { *m = WatchResponse{} }
func (m *WatchResponse) String() string            { return proto.CompactTextString(m) }
func (*WatchResponse) ProtoMessage()               {}
func (*WatchResponse) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{5} }

func (m *WatchResponse) GetWatchId() int64 {
	if m != nil {
		return m.WatchId
	}
	return 0
}

func (m *WatchResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *WatchResponse) GetScope() int32 {
	if m != nil {
		return m.Scope
	}
	return 0
}

func (m *WatchResponse) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// simple KV add request
type DsKvWatchPutRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *KvWatchPutRequest     `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsKvWatchPutRequest) Reset()                    { *m = DsKvWatchPutRequest{} }
func (m *DsKvWatchPutRequest) String() string            { return proto.CompactTextString(m) }
func (*DsKvWatchPutRequest) ProtoMessage()               {}
func (*DsKvWatchPutRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{6} }

func (m *DsKvWatchPutRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsKvWatchPutRequest) GetReq() *KvWatchPutRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

// simple KV add response
type DsKvWatchPutResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *KvWatchResponse        `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsKvWatchPutResponse) Reset()                    { *m = DsKvWatchPutResponse{} }
func (m *DsKvWatchPutResponse) String() string            { return proto.CompactTextString(m) }
func (*DsKvWatchPutResponse) ProtoMessage()               {}
func (*DsKvWatchPutResponse) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{7} }

func (m *DsKvWatchPutResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsKvWatchPutResponse) GetResp() *KvWatchResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

type KvWatchPutRequest struct {
	Kv *WatchKeyValue `protobuf:"bytes,1,opt,name=kv" json:"kv,omitempty"`
}

func (m *KvWatchPutRequest) Reset()                    { *m = KvWatchPutRequest{} }
func (m *KvWatchPutRequest) String() string            { return proto.CompactTextString(m) }
func (*KvWatchPutRequest) ProtoMessage()               {}
func (*KvWatchPutRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{8} }

func (m *KvWatchPutRequest) GetKv() *WatchKeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

// simple KV delete request
type DsKvWatchDeleteRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Req    *KvWatchDeleteRequest  `protobuf:"bytes,2,opt,name=req" json:"req,omitempty"`
}

func (m *DsKvWatchDeleteRequest) Reset()                    { *m = DsKvWatchDeleteRequest{} }
func (m *DsKvWatchDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DsKvWatchDeleteRequest) ProtoMessage()               {}
func (*DsKvWatchDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{9} }

func (m *DsKvWatchDeleteRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsKvWatchDeleteRequest) GetReq() *KvWatchDeleteRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

// simple KV delete response
type DsKvWatchDeleteResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Resp   *KvWatchResponse        `protobuf:"bytes,2,opt,name=resp" json:"resp,omitempty"`
}

func (m *DsKvWatchDeleteResponse) Reset()                    { *m = DsKvWatchDeleteResponse{} }
func (m *DsKvWatchDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DsKvWatchDeleteResponse) ProtoMessage()               {}
func (*DsKvWatchDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{10} }

func (m *DsKvWatchDeleteResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsKvWatchDeleteResponse) GetResp() *KvWatchResponse {
	if m != nil {
		return m.Resp
	}
	return nil
}

type KvWatchDeleteRequest struct {
	Kv     *WatchKeyValue `protobuf:"bytes,1,opt,name=kv" json:"kv,omitempty"`
	Prefix bool           `protobuf:"varint,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *KvWatchDeleteRequest) Reset()                    { *m = KvWatchDeleteRequest{} }
func (m *KvWatchDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*KvWatchDeleteRequest) ProtoMessage()               {}
func (*KvWatchDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{11} }

func (m *KvWatchDeleteRequest) GetKv() *WatchKeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *KvWatchDeleteRequest) GetPrefix() bool {
	if m != nil {
		return m.Prefix
	}
	return false
}

// common simple KV operation response
type KvWatchResponse struct {
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *KvWatchResponse) Reset()                    { *m = KvWatchResponse{} }
func (m *KvWatchResponse) String() string            { return proto.CompactTextString(m) }
func (*KvWatchResponse) ProtoMessage()               {}
func (*KvWatchResponse) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{12} }

func (m *KvWatchResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// get single or multiple keys request
type DsKvWatchGetMultiRequest struct {
	Header *kvrpcpb.RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Kv     *WatchKeyValue         `protobuf:"bytes,2,opt,name=kv" json:"kv,omitempty"`
	Prefix bool                   `protobuf:"varint,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Limit  uint32                 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *DsKvWatchGetMultiRequest) Reset()                    { *m = DsKvWatchGetMultiRequest{} }
func (m *DsKvWatchGetMultiRequest) String() string            { return proto.CompactTextString(m) }
func (*DsKvWatchGetMultiRequest) ProtoMessage()               {}
func (*DsKvWatchGetMultiRequest) Descriptor() ([]byte, []int) { return fileDescriptorWatchpb, []int{13} }

func (m *DsKvWatchGetMultiRequest) GetHeader() *kvrpcpb.RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsKvWatchGetMultiRequest) GetKv() *WatchKeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

func (m *DsKvWatchGetMultiRequest) GetPrefix() bool {
	if m != nil {
		return m.Prefix
	}
	return false
}

func (m *DsKvWatchGetMultiRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// get single or multiple keys response
type DsKvWatchGetMultiResponse struct {
	Header *kvrpcpb.ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Code   int32                   `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Kvs    []*WatchKeyValue        `protobuf:"bytes,3,rep,name=kvs" json:"kvs,omitempty"`
}

func (m *DsKvWatchGetMultiResponse) Reset()         { *m = DsKvWatchGetMultiResponse{} }
func (m *DsKvWatchGetMultiResponse) String() string { return proto.CompactTextString(m) }
func (*DsKvWatchGetMultiResponse) ProtoMessage()    {}
func (*DsKvWatchGetMultiResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorWatchpb, []int{14}
}

func (m *DsKvWatchGetMultiResponse) GetHeader() *kvrpcpb.ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DsKvWatchGetMultiResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DsKvWatchGetMultiResponse) GetKvs() []*WatchKeyValue {
	if m != nil {
		return m.Kvs
	}
	return nil
}

func init() {
	proto.RegisterType((*Event)(nil), "watchpb.Event")
	proto.RegisterType((*WatchKeyValue)(nil), "watchpb.WatchKeyValue")
	proto.RegisterType((*DsWatchRequest)(nil), "watchpb.DsWatchRequest")
	proto.RegisterType((*WatchCreateRequest)(nil), "watchpb.WatchCreateRequest")
	proto.RegisterType((*DsWatchResponse)(nil), "watchpb.DsWatchResponse")
	proto.RegisterType((*WatchResponse)(nil), "watchpb.WatchResponse")
	proto.RegisterType((*DsKvWatchPutRequest)(nil), "watchpb.DsKvWatchPutRequest")
	proto.RegisterType((*DsKvWatchPutResponse)(nil), "watchpb.DsKvWatchPutResponse")
	proto.RegisterType((*KvWatchPutRequest)(nil), "watchpb.KvWatchPutRequest")
	proto.RegisterType((*DsKvWatchDeleteRequest)(nil), "watchpb.DsKvWatchDeleteRequest")
	proto.RegisterType((*DsKvWatchDeleteResponse)(nil), "watchpb.DsKvWatchDeleteResponse")
	proto.RegisterType((*KvWatchDeleteRequest)(nil), "watchpb.KvWatchDeleteRequest")
	proto.RegisterType((*KvWatchResponse)(nil), "watchpb.KvWatchResponse")
	proto.RegisterType((*DsKvWatchGetMultiRequest)(nil), "watchpb.DsKvWatchGetMultiRequest")
	proto.RegisterType((*DsKvWatchGetMultiResponse)(nil), "watchpb.DsKvWatchGetMultiResponse")
	proto.RegisterEnum("watchpb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("watchpb.ScopeValue", ScopeValue_name, ScopeValue_value)
	proto.RegisterEnum("watchpb.FilterType", FilterType_name, FilterType_value)
}
func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Type))
	}
	if m.Kv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Kv.Size()))
		n1, err := m.Kv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *WatchKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchKeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.TableId))
	}
	if len(m.Key) > 0 {
		for _, b := range m.Key {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWatchpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Version))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.ExpireAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.ExpireAt))
	}
	if len(m.Ext) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(len(m.Ext)))
		i += copy(dAtA[i:], m.Ext)
	}
	return i, nil
}

func (m *DsWatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsWatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n2, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Req.Size()))
		n3, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *WatchCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kv != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Kv.Size()))
		n4, err := m.Kv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.StartVersion))
	}
	if len(m.Filters) > 0 {
		dAtA6 := make([]byte, len(m.Filters)*10)
		var j5 int
		for _, num := range m.Filters {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.WatchId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.WatchId))
	}
	if m.ExpireAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.ExpireAt))
	}
	if m.Prefix {
		dAtA[i] = 0x30
		i++
		if m.Prefix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LongPull != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.LongPull))
	}
	return i, nil
}

func (m *DsWatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsWatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n7, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Resp.Size()))
		n8, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *WatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WatchId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.WatchId))
	}
	if m.Code != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Code))
	}
	if m.Scope != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Scope))
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintWatchpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DsKvWatchPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsKvWatchPutRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n9, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Req.Size()))
		n10, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *DsKvWatchPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsKvWatchPutResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n11, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Resp.Size()))
		n12, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *KvWatchPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KvWatchPutRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kv != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Kv.Size()))
		n13, err := m.Kv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *DsKvWatchDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsKvWatchDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n14, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Req != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Req.Size()))
		n15, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *DsKvWatchDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsKvWatchDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n16, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Resp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Resp.Size()))
		n17, err := m.Resp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *KvWatchDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KvWatchDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kv != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Kv.Size()))
		n18, err := m.Kv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Prefix {
		dAtA[i] = 0x10
		i++
		if m.Prefix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *KvWatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KvWatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *DsKvWatchGetMultiRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsKvWatchGetMultiRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n19, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Kv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Kv.Size()))
		n20, err := m.Kv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Prefix {
		dAtA[i] = 0x18
		i++
		if m.Prefix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *DsKvWatchGetMultiResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsKvWatchGetMultiResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Header.Size()))
		n21, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWatchpb(dAtA, i, uint64(m.Code))
	}
	if len(m.Kvs) > 0 {
		for _, msg := range m.Kvs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintWatchpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintWatchpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Event) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovWatchpb(uint64(m.Type))
	}
	if m.Kv != nil {
		l = m.Kv.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *WatchKeyValue) Size() (n int) {
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovWatchpb(uint64(m.TableId))
	}
	if len(m.Key) > 0 {
		for _, b := range m.Key {
			l = len(b)
			n += 1 + l + sovWatchpb(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovWatchpb(uint64(m.Version))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.ExpireAt != 0 {
		n += 1 + sovWatchpb(uint64(m.ExpireAt))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *DsWatchRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *WatchCreateRequest) Size() (n int) {
	var l int
	_ = l
	if m.Kv != nil {
		l = m.Kv.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovWatchpb(uint64(m.StartVersion))
	}
	if len(m.Filters) > 0 {
		l = 0
		for _, e := range m.Filters {
			l += sovWatchpb(uint64(e))
		}
		n += 1 + sovWatchpb(uint64(l)) + l
	}
	if m.WatchId != 0 {
		n += 1 + sovWatchpb(uint64(m.WatchId))
	}
	if m.ExpireAt != 0 {
		n += 1 + sovWatchpb(uint64(m.ExpireAt))
	}
	if m.Prefix {
		n += 2
	}
	if m.LongPull != 0 {
		n += 1 + sovWatchpb(uint64(m.LongPull))
	}
	return n
}

func (m *DsWatchResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *WatchResponse) Size() (n int) {
	var l int
	_ = l
	if m.WatchId != 0 {
		n += 1 + sovWatchpb(uint64(m.WatchId))
	}
	if m.Code != 0 {
		n += 1 + sovWatchpb(uint64(m.Code))
	}
	if m.Scope != 0 {
		n += 1 + sovWatchpb(uint64(m.Scope))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovWatchpb(uint64(l))
		}
	}
	return n
}

func (m *DsKvWatchPutRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *DsKvWatchPutResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *KvWatchPutRequest) Size() (n int) {
	var l int
	_ = l
	if m.Kv != nil {
		l = m.Kv.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *DsKvWatchDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *DsKvWatchDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	return n
}

func (m *KvWatchDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Kv != nil {
		l = m.Kv.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Prefix {
		n += 2
	}
	return n
}

func (m *KvWatchResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWatchpb(uint64(m.Code))
	}
	return n
}

func (m *DsKvWatchGetMultiRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Kv != nil {
		l = m.Kv.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Prefix {
		n += 2
	}
	if m.Limit != 0 {
		n += 1 + sovWatchpb(uint64(m.Limit))
	}
	return n
}

func (m *DsKvWatchGetMultiResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovWatchpb(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovWatchpb(uint64(m.Code))
	}
	if len(m.Kvs) > 0 {
		for _, e := range m.Kvs {
			l = e.Size()
			n += 1 + l + sovWatchpb(uint64(l))
		}
	}
	return n
}

func sovWatchpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWatchpb(x uint64) (n int) {
	return sovWatchpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kv == nil {
				m.Kv = &WatchKeyValue{}
			}
			if err := m.Kv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, make([]byte, postIndex-iNdEx))
			copy(m.Key[len(m.Key)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireAt", wireType)
			}
			m.ExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = append(m.Ext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ext == nil {
				m.Ext = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsWatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsWatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsWatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &WatchCreateRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kv == nil {
				m.Kv = &WatchKeyValue{}
			}
			if err := m.Kv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v FilterType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWatchpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (FilterType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Filters = append(m.Filters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWatchpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWatchpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v FilterType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWatchpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (FilterType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Filters = append(m.Filters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatchId", wireType)
			}
			m.WatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatchId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireAt", wireType)
			}
			m.ExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prefix = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongPull", wireType)
			}
			m.LongPull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LongPull |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsWatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsWatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsWatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &WatchResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatchId", wireType)
			}
			m.WatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatchId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsKvWatchPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsKvWatchPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsKvWatchPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &KvWatchPutRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsKvWatchPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsKvWatchPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsKvWatchPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &KvWatchResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvWatchPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvWatchPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvWatchPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kv == nil {
				m.Kv = &WatchKeyValue{}
			}
			if err := m.Kv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsKvWatchDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsKvWatchDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsKvWatchDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &KvWatchDeleteRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsKvWatchDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsKvWatchDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsKvWatchDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &KvWatchResponse{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvWatchDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvWatchDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvWatchDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kv == nil {
				m.Kv = &WatchKeyValue{}
			}
			if err := m.Kv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prefix = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvWatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvWatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvWatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsKvWatchGetMultiRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsKvWatchGetMultiRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsKvWatchGetMultiRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kv == nil {
				m.Kv = &WatchKeyValue{}
			}
			if err := m.Kv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prefix = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsKvWatchGetMultiResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsKvWatchGetMultiResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsKvWatchGetMultiResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &kvrpcpb.ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWatchpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kvs = append(m.Kvs, &WatchKeyValue{})
			if err := m.Kvs[len(m.Kvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWatchpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWatchpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWatchpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWatchpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWatchpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWatchpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWatchpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWatchpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWatchpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWatchpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("watchpb.proto", fileDescriptorWatchpb) }

var fileDescriptorWatchpb = []byte{
	// 776 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x95, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xc7, 0x99, 0x38, 0x1f, 0x70, 0x48, 0x42, 0x18, 0x22, 0xf0, 0xcd, 0xd5, 0x8d, 0x7c, 0x2d,
	0x81, 0xac, 0x08, 0x8c, 0x6e, 0x58, 0xde, 0x15, 0x6d, 0xd2, 0x16, 0x41, 0x21, 0x1a, 0x28, 0x2c,
	0xab, 0x90, 0x0c, 0xc1, 0x8a, 0x13, 0x1b, 0x7b, 0x62, 0x12, 0xf5, 0x0d, 0xfa, 0x04, 0xed, 0xae,
	0x8f, 0xd3, 0x65, 0x1f, 0xa1, 0xa2, 0x4f, 0xd1, 0x5d, 0x35, 0xe3, 0x8f, 0xd8, 0x09, 0x55, 0x69,
	0x16, 0x5d, 0xc5, 0x67, 0xce, 0x7f, 0xce, 0xc7, 0x2f, 0x67, 0x66, 0xa0, 0x70, 0xdf, 0x66, 0x9d,
	0x5b, 0xfb, 0x5a, 0xb7, 0x1d, 0x8b, 0x59, 0x38, 0x17, 0x98, 0x95, 0x72, 0xcf, 0xea, 0x59, 0x62,
	0x6d, 0x9f, 0x7f, 0xf9, 0xee, 0x4a, 0xa1, 0xef, 0x39, 0x76, 0x27, 0x54, 0xab, 0x57, 0x90, 0x69,
	0x7a, 0x74, 0xc8, 0xf0, 0x0e, 0xa4, 0xd9, 0xc4, 0xa6, 0x32, 0x52, 0x90, 0x56, 0xac, 0x63, 0x3d,
	0x0c, 0x2a, 0xbc, 0x17, 0x13, 0x9b, 0x12, 0xe1, 0xc7, 0x3b, 0x90, 0xea, 0x7b, 0x72, 0x4a, 0x41,
	0xda, 0x6a, 0x7d, 0x33, 0x52, 0x5d, 0xf1, 0xdf, 0x63, 0x3a, 0xb9, 0x6c, 0x9b, 0x23, 0x4a, 0x52,
	0x7d, 0x4f, 0xfd, 0x88, 0xa0, 0x90, 0x58, 0xc5, 0x32, 0xe4, 0x58, 0xfb, 0xda, 0xa4, 0x47, 0x5d,
	0x91, 0x44, 0x22, 0xa1, 0x89, 0x4b, 0x20, 0xf5, 0xe9, 0x44, 0x4e, 0x29, 0x92, 0x96, 0x27, 0xfc,
	0x93, 0x6b, 0x3d, 0xea, 0xb8, 0x86, 0x35, 0x94, 0x25, 0x5f, 0x1b, 0x98, 0xb8, 0x0c, 0x19, 0x8f,
	0x87, 0x93, 0xd3, 0x0a, 0xd2, 0xf2, 0xc4, 0x37, 0x70, 0x05, 0x96, 0xe9, 0xd8, 0x36, 0x1c, 0x7a,
	0xc8, 0xe4, 0x8c, 0x82, 0xb4, 0x34, 0x89, 0x6c, 0x1e, 0x9d, 0x8e, 0x99, 0x9c, 0x15, 0x7a, 0xfe,
	0xa9, 0x5a, 0x50, 0x6c, 0xb8, 0xa2, 0x38, 0x42, 0xef, 0x46, 0xd4, 0x65, 0x58, 0x87, 0xec, 0x2d,
	0x6d, 0x77, 0xa9, 0x23, 0x4a, 0xe3, 0x9d, 0x85, 0x98, 0x02, 0xc5, 0x2b, 0xe1, 0x25, 0x81, 0x0a,
	0xef, 0x81, 0xe4, 0xd0, 0xbb, 0x00, 0xc3, 0xdf, 0x49, 0x0c, 0xcf, 0x1d, 0xda, 0x66, 0x34, 0xd8,
	0x47, 0xb8, 0x4e, 0xfd, 0x8e, 0x00, 0xcf, 0xfb, 0x02, 0x96, 0xe8, 0x57, 0x2c, 0xb1, 0x0a, 0x79,
	0x97, 0xb5, 0x1d, 0x76, 0x19, 0x20, 0x49, 0x09, 0x24, 0x89, 0x35, 0xbc, 0x07, 0xb9, 0x1b, 0xc3,
	0x64, 0xd4, 0x71, 0x65, 0x49, 0x91, 0xb4, 0x62, 0x7d, 0x23, 0x0a, 0xf8, 0x42, 0xac, 0x8b, 0xff,
	0x30, 0xd4, 0x70, 0xc0, 0xc2, 0x7d, 0xd4, 0x15, 0x20, 0x25, 0x12, 0x9a, 0x73, 0x28, 0xa5, 0x18,
	0xca, 0x4d, 0xc8, 0xda, 0x0e, 0xbd, 0x31, 0xc6, 0x82, 0xe6, 0x32, 0x09, 0x2c, 0xbe, 0xc7, 0xb4,
	0x86, 0xbd, 0xd6, 0xc8, 0x34, 0xe5, 0x9c, 0xbf, 0x27, 0xb4, 0xd5, 0x21, 0xac, 0x45, 0xb0, 0x5d,
	0xdb, 0x1a, 0xba, 0x14, 0xef, 0xcf, 0xd0, 0xde, 0x8a, 0xd1, 0xf6, 0x25, 0x33, 0xb8, 0x6b, 0x90,
	0x76, 0xa8, 0x6b, 0x3f, 0x3e, 0x76, 0xe1, 0x1e, 0x22, 0x34, 0xea, 0xbb, 0x60, 0xee, 0xa2, 0x6c,
	0xb1, 0x56, 0x51, 0xb2, 0x55, 0x0c, 0xe9, 0x8e, 0xd5, 0xa5, 0x62, 0xc4, 0x32, 0x44, 0x7c, 0xf3,
	0xf9, 0x72, 0x3b, 0x96, 0x4d, 0x45, 0x87, 0x19, 0xe2, 0x1b, 0x78, 0x07, 0xb2, 0x94, 0x1f, 0x04,
	0x57, 0x5e, 0x51, 0x24, 0x6d, 0xb5, 0x5e, 0x4c, 0x9e, 0x0f, 0x12, 0x78, 0x55, 0x17, 0x36, 0x1a,
	0xee, 0xb1, 0x27, 0x0a, 0x68, 0x8d, 0xd8, 0xa2, 0xe3, 0xb5, 0x1b, 0x1f, 0xaf, 0x4a, 0x94, 0x6b,
	0x2e, 0xb0, 0x3f, 0x5d, 0x23, 0x28, 0x27, 0x93, 0x2e, 0x8a, 0x79, 0x37, 0x81, 0x59, 0x9e, 0xcd,
	0x3b, 0x03, 0xfa, 0x7f, 0x58, 0x9f, 0xef, 0xf4, 0x89, 0x23, 0xad, 0x4e, 0x60, 0x33, 0xaa, 0xb9,
	0x41, 0x4d, 0x3a, 0x3d, 0x14, 0xbf, 0xcb, 0x6a, 0x3f, 0xce, 0xea, 0x9f, 0xd9, 0x9a, 0x13, 0xb1,
	0x7d, 0x5c, 0x63, 0xd8, 0x9a, 0x4b, 0xfd, 0x67, 0x88, 0x5d, 0x42, 0xf9, 0xd1, 0x96, 0x9f, 0x7a,
	0x0f, 0x4c, 0x8f, 0x5f, 0x2a, 0x7e, 0xfc, 0xd4, 0x6d, 0x58, 0x9b, 0x49, 0x18, 0x8d, 0x36, 0x9a,
	0x8e, 0xb6, 0xfa, 0x09, 0x81, 0x1c, 0x75, 0xfe, 0x92, 0xb2, 0xd7, 0x23, 0x93, 0x19, 0x8b, 0x62,
	0x7f, 0xe2, 0x3b, 0x10, 0xab, 0x59, 0x4a, 0x5c, 0x19, 0x65, 0xc8, 0x98, 0xc6, 0xc0, 0x60, 0xe2,
	0xfa, 0x29, 0x10, 0xdf, 0x50, 0xdf, 0x23, 0xf8, 0xeb, 0x91, 0x12, 0x17, 0xfd, 0x7b, 0x42, 0x0a,
	0xa9, 0xd8, 0x01, 0xd7, 0x40, 0xea, 0x7b, 0xfe, 0x25, 0xf9, 0xf3, 0xca, 0xb9, 0xa4, 0xa6, 0xc0,
	0x4a, 0xf4, 0xfa, 0xe1, 0x1c, 0x48, 0xad, 0x37, 0x17, 0xa5, 0x25, 0x0c, 0x90, 0x6d, 0x34, 0x4f,
	0x9a, 0x17, 0xcd, 0x12, 0xaa, 0xfd, 0x07, 0x70, 0xce, 0xef, 0x07, 0xff, 0x81, 0x5b, 0x87, 0x02,
	0x69, 0x9e, 0xb7, 0xce, 0x4e, 0xcf, 0x9b, 0x6f, 0x5b, 0x87, 0x84, 0x8b, 0x4b, 0x90, 0x8f, 0x96,
	0x0e, 0x4f, 0x4e, 0x4a, 0xa8, 0xb6, 0x0d, 0x30, 0xbd, 0x8f, 0xf1, 0x0a, 0x64, 0x4e, 0xcf, 0xfc,
	0xb8, 0x79, 0x58, 0x3e, 0x3d, 0x0b, 0x23, 0x3f, 0x3b, 0xf8, 0xfc, 0x50, 0x45, 0x5f, 0x1e, 0xaa,
	0xe8, 0xeb, 0x43, 0x15, 0x7d, 0xf8, 0x56, 0x5d, 0x82, 0x7f, 0x3b, 0xd6, 0x40, 0x67, 0x46, 0x4f,
	0x77, 0x6f, 0xdb, 0x4e, 0x5f, 0xef, 0x58, 0x83, 0x81, 0x35, 0xd4, 0x87, 0x94, 0xdd, 0x5b, 0x4e,
	0x5f, 0xef, 0x39, 0x76, 0xe7, 0x3a, 0x2b, 0xde, 0xf4, 0x83, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xd3, 0x63, 0xb1, 0xfa, 0x12, 0x08, 0x00, 0x00,
}
