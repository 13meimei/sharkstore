// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: statspb.proto

/*
	Package statspb is a generated protocol buffer package.

	It is generated from these files:
		statspb.proto

	It has these top-level messages:
		ClusterStats
		DatabaseStats
		TableStats
		TaskInfo
		HotSpotStats
		ScheduleCount
		DiskStats
		NetStats
		MemStats
		TpStats
		SlowLog
		SlowLogStats
		DsInfo
		ProcessStats
		MacStats
		RangeStats
		ReplicaStatus
		RaftStatus
		SqlStats
		SqlSlowlog
		SqlSlow
		SqlTp
*/
package statspb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"

	_ "github.com/gogo/protobuf/gogoproto"

	binary "encoding/binary"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TpArgs int32

const (
	TpArgs_invalid    TpArgs = 0
	TpArgs_msec_index TpArgs = 1000
	TpArgs_sec_index  TpArgs = 1060
	TpArgs_min_index  TpArgs = 1061
)

var TpArgs_name = map[int32]string{
	0:    "invalid",
	1000: "msec_index",
	1060: "sec_index",
	1061: "min_index",
}
var TpArgs_value = map[string]int32{
	"invalid":    0,
	"msec_index": 1000,
	"sec_index":  1060,
	"min_index":  1061,
}

func (x TpArgs) String() string {
	return proto.EnumName(TpArgs_name, int32(x))
}
func (TpArgs) EnumDescriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{0} }

type ClusterStats struct {
	CapacityTotal      uint64  `protobuf:"varint,1,opt,name=capacity_total,json=capacityTotal,proto3" json:"capacity_total,omitempty"`
	SizeUsed           uint64  `protobuf:"varint,2,opt,name=size_used,json=sizeUsed,proto3" json:"size_used,omitempty"`
	RangeNum           uint64  `protobuf:"varint,3,opt,name=range_num,json=rangeNum,proto3" json:"range_num,omitempty"`
	DbNum              uint64  `protobuf:"varint,4,opt,name=db_num,json=dbNum,proto3" json:"db_num,omitempty"`
	TableNum           uint64  `protobuf:"varint,5,opt,name=table_num,json=tableNum,proto3" json:"table_num,omitempty"`
	TaskNum            uint64  `protobuf:"varint,6,opt,name=task_num,json=taskNum,proto3" json:"task_num,omitempty"`
	NodeUpCount        uint64  `protobuf:"varint,7,opt,name=node_up_count,json=nodeUpCount,proto3" json:"node_up_count,omitempty"`
	NodeDownCount      uint64  `protobuf:"varint,8,opt,name=node_down_count,json=nodeDownCount,proto3" json:"node_down_count,omitempty"`
	NodeOfflineCount   uint64  `protobuf:"varint,9,opt,name=node_offline_count,json=nodeOfflineCount,proto3" json:"node_offline_count,omitempty"`
	NodeTombstoneCount uint64  `protobuf:"varint,10,opt,name=node_tombstone_count,json=nodeTombstoneCount,proto3" json:"node_tombstone_count,omitempty"`
	LeaderBalanceRatio float64 `protobuf:"fixed64,11,opt,name=leader_balance_ratio,json=leaderBalanceRatio,proto3" json:"leader_balance_ratio,omitempty"`
	RegionBalanceRatio float64 `protobuf:"fixed64,12,opt,name=region_balance_ratio,json=regionBalanceRatio,proto3" json:"region_balance_ratio,omitempty"`
}

func (m *ClusterStats) Reset()                    { *m = ClusterStats{} }
func (m *ClusterStats) String() string            { return proto.CompactTextString(m) }
func (*ClusterStats) ProtoMessage()               {}
func (*ClusterStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{0} }

func (m *ClusterStats) GetCapacityTotal() uint64 {
	if m != nil {
		return m.CapacityTotal
	}
	return 0
}

func (m *ClusterStats) GetSizeUsed() uint64 {
	if m != nil {
		return m.SizeUsed
	}
	return 0
}

func (m *ClusterStats) GetRangeNum() uint64 {
	if m != nil {
		return m.RangeNum
	}
	return 0
}

func (m *ClusterStats) GetDbNum() uint64 {
	if m != nil {
		return m.DbNum
	}
	return 0
}

func (m *ClusterStats) GetTableNum() uint64 {
	if m != nil {
		return m.TableNum
	}
	return 0
}

func (m *ClusterStats) GetTaskNum() uint64 {
	if m != nil {
		return m.TaskNum
	}
	return 0
}

func (m *ClusterStats) GetNodeUpCount() uint64 {
	if m != nil {
		return m.NodeUpCount
	}
	return 0
}

func (m *ClusterStats) GetNodeDownCount() uint64 {
	if m != nil {
		return m.NodeDownCount
	}
	return 0
}

func (m *ClusterStats) GetNodeOfflineCount() uint64 {
	if m != nil {
		return m.NodeOfflineCount
	}
	return 0
}

func (m *ClusterStats) GetNodeTombstoneCount() uint64 {
	if m != nil {
		return m.NodeTombstoneCount
	}
	return 0
}

func (m *ClusterStats) GetLeaderBalanceRatio() float64 {
	if m != nil {
		return m.LeaderBalanceRatio
	}
	return 0
}

func (m *ClusterStats) GetRegionBalanceRatio() float64 {
	if m != nil {
		return m.RegionBalanceRatio
	}
	return 0
}

type DatabaseStats struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TableNum uint32 `protobuf:"varint,2,opt,name=table_num,json=tableNum,proto3" json:"table_num,omitempty"`
}

func (m *DatabaseStats) Reset()                    { *m = DatabaseStats{} }
func (m *DatabaseStats) String() string            { return proto.CompactTextString(m) }
func (*DatabaseStats) ProtoMessage()               {}
func (*DatabaseStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{1} }

func (m *DatabaseStats) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseStats) GetTableNum() uint32 {
	if m != nil {
		return m.TableNum
	}
	return 0
}

type TableStats struct {
	DbName    string `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	RangeNum  uint64 `protobuf:"varint,3,opt,name=range_num,json=rangeNum,proto3" json:"range_num,omitempty"`
	Size_     uint64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *TableStats) Reset()                    { *m = TableStats{} }
func (m *TableStats) String() string            { return proto.CompactTextString(m) }
func (*TableStats) ProtoMessage()               {}
func (*TableStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{2} }

func (m *TableStats) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *TableStats) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *TableStats) GetRangeNum() uint64 {
	if m != nil {
		return m.RangeNum
	}
	return 0
}

func (m *TableStats) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type TaskInfo struct {
	TaskId  uint64 `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	RangeId uint64 `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Kind    string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	Name    string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// 任务状态
	State string `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
	Start int64  `protobuf:"varint,6,opt,name=start,proto3" json:"start,omitempty"`
	End   int64  `protobuf:"varint,7,opt,name=end,proto3" json:"end,omitempty"`
	// 单位s
	UsedTime float64 `protobuf:"fixed64,8,opt,name=used_time,json=usedTime,proto3" json:"used_time,omitempty"`
	Describe string  `protobuf:"bytes,9,opt,name=describe,proto3" json:"describe,omitempty"`
}

func (m *TaskInfo) Reset()                    { *m = TaskInfo{} }
func (m *TaskInfo) String() string            { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()               {}
func (*TaskInfo) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{3} }

func (m *TaskInfo) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskInfo) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *TaskInfo) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *TaskInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TaskInfo) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *TaskInfo) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TaskInfo) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *TaskInfo) GetUsedTime() float64 {
	if m != nil {
		return m.UsedTime
	}
	return 0
}

func (m *TaskInfo) GetDescribe() string {
	if m != nil {
		return m.Describe
	}
	return ""
}

type HotSpotStats struct {
	NodeId                    uint64  `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr                  string  `protobuf:"bytes,2,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	TotalWrittenBytesAsPeer   float64 `protobuf:"fixed64,3,opt,name=total_written_bytes_as_peer,json=totalWrittenBytesAsPeer,proto3" json:"total_written_bytes_as_peer,omitempty"`
	HotWriteRegionAsPeer      uint64  `protobuf:"varint,4,opt,name=hot_write_region_as_peer,json=hotWriteRegionAsPeer,proto3" json:"hot_write_region_as_peer,omitempty"`
	TotalWrittenBytesAsLeader float64 `protobuf:"fixed64,5,opt,name=total_written_bytes_as_leader,json=totalWrittenBytesAsLeader,proto3" json:"total_written_bytes_as_leader,omitempty"`
	HotWriteRegionAsLeader    uint64  `protobuf:"varint,6,opt,name=hot_write_region_as_leader,json=hotWriteRegionAsLeader,proto3" json:"hot_write_region_as_leader,omitempty"`
}

func (m *HotSpotStats) Reset()                    { *m = HotSpotStats{} }
func (m *HotSpotStats) String() string            { return proto.CompactTextString(m) }
func (*HotSpotStats) ProtoMessage()               {}
func (*HotSpotStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{4} }

func (m *HotSpotStats) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *HotSpotStats) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

func (m *HotSpotStats) GetTotalWrittenBytesAsPeer() float64 {
	if m != nil {
		return m.TotalWrittenBytesAsPeer
	}
	return 0
}

func (m *HotSpotStats) GetHotWriteRegionAsPeer() uint64 {
	if m != nil {
		return m.HotWriteRegionAsPeer
	}
	return 0
}

func (m *HotSpotStats) GetTotalWrittenBytesAsLeader() float64 {
	if m != nil {
		return m.TotalWrittenBytesAsLeader
	}
	return 0
}

func (m *HotSpotStats) GetHotWriteRegionAsLeader() uint64 {
	if m != nil {
		return m.HotWriteRegionAsLeader
	}
	return 0
}

type ScheduleCount struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Count uint64 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *ScheduleCount) Reset()                    { *m = ScheduleCount{} }
func (m *ScheduleCount) String() string            { return proto.CompactTextString(m) }
func (*ScheduleCount) ProtoMessage()               {}
func (*ScheduleCount) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{5} }

func (m *ScheduleCount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScheduleCount) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *ScheduleCount) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type DiskStats struct {
	DiskPath             string  `protobuf:"bytes,1,opt,name=disk_path,json=diskPath,proto3" json:"disk_path,omitempty"`
	DiskTotal            uint64  `protobuf:"varint,2,opt,name=disk_total,json=diskTotal,proto3" json:"disk_total,omitempty"`
	DiskUsed             uint64  `protobuf:"varint,3,opt,name=disk_used,json=diskUsed,proto3" json:"disk_used,omitempty"`
	DiskFree             uint64  `protobuf:"varint,4,opt,name=disk_free,json=diskFree,proto3" json:"disk_free,omitempty"`
	DiskProcRate         float64 `protobuf:"fixed64,5,opt,name=disk_proc_rate,json=diskProcRate,proto3" json:"disk_proc_rate,omitempty"`
	DiskReadBytePerSec   uint64  `protobuf:"varint,6,opt,name=disk_read_byte_per_sec,json=diskReadBytePerSec,proto3" json:"disk_read_byte_per_sec,omitempty"`
	DiskWriteBytePerSec  uint64  `protobuf:"varint,7,opt,name=disk_write_byte_per_sec,json=diskWriteBytePerSec,proto3" json:"disk_write_byte_per_sec,omitempty"`
	DiskReadCountPerSec  uint64  `protobuf:"varint,8,opt,name=disk_read_count_per_sec,json=diskReadCountPerSec,proto3" json:"disk_read_count_per_sec,omitempty"`
	DiskWriteCountPerSec uint64  `protobuf:"varint,9,opt,name=disk_write_count_per_sec,json=diskWriteCountPerSec,proto3" json:"disk_write_count_per_sec,omitempty"`
}

func (m *DiskStats) Reset()                    { *m = DiskStats{} }
func (m *DiskStats) String() string            { return proto.CompactTextString(m) }
func (*DiskStats) ProtoMessage()               {}
func (*DiskStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{6} }

func (m *DiskStats) GetDiskPath() string {
	if m != nil {
		return m.DiskPath
	}
	return ""
}

func (m *DiskStats) GetDiskTotal() uint64 {
	if m != nil {
		return m.DiskTotal
	}
	return 0
}

func (m *DiskStats) GetDiskUsed() uint64 {
	if m != nil {
		return m.DiskUsed
	}
	return 0
}

func (m *DiskStats) GetDiskFree() uint64 {
	if m != nil {
		return m.DiskFree
	}
	return 0
}

func (m *DiskStats) GetDiskProcRate() float64 {
	if m != nil {
		return m.DiskProcRate
	}
	return 0
}

func (m *DiskStats) GetDiskReadBytePerSec() uint64 {
	if m != nil {
		return m.DiskReadBytePerSec
	}
	return 0
}

func (m *DiskStats) GetDiskWriteBytePerSec() uint64 {
	if m != nil {
		return m.DiskWriteBytePerSec
	}
	return 0
}

func (m *DiskStats) GetDiskReadCountPerSec() uint64 {
	if m != nil {
		return m.DiskReadCountPerSec
	}
	return 0
}

func (m *DiskStats) GetDiskWriteCountPerSec() uint64 {
	if m != nil {
		return m.DiskWriteCountPerSec
	}
	return 0
}

type NetStats struct {
	NetIoInBytePerSec             uint64 `protobuf:"varint,1,opt,name=net_io_in_byte_per_sec,json=netIoInBytePerSec,proto3" json:"net_io_in_byte_per_sec,omitempty"`
	NetIoOutBytePerSec            uint64 `protobuf:"varint,2,opt,name=net_io_out_byte_per_sec,json=netIoOutBytePerSec,proto3" json:"net_io_out_byte_per_sec,omitempty"`
	NetIoInPackagePerSec          uint64 `protobuf:"varint,3,opt,name=net_io_in_package_per_sec,json=netIoInPackagePerSec,proto3" json:"net_io_in_package_per_sec,omitempty"`
	NetIoOutPackagePerSec         uint64 `protobuf:"varint,4,opt,name=net_io_out_package_per_sec,json=netIoOutPackagePerSec,proto3" json:"net_io_out_package_per_sec,omitempty"`
	NetTcpConnections             uint32 `protobuf:"varint,5,opt,name=net_tcp_connections,json=netTcpConnections,proto3" json:"net_tcp_connections,omitempty"`
	NetTcpActiveOpensPerSec       uint64 `protobuf:"varint,6,opt,name=net_tcp_active_opens_per_sec,json=netTcpActiveOpensPerSec,proto3" json:"net_tcp_active_opens_per_sec,omitempty"`
	NetIpRecvPackagePerSec        uint64 `protobuf:"varint,7,opt,name=net_ip_recv_package_per_sec,json=netIpRecvPackagePerSec,proto3" json:"net_ip_recv_package_per_sec,omitempty"`
	NetIpSendPackagePerSec        uint64 `protobuf:"varint,8,opt,name=net_ip_send_package_per_sec,json=netIpSendPackagePerSec,proto3" json:"net_ip_send_package_per_sec,omitempty"`
	NetIpDropPackagePerSec        uint64 `protobuf:"varint,9,opt,name=net_ip_drop_package_per_sec,json=netIpDropPackagePerSec,proto3" json:"net_ip_drop_package_per_sec,omitempty"`
	NetTcpRecvPackagePerSec       uint64 `protobuf:"varint,10,opt,name=net_tcp_recv_package_per_sec,json=netTcpRecvPackagePerSec,proto3" json:"net_tcp_recv_package_per_sec,omitempty"`
	NetTcpSendPackagePerSec       uint64 `protobuf:"varint,11,opt,name=net_tcp_send_package_per_sec,json=netTcpSendPackagePerSec,proto3" json:"net_tcp_send_package_per_sec,omitempty"`
	NetTcpErrPackagePerSec        uint64 `protobuf:"varint,12,opt,name=net_tcp_err_package_per_sec,json=netTcpErrPackagePerSec,proto3" json:"net_tcp_err_package_per_sec,omitempty"`
	NetTcpRetransferPackagePerSec uint64 `protobuf:"varint,13,opt,name=net_tcp_retransfer_package_per_sec,json=netTcpRetransferPackagePerSec,proto3" json:"net_tcp_retransfer_package_per_sec,omitempty"`
}

func (m *NetStats) Reset()                    { *m = NetStats{} }
func (m *NetStats) String() string            { return proto.CompactTextString(m) }
func (*NetStats) ProtoMessage()               {}
func (*NetStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{7} }

func (m *NetStats) GetNetIoInBytePerSec() uint64 {
	if m != nil {
		return m.NetIoInBytePerSec
	}
	return 0
}

func (m *NetStats) GetNetIoOutBytePerSec() uint64 {
	if m != nil {
		return m.NetIoOutBytePerSec
	}
	return 0
}

func (m *NetStats) GetNetIoInPackagePerSec() uint64 {
	if m != nil {
		return m.NetIoInPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetIoOutPackagePerSec() uint64 {
	if m != nil {
		return m.NetIoOutPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetTcpConnections() uint32 {
	if m != nil {
		return m.NetTcpConnections
	}
	return 0
}

func (m *NetStats) GetNetTcpActiveOpensPerSec() uint64 {
	if m != nil {
		return m.NetTcpActiveOpensPerSec
	}
	return 0
}

func (m *NetStats) GetNetIpRecvPackagePerSec() uint64 {
	if m != nil {
		return m.NetIpRecvPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetIpSendPackagePerSec() uint64 {
	if m != nil {
		return m.NetIpSendPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetIpDropPackagePerSec() uint64 {
	if m != nil {
		return m.NetIpDropPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetTcpRecvPackagePerSec() uint64 {
	if m != nil {
		return m.NetTcpRecvPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetTcpSendPackagePerSec() uint64 {
	if m != nil {
		return m.NetTcpSendPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetTcpErrPackagePerSec() uint64 {
	if m != nil {
		return m.NetTcpErrPackagePerSec
	}
	return 0
}

func (m *NetStats) GetNetTcpRetransferPackagePerSec() uint64 {
	if m != nil {
		return m.NetTcpRetransferPackagePerSec
	}
	return 0
}

type MemStats struct {
	MemoryTotal           uint64  `protobuf:"varint,1,opt,name=memory_total,json=memoryTotal,proto3" json:"memory_total,omitempty"`
	MemoryUsedRss         uint64  `protobuf:"varint,2,opt,name=memory_used_rss,json=memoryUsedRss,proto3" json:"memory_used_rss,omitempty"`
	MemoryUsed            uint64  `protobuf:"varint,3,opt,name=memory_used,json=memoryUsed,proto3" json:"memory_used,omitempty"`
	MemoryFree            uint64  `protobuf:"varint,4,opt,name=memory_free,json=memoryFree,proto3" json:"memory_free,omitempty"`
	MemoryUsedPercent     float64 `protobuf:"fixed64,5,opt,name=memory_used_percent,json=memoryUsedPercent,proto3" json:"memory_used_percent,omitempty"`
	SwapMemoryTotal       uint64  `protobuf:"varint,6,opt,name=swap_memory_total,json=swapMemoryTotal,proto3" json:"swap_memory_total,omitempty"`
	SwapMemoryUsed        uint64  `protobuf:"varint,7,opt,name=swap_memory_used,json=swapMemoryUsed,proto3" json:"swap_memory_used,omitempty"`
	SwapMemoryFree        uint64  `protobuf:"varint,8,opt,name=swap_memory_free,json=swapMemoryFree,proto3" json:"swap_memory_free,omitempty"`
	SwapMemoryUsedPercent float64 `protobuf:"fixed64,9,opt,name=swap_memory_used_percent,json=swapMemoryUsedPercent,proto3" json:"swap_memory_used_percent,omitempty"`
}

func (m *MemStats) Reset()                    { *m = MemStats{} }
func (m *MemStats) String() string            { return proto.CompactTextString(m) }
func (*MemStats) ProtoMessage()               {}
func (*MemStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{8} }

func (m *MemStats) GetMemoryTotal() uint64 {
	if m != nil {
		return m.MemoryTotal
	}
	return 0
}

func (m *MemStats) GetMemoryUsedRss() uint64 {
	if m != nil {
		return m.MemoryUsedRss
	}
	return 0
}

func (m *MemStats) GetMemoryUsed() uint64 {
	if m != nil {
		return m.MemoryUsed
	}
	return 0
}

func (m *MemStats) GetMemoryFree() uint64 {
	if m != nil {
		return m.MemoryFree
	}
	return 0
}

func (m *MemStats) GetMemoryUsedPercent() float64 {
	if m != nil {
		return m.MemoryUsedPercent
	}
	return 0
}

func (m *MemStats) GetSwapMemoryTotal() uint64 {
	if m != nil {
		return m.SwapMemoryTotal
	}
	return 0
}

func (m *MemStats) GetSwapMemoryUsed() uint64 {
	if m != nil {
		return m.SwapMemoryUsed
	}
	return 0
}

func (m *MemStats) GetSwapMemoryFree() uint64 {
	if m != nil {
		return m.SwapMemoryFree
	}
	return 0
}

func (m *MemStats) GetSwapMemoryUsedPercent() float64 {
	if m != nil {
		return m.SwapMemoryUsedPercent
	}
	return 0
}

type TpStats struct {
	Tps uint64 `protobuf:"varint,1,opt,name=tps,proto3" json:"tps,omitempty"`
	// min　latency ms
	Min float64 `protobuf:"fixed64,2,opt,name=min,proto3" json:"min,omitempty"`
	// max　latency ms
	Max float64 `protobuf:"fixed64,3,opt,name=max,proto3" json:"max,omitempty"`
	// avg　latency ms
	Avg         float64 `protobuf:"fixed64,4,opt,name=avg,proto3" json:"avg,omitempty"`
	Tp_50       float64 `protobuf:"fixed64,5,opt,name=tp_50,json=tp50,proto3" json:"tp_50,omitempty"`
	Tp_90       float64 `protobuf:"fixed64,6,opt,name=tp_90,json=tp90,proto3" json:"tp_90,omitempty"`
	Tp_99       float64 `protobuf:"fixed64,7,opt,name=tp_99,json=tp99,proto3" json:"tp_99,omitempty"`
	Tp_999      float64 `protobuf:"fixed64,8,opt,name=tp_999,json=tp999,proto3" json:"tp_999,omitempty"`
	TotalNumber uint64  `protobuf:"varint,9,opt,name=total_number,json=totalNumber,proto3" json:"total_number,omitempty"`
	ErrNumber   uint64  `protobuf:"varint,10,opt,name=err_number,json=errNumber,proto3" json:"err_number,omitempty"`
}

func (m *TpStats) Reset()                    { *m = TpStats{} }
func (m *TpStats) String() string            { return proto.CompactTextString(m) }
func (*TpStats) ProtoMessage()               {}
func (*TpStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{9} }

func (m *TpStats) GetTps() uint64 {
	if m != nil {
		return m.Tps
	}
	return 0
}

func (m *TpStats) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *TpStats) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *TpStats) GetAvg() float64 {
	if m != nil {
		return m.Avg
	}
	return 0
}

func (m *TpStats) GetTp_50() float64 {
	if m != nil {
		return m.Tp_50
	}
	return 0
}

func (m *TpStats) GetTp_90() float64 {
	if m != nil {
		return m.Tp_90
	}
	return 0
}

func (m *TpStats) GetTp_99() float64 {
	if m != nil {
		return m.Tp_99
	}
	return 0
}

func (m *TpStats) GetTp_999() float64 {
	if m != nil {
		return m.Tp_999
	}
	return 0
}

func (m *TpStats) GetTotalNumber() uint64 {
	if m != nil {
		return m.TotalNumber
	}
	return 0
}

func (m *TpStats) GetErrNumber() uint64 {
	if m != nil {
		return m.ErrNumber
	}
	return 0
}

type SlowLog struct {
	SlowLog string  `protobuf:"bytes,1,opt,name=slow_log,json=slowLog,proto3" json:"slow_log,omitempty"`
	Lats    float64 `protobuf:"fixed64,2,opt,name=lats,proto3" json:"lats,omitempty"`
}

func (m *SlowLog) Reset()                    { *m = SlowLog{} }
func (m *SlowLog) String() string            { return proto.CompactTextString(m) }
func (*SlowLog) ProtoMessage()               {}
func (*SlowLog) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{10} }

func (m *SlowLog) GetSlowLog() string {
	if m != nil {
		return m.SlowLog
	}
	return ""
}

func (m *SlowLog) GetLats() float64 {
	if m != nil {
		return m.Lats
	}
	return 0
}

type SlowLogStats struct {
	SlowLogs []*SlowLog `protobuf:"bytes,1,rep,name=slow_logs,json=slowLogs" json:"slow_logs,omitempty"`
}

func (m *SlowLogStats) Reset()                    { *m = SlowLogStats{} }
func (m *SlowLogStats) String() string            { return proto.CompactTextString(m) }
func (*SlowLogStats) ProtoMessage()               {}
func (*SlowLogStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{11} }

func (m *SlowLogStats) GetSlowLogs() []*SlowLog {
	if m != nil {
		return m.SlowLogs
	}
	return nil
}

type DsInfo struct {
	// Total range count in this store.
	RangeCount uint64 `protobuf:"varint,1,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	// Current range split count.
	RangeSplitCount uint32 `protobuf:"varint,2,opt,name=range_split_count,json=rangeSplitCount,proto3" json:"range_split_count,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint32 `protobuf:"varint,3,opt,name=sending_snap_count,json=sendingSnapCount,proto3" json:"sending_snap_count,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint32 `protobuf:"varint,4,opt,name=receiving_snap_count,json=receivingSnapCount,proto3" json:"receiving_snap_count,omitempty"`
	// How many range is applying snapshot.
	ApplyingSnapCount uint32 `protobuf:"varint,5,opt,name=applying_snap_count,json=applyingSnapCount,proto3" json:"applying_snap_count,omitempty"`
	RangeLeaderCount  uint32 `protobuf:"varint,6,opt,name=range_leader_count,json=rangeLeaderCount,proto3" json:"range_leader_count,omitempty"`
	// ds version for update
	Version string `protobuf:"bytes,7,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *DsInfo) Reset()                    { *m = DsInfo{} }
func (m *DsInfo) String() string            { return proto.CompactTextString(m) }
func (*DsInfo) ProtoMessage()               {}
func (*DsInfo) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{12} }

func (m *DsInfo) GetRangeCount() uint64 {
	if m != nil {
		return m.RangeCount
	}
	return 0
}

func (m *DsInfo) GetRangeSplitCount() uint32 {
	if m != nil {
		return m.RangeSplitCount
	}
	return 0
}

func (m *DsInfo) GetSendingSnapCount() uint32 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *DsInfo) GetReceivingSnapCount() uint32 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *DsInfo) GetApplyingSnapCount() uint32 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *DsInfo) GetRangeLeaderCount() uint32 {
	if m != nil {
		return m.RangeLeaderCount
	}
	return 0
}

func (m *DsInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ProcessStats struct {
	CpuProcRate float64 `protobuf:"fixed64,1,opt,name=cpu_proc_rate,json=cpuProcRate,proto3" json:"cpu_proc_rate,omitempty"`
	MemoryTotal uint64  `protobuf:"varint,2,opt,name=memory_total,json=memoryTotal,proto3" json:"memory_total,omitempty"`
	MemoryUsed  uint64  `protobuf:"varint,3,opt,name=memory_used,json=memoryUsed,proto3" json:"memory_used,omitempty"`
	// 客户端连接数
	ConnectCount uint64 `protobuf:"varint,4,opt,name=connect_count,json=connectCount,proto3" json:"connect_count,omitempty"`
	// 一般只有DS需要
	DiskStats *DiskStats `protobuf:"bytes,8,opt,name=disk_stats,json=diskStats" json:"disk_stats,omitempty"`
	TpStats   *TpStats   `protobuf:"bytes,9,opt,name=tp_stats,json=tpStats" json:"tp_stats,omitempty"`
	// 只有ds process需要统计这部分信息
	DsInfo *DsInfo `protobuf:"bytes,10,opt,name=ds_info,json=dsInfo" json:"ds_info,omitempty"`
	// 线程数 or 协程数
	ThreadNum uint32 `protobuf:"varint,11,opt,name=thread_num,json=threadNum,proto3" json:"thread_num,omitempty"`
	// 句柄数
	HandleNum uint32 `protobuf:"varint,12,opt,name=handle_num,json=handleNum,proto3" json:"handle_num,omitempty"`
	// When the data server is started (unix timestamp in seconds).
	StartTime int64 `protobuf:"varint,13,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
}

func (m *ProcessStats) Reset()                    { *m = ProcessStats{} }
func (m *ProcessStats) String() string            { return proto.CompactTextString(m) }
func (*ProcessStats) ProtoMessage()               {}
func (*ProcessStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{13} }

func (m *ProcessStats) GetCpuProcRate() float64 {
	if m != nil {
		return m.CpuProcRate
	}
	return 0
}

func (m *ProcessStats) GetMemoryTotal() uint64 {
	if m != nil {
		return m.MemoryTotal
	}
	return 0
}

func (m *ProcessStats) GetMemoryUsed() uint64 {
	if m != nil {
		return m.MemoryUsed
	}
	return 0
}

func (m *ProcessStats) GetConnectCount() uint64 {
	if m != nil {
		return m.ConnectCount
	}
	return 0
}

func (m *ProcessStats) GetDiskStats() *DiskStats {
	if m != nil {
		return m.DiskStats
	}
	return nil
}

func (m *ProcessStats) GetTpStats() *TpStats {
	if m != nil {
		return m.TpStats
	}
	return nil
}

func (m *ProcessStats) GetDsInfo() *DsInfo {
	if m != nil {
		return m.DsInfo
	}
	return nil
}

func (m *ProcessStats) GetThreadNum() uint32 {
	if m != nil {
		return m.ThreadNum
	}
	return 0
}

func (m *ProcessStats) GetHandleNum() uint32 {
	if m != nil {
		return m.HandleNum
	}
	return 0
}

func (m *ProcessStats) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

type MacStats struct {
	CpuProcRate float64   `protobuf:"fixed64,1,opt,name=cpu_proc_rate,json=cpuProcRate,proto3" json:"cpu_proc_rate,omitempty"`
	CpuCount    uint32    `protobuf:"varint,2,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	Load1       float64   `protobuf:"fixed64,3,opt,name=load1,proto3" json:"load1,omitempty"`
	Load5       float64   `protobuf:"fixed64,4,opt,name=load5,proto3" json:"load5,omitempty"`
	Load15      float64   `protobuf:"fixed64,5,opt,name=load15,proto3" json:"load15,omitempty"`
	MemStats    *MemStats `protobuf:"bytes,6,opt,name=mem_stats,json=memStats" json:"mem_stats,omitempty"`
	NetStats    *NetStats `protobuf:"bytes,7,opt,name=net_stats,json=netStats" json:"net_stats,omitempty"`
	// 多个磁盘的统计情况
	DiskStats []*DiskStats `protobuf:"bytes,8,rep,name=disk_stats,json=diskStats" json:"disk_stats,omitempty"`
	// 进程数
	ProcessNum uint32 `protobuf:"varint,9,opt,name=process_num,json=processNum,proto3" json:"process_num,omitempty"`
	// 线程数
	ThreadNum uint32 `protobuf:"varint,10,opt,name=thread_num,json=threadNum,proto3" json:"thread_num,omitempty"`
	// 句柄数
	HandleNum uint32 `protobuf:"varint,11,opt,name=handle_num,json=handleNum,proto3" json:"handle_num,omitempty"`
}

func (m *MacStats) Reset()                    { *m = MacStats{} }
func (m *MacStats) String() string            { return proto.CompactTextString(m) }
func (*MacStats) ProtoMessage()               {}
func (*MacStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{14} }

func (m *MacStats) GetCpuProcRate() float64 {
	if m != nil {
		return m.CpuProcRate
	}
	return 0
}

func (m *MacStats) GetCpuCount() uint32 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *MacStats) GetLoad1() float64 {
	if m != nil {
		return m.Load1
	}
	return 0
}

func (m *MacStats) GetLoad5() float64 {
	if m != nil {
		return m.Load5
	}
	return 0
}

func (m *MacStats) GetLoad15() float64 {
	if m != nil {
		return m.Load15
	}
	return 0
}

func (m *MacStats) GetMemStats() *MemStats {
	if m != nil {
		return m.MemStats
	}
	return nil
}

func (m *MacStats) GetNetStats() *NetStats {
	if m != nil {
		return m.NetStats
	}
	return nil
}

func (m *MacStats) GetDiskStats() []*DiskStats {
	if m != nil {
		return m.DiskStats
	}
	return nil
}

func (m *MacStats) GetProcessNum() uint32 {
	if m != nil {
		return m.ProcessNum
	}
	return 0
}

func (m *MacStats) GetThreadNum() uint32 {
	if m != nil {
		return m.ThreadNum
	}
	return 0
}

func (m *MacStats) GetHandleNum() uint32 {
	if m != nil {
		return m.HandleNum
	}
	return 0
}

type RangeStats struct {
	Size_                  uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Ops                    uint64 `protobuf:"varint,2,opt,name=ops,proto3" json:"ops,omitempty"`
	BytesInPerSec          uint64 `protobuf:"varint,3,opt,name=bytes_in_per_sec,json=bytesInPerSec,proto3" json:"bytes_in_per_sec,omitempty"`
	BytesOutPerSec         uint64 `protobuf:"varint,4,opt,name=bytes_out_per_sec,json=bytesOutPerSec,proto3" json:"bytes_out_per_sec,omitempty"`
	TotalCommandsProcessed uint64 `protobuf:"varint,5,opt,name=total_commands_processed,json=totalCommandsProcessed,proto3" json:"total_commands_processed,omitempty"`
	KeyspaceMisses         uint64 `protobuf:"varint,6,opt,name=keyspace_misses,json=keyspaceMisses,proto3" json:"keyspace_misses,omitempty"`
}

func (m *RangeStats) Reset()                    { *m = RangeStats{} }
func (m *RangeStats) String() string            { return proto.CompactTextString(m) }
func (*RangeStats) ProtoMessage()               {}
func (*RangeStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{15} }

func (m *RangeStats) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *RangeStats) GetOps() uint64 {
	if m != nil {
		return m.Ops
	}
	return 0
}

func (m *RangeStats) GetBytesInPerSec() uint64 {
	if m != nil {
		return m.BytesInPerSec
	}
	return 0
}

func (m *RangeStats) GetBytesOutPerSec() uint64 {
	if m != nil {
		return m.BytesOutPerSec
	}
	return 0
}

func (m *RangeStats) GetTotalCommandsProcessed() uint64 {
	if m != nil {
		return m.TotalCommandsProcessed
	}
	return 0
}

func (m *RangeStats) GetKeyspaceMisses() uint64 {
	if m != nil {
		return m.KeyspaceMisses
	}
	return 0
}

type ReplicaStatus struct {
	Match       uint64 `protobuf:"varint,1,opt,name=Match,proto3" json:"Match,omitempty"`
	Commit      uint64 `protobuf:"varint,2,opt,name=Commit,proto3" json:"Commit,omitempty"`
	Next        uint64 `protobuf:"varint,3,opt,name=Next,proto3" json:"Next,omitempty"`
	State       string `protobuf:"bytes,4,opt,name=State,proto3" json:"State,omitempty"`
	Snapshoting bool   `protobuf:"varint,5,opt,name=Snapshoting,proto3" json:"Snapshoting,omitempty"`
	Paused      bool   `protobuf:"varint,6,opt,name=Paused,proto3" json:"Paused,omitempty"`
	Active      bool   `protobuf:"varint,7,opt,name=Active,proto3" json:"Active,omitempty"`
	LastActive  int64  `protobuf:"varint,8,opt,name=LastActive,proto3" json:"LastActive,omitempty"`
	Inflight    int32  `protobuf:"varint,9,opt,name=Inflight,proto3" json:"Inflight,omitempty"`
	ID          uint64 `protobuf:"varint,10,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *ReplicaStatus) Reset()                    { *m = ReplicaStatus{} }
func (m *ReplicaStatus) String() string            { return proto.CompactTextString(m) }
func (*ReplicaStatus) ProtoMessage()               {}
func (*ReplicaStatus) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{16} }

func (m *ReplicaStatus) GetMatch() uint64 {
	if m != nil {
		return m.Match
	}
	return 0
}

func (m *ReplicaStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *ReplicaStatus) GetNext() uint64 {
	if m != nil {
		return m.Next
	}
	return 0
}

func (m *ReplicaStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ReplicaStatus) GetSnapshoting() bool {
	if m != nil {
		return m.Snapshoting
	}
	return false
}

func (m *ReplicaStatus) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ReplicaStatus) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ReplicaStatus) GetLastActive() int64 {
	if m != nil {
		return m.LastActive
	}
	return 0
}

func (m *ReplicaStatus) GetInflight() int32 {
	if m != nil {
		return m.Inflight
	}
	return 0
}

func (m *ReplicaStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type RaftStatus struct {
	ID                uint64           `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	NodeID            uint64           `protobuf:"varint,2,opt,name=NodeID,proto3" json:"NodeID,omitempty"`
	Leader            uint64           `protobuf:"varint,3,opt,name=Leader,proto3" json:"Leader,omitempty"`
	Term              uint64           `protobuf:"varint,4,opt,name=Term,proto3" json:"Term,omitempty"`
	Index             uint64           `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	Commit            uint64           `protobuf:"varint,6,opt,name=Commit,proto3" json:"Commit,omitempty"`
	Applied           uint64           `protobuf:"varint,7,opt,name=Applied,proto3" json:"Applied,omitempty"`
	Vote              uint64           `protobuf:"varint,8,opt,name=Vote,proto3" json:"Vote,omitempty"`
	PendQueue         int32            `protobuf:"varint,9,opt,name=PendQueue,proto3" json:"PendQueue,omitempty"`
	RecvQueue         int32            `protobuf:"varint,10,opt,name=RecvQueue,proto3" json:"RecvQueue,omitempty"`
	AppQueue          int32            `protobuf:"varint,11,opt,name=AppQueue,proto3" json:"AppQueue,omitempty"`
	Stopped           bool             `protobuf:"varint,12,opt,name=Stopped,proto3" json:"Stopped,omitempty"`
	RestoringSnapshot bool             `protobuf:"varint,13,opt,name=RestoringSnapshot,proto3" json:"RestoringSnapshot,omitempty"`
	State             string           `protobuf:"bytes,14,opt,name=State,proto3" json:"State,omitempty"`
	Replicas          []*ReplicaStatus `protobuf:"bytes,15,rep,name=Replicas" json:"Replicas,omitempty"`
}

func (m *RaftStatus) Reset()                    { *m = RaftStatus{} }
func (m *RaftStatus) String() string            { return proto.CompactTextString(m) }
func (*RaftStatus) ProtoMessage()               {}
func (*RaftStatus) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{17} }

func (m *RaftStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RaftStatus) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *RaftStatus) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *RaftStatus) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RaftStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *RaftStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *RaftStatus) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

func (m *RaftStatus) GetVote() uint64 {
	if m != nil {
		return m.Vote
	}
	return 0
}

func (m *RaftStatus) GetPendQueue() int32 {
	if m != nil {
		return m.PendQueue
	}
	return 0
}

func (m *RaftStatus) GetRecvQueue() int32 {
	if m != nil {
		return m.RecvQueue
	}
	return 0
}

func (m *RaftStatus) GetAppQueue() int32 {
	if m != nil {
		return m.AppQueue
	}
	return 0
}

func (m *RaftStatus) GetStopped() bool {
	if m != nil {
		return m.Stopped
	}
	return false
}

func (m *RaftStatus) GetRestoringSnapshot() bool {
	if m != nil {
		return m.RestoringSnapshot
	}
	return false
}

func (m *RaftStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *RaftStatus) GetReplicas() []*ReplicaStatus {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type SqlStats struct {
	Ops      int64  `protobuf:"varint,1,opt,name=ops,proto3" json:"ops,omitempty"`
	DelayAvg int64  `protobuf:"varint,2,opt,name=delay_avg,json=delayAvg,proto3" json:"delay_avg,omitempty"`
	Tp       []byte `protobuf:"bytes,3,opt,name=tp,proto3" json:"tp,omitempty"`
}

func (m *SqlStats) Reset()                    { *m = SqlStats{} }
func (m *SqlStats) String() string            { return proto.CompactTextString(m) }
func (*SqlStats) ProtoMessage()               {}
func (*SqlStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{18} }

func (m *SqlStats) GetOps() int64 {
	if m != nil {
		return m.Ops
	}
	return 0
}

func (m *SqlStats) GetDelayAvg() int64 {
	if m != nil {
		return m.DelayAvg
	}
	return 0
}

func (m *SqlStats) GetTp() []byte {
	if m != nil {
		return m.Tp
	}
	return nil
}

type SqlSlowlog struct {
	Len  uint32     `protobuf:"varint,1,opt,name=len,proto3" json:"len,omitempty"`
	Than int32      `protobuf:"varint,2,opt,name=than,proto3" json:"than,omitempty"`
	Idx  uint32     `protobuf:"varint,3,opt,name=idx,proto3" json:"idx,omitempty"`
	Log  []*SqlSlow `protobuf:"bytes,4,rep,name=log" json:"log,omitempty"`
}

func (m *SqlSlowlog) Reset()                    { *m = SqlSlowlog{} }
func (m *SqlSlowlog) String() string            { return proto.CompactTextString(m) }
func (*SqlSlowlog) ProtoMessage()               {}
func (*SqlSlowlog) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{19} }

func (m *SqlSlowlog) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *SqlSlowlog) GetThan() int32 {
	if m != nil {
		return m.Than
	}
	return 0
}

func (m *SqlSlowlog) GetIdx() uint32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *SqlSlowlog) GetLog() []*SqlSlow {
	if m != nil {
		return m.Log
	}
	return nil
}

type SqlSlow struct {
	TimeSec   int64  `protobuf:"varint,1,opt,name=time_sec,json=timeSec,proto3" json:"time_sec,omitempty"`
	Sql       string `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	TotalUsec int64  `protobuf:"varint,3,opt,name=total_usec,json=totalUsec,proto3" json:"total_usec,omitempty"`
	CallUsec  int64  `protobuf:"varint,4,opt,name=call_usec,json=callUsec,proto3" json:"call_usec,omitempty"`
}

func (m *SqlSlow) Reset()                    { *m = SqlSlow{} }
func (m *SqlSlow) String() string            { return proto.CompactTextString(m) }
func (*SqlSlow) ProtoMessage()               {}
func (*SqlSlow) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{20} }

func (m *SqlSlow) GetTimeSec() int64 {
	if m != nil {
		return m.TimeSec
	}
	return 0
}

func (m *SqlSlow) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

func (m *SqlSlow) GetTotalUsec() int64 {
	if m != nil {
		return m.TotalUsec
	}
	return 0
}

func (m *SqlSlow) GetCallUsec() int64 {
	if m != nil {
		return m.CallUsec
	}
	return 0
}

type SqlTp struct {
	Calls    int64   `protobuf:"varint,1,opt,name=calls,proto3" json:"calls,omitempty"`
	Tp       []int64 `protobuf:"varint,2,rep,packed,name=tp" json:"tp,omitempty"`
	DelayMax int64   `protobuf:"varint,3,opt,name=delay_max,json=delayMax,proto3" json:"delay_max,omitempty"`
}

func (m *SqlTp) Reset()                    { *m = SqlTp{} }
func (m *SqlTp) String() string            { return proto.CompactTextString(m) }
func (*SqlTp) ProtoMessage()               {}
func (*SqlTp) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{21} }

func (m *SqlTp) GetCalls() int64 {
	if m != nil {
		return m.Calls
	}
	return 0
}

func (m *SqlTp) GetTp() []int64 {
	if m != nil {
		return m.Tp
	}
	return nil
}

func (m *SqlTp) GetDelayMax() int64 {
	if m != nil {
		return m.DelayMax
	}
	return 0
}

func init() {
	proto.RegisterType((*ClusterStats)(nil), "statspb.ClusterStats")
	proto.RegisterType((*DatabaseStats)(nil), "statspb.DatabaseStats")
	proto.RegisterType((*TableStats)(nil), "statspb.TableStats")
	proto.RegisterType((*TaskInfo)(nil), "statspb.TaskInfo")
	proto.RegisterType((*HotSpotStats)(nil), "statspb.HotSpotStats")
	proto.RegisterType((*ScheduleCount)(nil), "statspb.ScheduleCount")
	proto.RegisterType((*DiskStats)(nil), "statspb.DiskStats")
	proto.RegisterType((*NetStats)(nil), "statspb.NetStats")
	proto.RegisterType((*MemStats)(nil), "statspb.MemStats")
	proto.RegisterType((*TpStats)(nil), "statspb.TpStats")
	proto.RegisterType((*SlowLog)(nil), "statspb.SlowLog")
	proto.RegisterType((*SlowLogStats)(nil), "statspb.SlowLogStats")
	proto.RegisterType((*DsInfo)(nil), "statspb.DsInfo")
	proto.RegisterType((*ProcessStats)(nil), "statspb.ProcessStats")
	proto.RegisterType((*MacStats)(nil), "statspb.MacStats")
	proto.RegisterType((*RangeStats)(nil), "statspb.RangeStats")
	proto.RegisterType((*ReplicaStatus)(nil), "statspb.ReplicaStatus")
	proto.RegisterType((*RaftStatus)(nil), "statspb.RaftStatus")
	proto.RegisterType((*SqlStats)(nil), "statspb.SqlStats")
	proto.RegisterType((*SqlSlowlog)(nil), "statspb.SqlSlowlog")
	proto.RegisterType((*SqlSlow)(nil), "statspb.SqlSlow")
	proto.RegisterType((*SqlTp)(nil), "statspb.SqlTp")
	proto.RegisterEnum("statspb.TpArgs", TpArgs_name, TpArgs_value)
}
func (m *ClusterStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CapacityTotal != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.CapacityTotal))
	}
	if m.SizeUsed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SizeUsed))
	}
	if m.RangeNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeNum))
	}
	if m.DbNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DbNum))
	}
	if m.TableNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TableNum))
	}
	if m.TaskNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TaskNum))
	}
	if m.NodeUpCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeUpCount))
	}
	if m.NodeDownCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeDownCount))
	}
	if m.NodeOfflineCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeOfflineCount))
	}
	if m.NodeTombstoneCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeTombstoneCount))
	}
	if m.LeaderBalanceRatio != 0 {
		dAtA[i] = 0x59
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeaderBalanceRatio))))
		i += 8
	}
	if m.RegionBalanceRatio != 0 {
		dAtA[i] = 0x61
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RegionBalanceRatio))))
		i += 8
	}
	return i, nil
}

func (m *DatabaseStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.TableNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TableNum))
	}
	return i, nil
}

func (m *TableStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DbName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if len(m.TableName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if m.RangeNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeNum))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *TaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TaskId))
	}
	if m.RangeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeId))
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Start != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.End))
	}
	if m.UsedTime != 0 {
		dAtA[i] = 0x41
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedTime))))
		i += 8
	}
	if len(m.Describe) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Describe)))
		i += copy(dAtA[i:], m.Describe)
	}
	return i, nil
}

func (m *HotSpotStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotSpotStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.NodeAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.NodeAddr)))
		i += copy(dAtA[i:], m.NodeAddr)
	}
	if m.TotalWrittenBytesAsPeer != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalWrittenBytesAsPeer))))
		i += 8
	}
	if m.HotWriteRegionAsPeer != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.HotWriteRegionAsPeer))
	}
	if m.TotalWrittenBytesAsLeader != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalWrittenBytesAsLeader))))
		i += 8
	}
	if m.HotWriteRegionAsLeader != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.HotWriteRegionAsLeader))
	}
	return i, nil
}

func (m *ScheduleCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DiskStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DiskPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.DiskPath)))
		i += copy(dAtA[i:], m.DiskPath)
	}
	if m.DiskTotal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskTotal))
	}
	if m.DiskUsed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskUsed))
	}
	if m.DiskFree != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskFree))
	}
	if m.DiskProcRate != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskProcRate))))
		i += 8
	}
	if m.DiskReadBytePerSec != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskReadBytePerSec))
	}
	if m.DiskWriteBytePerSec != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskWriteBytePerSec))
	}
	if m.DiskReadCountPerSec != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskReadCountPerSec))
	}
	if m.DiskWriteCountPerSec != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskWriteCountPerSec))
	}
	return i, nil
}

func (m *NetStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetIoInBytePerSec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIoInBytePerSec))
	}
	if m.NetIoOutBytePerSec != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIoOutBytePerSec))
	}
	if m.NetIoInPackagePerSec != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIoInPackagePerSec))
	}
	if m.NetIoOutPackagePerSec != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIoOutPackagePerSec))
	}
	if m.NetTcpConnections != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpConnections))
	}
	if m.NetTcpActiveOpensPerSec != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpActiveOpensPerSec))
	}
	if m.NetIpRecvPackagePerSec != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIpRecvPackagePerSec))
	}
	if m.NetIpSendPackagePerSec != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIpSendPackagePerSec))
	}
	if m.NetIpDropPackagePerSec != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIpDropPackagePerSec))
	}
	if m.NetTcpRecvPackagePerSec != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpRecvPackagePerSec))
	}
	if m.NetTcpSendPackagePerSec != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpSendPackagePerSec))
	}
	if m.NetTcpErrPackagePerSec != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpErrPackagePerSec))
	}
	if m.NetTcpRetransferPackagePerSec != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpRetransferPackagePerSec))
	}
	return i, nil
}

func (m *MemStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryTotal != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryTotal))
	}
	if m.MemoryUsedRss != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryUsedRss))
	}
	if m.MemoryUsed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryUsed))
	}
	if m.MemoryFree != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryFree))
	}
	if m.MemoryUsedPercent != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemoryUsedPercent))))
		i += 8
	}
	if m.SwapMemoryTotal != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SwapMemoryTotal))
	}
	if m.SwapMemoryUsed != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SwapMemoryUsed))
	}
	if m.SwapMemoryFree != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SwapMemoryFree))
	}
	if m.SwapMemoryUsedPercent != 0 {
		dAtA[i] = 0x49
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SwapMemoryUsedPercent))))
		i += 8
	}
	return i, nil
}

func (m *TpStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TpStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Tps))
	}
	if m.Min != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
		i += 8
	}
	if m.Max != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
		i += 8
	}
	if m.Avg != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Avg))))
		i += 8
	}
	if m.Tp_50 != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tp_50))))
		i += 8
	}
	if m.Tp_90 != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tp_90))))
		i += 8
	}
	if m.Tp_99 != 0 {
		dAtA[i] = 0x39
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tp_99))))
		i += 8
	}
	if m.Tp_999 != 0 {
		dAtA[i] = 0x41
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tp_999))))
		i += 8
	}
	if m.TotalNumber != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TotalNumber))
	}
	if m.ErrNumber != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ErrNumber))
	}
	return i, nil
}

func (m *SlowLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlowLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SlowLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.SlowLog)))
		i += copy(dAtA[i:], m.SlowLog)
	}
	if m.Lats != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lats))))
		i += 8
	}
	return i, nil
}

func (m *SlowLogStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlowLogStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SlowLogs) > 0 {
		for _, msg := range m.SlowLogs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeCount))
	}
	if m.RangeSplitCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeSplitCount))
	}
	if m.SendingSnapCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ApplyingSnapCount))
	}
	if m.RangeLeaderCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeLeaderCount))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *ProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuProcRate != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuProcRate))))
		i += 8
	}
	if m.MemoryTotal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryTotal))
	}
	if m.MemoryUsed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryUsed))
	}
	if m.ConnectCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ConnectCount))
	}
	if m.DiskStats != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskStats.Size()))
		n1, err := m.DiskStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TpStats != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TpStats.Size()))
		n2, err := m.TpStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DsInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DsInfo.Size()))
		n3, err := m.DsInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ThreadNum != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ThreadNum))
	}
	if m.HandleNum != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.HandleNum))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.StartTime))
	}
	return i, nil
}

func (m *MacStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuProcRate != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuProcRate))))
		i += 8
	}
	if m.CpuCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.CpuCount))
	}
	if m.Load1 != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Load1))))
		i += 8
	}
	if m.Load5 != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Load5))))
		i += 8
	}
	if m.Load15 != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Load15))))
		i += 8
	}
	if m.MemStats != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemStats.Size()))
		n4, err := m.MemStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.NetStats != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetStats.Size()))
		n5, err := m.NetStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.DiskStats) > 0 {
		for _, msg := range m.DiskStats {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStatspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ProcessNum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ProcessNum))
	}
	if m.ThreadNum != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ThreadNum))
	}
	if m.HandleNum != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.HandleNum))
	}
	return i, nil
}

func (m *RangeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Size_))
	}
	if m.Ops != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Ops))
	}
	if m.BytesInPerSec != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.BytesInPerSec))
	}
	if m.BytesOutPerSec != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.BytesOutPerSec))
	}
	if m.TotalCommandsProcessed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TotalCommandsProcessed))
	}
	if m.KeyspaceMisses != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.KeyspaceMisses))
	}
	return i, nil
}

func (m *ReplicaStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Match))
	}
	if m.Commit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Commit))
	}
	if m.Next != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Next))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Snapshoting {
		dAtA[i] = 0x28
		i++
		if m.Snapshoting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Paused {
		dAtA[i] = 0x30
		i++
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Active {
		dAtA[i] = 0x38
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastActive != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.LastActive))
	}
	if m.Inflight != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Inflight))
	}
	if m.ID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *RaftStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ID))
	}
	if m.NodeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeID))
	}
	if m.Leader != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Leader))
	}
	if m.Term != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Term))
	}
	if m.Index != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Index))
	}
	if m.Commit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Commit))
	}
	if m.Applied != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Applied))
	}
	if m.Vote != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Vote))
	}
	if m.PendQueue != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.PendQueue))
	}
	if m.RecvQueue != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RecvQueue))
	}
	if m.AppQueue != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.AppQueue))
	}
	if m.Stopped {
		dAtA[i] = 0x60
		i++
		if m.Stopped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RestoringSnapshot {
		dAtA[i] = 0x68
		i++
		if m.RestoringSnapshot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Replicas) > 0 {
		for _, msg := range m.Replicas {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintStatspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SqlStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ops != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Ops))
	}
	if m.DelayAvg != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DelayAvg))
	}
	if len(m.Tp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Tp)))
		i += copy(dAtA[i:], m.Tp)
	}
	return i, nil
}

func (m *SqlSlowlog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlSlowlog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Len != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Len))
	}
	if m.Than != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Than))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Idx))
	}
	if len(m.Log) > 0 {
		for _, msg := range m.Log {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStatspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SqlSlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlSlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeSec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TimeSec))
	}
	if len(m.Sql) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Sql)))
		i += copy(dAtA[i:], m.Sql)
	}
	if m.TotalUsec != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TotalUsec))
	}
	if m.CallUsec != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.CallUsec))
	}
	return i, nil
}

func (m *SqlTp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlTp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Calls != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Calls))
	}
	if len(m.Tp) > 0 {
		dAtA7 := make([]byte, len(m.Tp)*10)
		var j6 int
		for _, num1 := range m.Tp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.DelayMax != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DelayMax))
	}
	return i, nil
}

func encodeVarintStatspb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClusterStats) Size() (n int) {
	var l int
	_ = l
	if m.CapacityTotal != 0 {
		n += 1 + sovStatspb(uint64(m.CapacityTotal))
	}
	if m.SizeUsed != 0 {
		n += 1 + sovStatspb(uint64(m.SizeUsed))
	}
	if m.RangeNum != 0 {
		n += 1 + sovStatspb(uint64(m.RangeNum))
	}
	if m.DbNum != 0 {
		n += 1 + sovStatspb(uint64(m.DbNum))
	}
	if m.TableNum != 0 {
		n += 1 + sovStatspb(uint64(m.TableNum))
	}
	if m.TaskNum != 0 {
		n += 1 + sovStatspb(uint64(m.TaskNum))
	}
	if m.NodeUpCount != 0 {
		n += 1 + sovStatspb(uint64(m.NodeUpCount))
	}
	if m.NodeDownCount != 0 {
		n += 1 + sovStatspb(uint64(m.NodeDownCount))
	}
	if m.NodeOfflineCount != 0 {
		n += 1 + sovStatspb(uint64(m.NodeOfflineCount))
	}
	if m.NodeTombstoneCount != 0 {
		n += 1 + sovStatspb(uint64(m.NodeTombstoneCount))
	}
	if m.LeaderBalanceRatio != 0 {
		n += 9
	}
	if m.RegionBalanceRatio != 0 {
		n += 9
	}
	return n
}

func (m *DatabaseStats) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.TableNum != 0 {
		n += 1 + sovStatspb(uint64(m.TableNum))
	}
	return n
}

func (m *TableStats) Size() (n int) {
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.RangeNum != 0 {
		n += 1 + sovStatspb(uint64(m.RangeNum))
	}
	if m.Size_ != 0 {
		n += 1 + sovStatspb(uint64(m.Size_))
	}
	return n
}

func (m *TaskInfo) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovStatspb(uint64(m.TaskId))
	}
	if m.RangeId != 0 {
		n += 1 + sovStatspb(uint64(m.RangeId))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovStatspb(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovStatspb(uint64(m.End))
	}
	if m.UsedTime != 0 {
		n += 9
	}
	l = len(m.Describe)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	return n
}

func (m *HotSpotStats) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovStatspb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.TotalWrittenBytesAsPeer != 0 {
		n += 9
	}
	if m.HotWriteRegionAsPeer != 0 {
		n += 1 + sovStatspb(uint64(m.HotWriteRegionAsPeer))
	}
	if m.TotalWrittenBytesAsLeader != 0 {
		n += 9
	}
	if m.HotWriteRegionAsLeader != 0 {
		n += 1 + sovStatspb(uint64(m.HotWriteRegionAsLeader))
	}
	return n
}

func (m *ScheduleCount) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovStatspb(uint64(m.Count))
	}
	return n
}

func (m *DiskStats) Size() (n int) {
	var l int
	_ = l
	l = len(m.DiskPath)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.DiskTotal != 0 {
		n += 1 + sovStatspb(uint64(m.DiskTotal))
	}
	if m.DiskUsed != 0 {
		n += 1 + sovStatspb(uint64(m.DiskUsed))
	}
	if m.DiskFree != 0 {
		n += 1 + sovStatspb(uint64(m.DiskFree))
	}
	if m.DiskProcRate != 0 {
		n += 9
	}
	if m.DiskReadBytePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.DiskReadBytePerSec))
	}
	if m.DiskWriteBytePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.DiskWriteBytePerSec))
	}
	if m.DiskReadCountPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.DiskReadCountPerSec))
	}
	if m.DiskWriteCountPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.DiskWriteCountPerSec))
	}
	return n
}

func (m *NetStats) Size() (n int) {
	var l int
	_ = l
	if m.NetIoInBytePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIoInBytePerSec))
	}
	if m.NetIoOutBytePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIoOutBytePerSec))
	}
	if m.NetIoInPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIoInPackagePerSec))
	}
	if m.NetIoOutPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIoOutPackagePerSec))
	}
	if m.NetTcpConnections != 0 {
		n += 1 + sovStatspb(uint64(m.NetTcpConnections))
	}
	if m.NetTcpActiveOpensPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetTcpActiveOpensPerSec))
	}
	if m.NetIpRecvPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIpRecvPackagePerSec))
	}
	if m.NetIpSendPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIpSendPackagePerSec))
	}
	if m.NetIpDropPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetIpDropPackagePerSec))
	}
	if m.NetTcpRecvPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetTcpRecvPackagePerSec))
	}
	if m.NetTcpSendPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetTcpSendPackagePerSec))
	}
	if m.NetTcpErrPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetTcpErrPackagePerSec))
	}
	if m.NetTcpRetransferPackagePerSec != 0 {
		n += 1 + sovStatspb(uint64(m.NetTcpRetransferPackagePerSec))
	}
	return n
}

func (m *MemStats) Size() (n int) {
	var l int
	_ = l
	if m.MemoryTotal != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryTotal))
	}
	if m.MemoryUsedRss != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryUsedRss))
	}
	if m.MemoryUsed != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryUsed))
	}
	if m.MemoryFree != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryFree))
	}
	if m.MemoryUsedPercent != 0 {
		n += 9
	}
	if m.SwapMemoryTotal != 0 {
		n += 1 + sovStatspb(uint64(m.SwapMemoryTotal))
	}
	if m.SwapMemoryUsed != 0 {
		n += 1 + sovStatspb(uint64(m.SwapMemoryUsed))
	}
	if m.SwapMemoryFree != 0 {
		n += 1 + sovStatspb(uint64(m.SwapMemoryFree))
	}
	if m.SwapMemoryUsedPercent != 0 {
		n += 9
	}
	return n
}

func (m *TpStats) Size() (n int) {
	var l int
	_ = l
	if m.Tps != 0 {
		n += 1 + sovStatspb(uint64(m.Tps))
	}
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	if m.Avg != 0 {
		n += 9
	}
	if m.Tp_50 != 0 {
		n += 9
	}
	if m.Tp_90 != 0 {
		n += 9
	}
	if m.Tp_99 != 0 {
		n += 9
	}
	if m.Tp_999 != 0 {
		n += 9
	}
	if m.TotalNumber != 0 {
		n += 1 + sovStatspb(uint64(m.TotalNumber))
	}
	if m.ErrNumber != 0 {
		n += 1 + sovStatspb(uint64(m.ErrNumber))
	}
	return n
}

func (m *SlowLog) Size() (n int) {
	var l int
	_ = l
	l = len(m.SlowLog)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.Lats != 0 {
		n += 9
	}
	return n
}

func (m *SlowLogStats) Size() (n int) {
	var l int
	_ = l
	if len(m.SlowLogs) > 0 {
		for _, e := range m.SlowLogs {
			l = e.Size()
			n += 1 + l + sovStatspb(uint64(l))
		}
	}
	return n
}

func (m *DsInfo) Size() (n int) {
	var l int
	_ = l
	if m.RangeCount != 0 {
		n += 1 + sovStatspb(uint64(m.RangeCount))
	}
	if m.RangeSplitCount != 0 {
		n += 1 + sovStatspb(uint64(m.RangeSplitCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovStatspb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 1 + sovStatspb(uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovStatspb(uint64(m.ApplyingSnapCount))
	}
	if m.RangeLeaderCount != 0 {
		n += 1 + sovStatspb(uint64(m.RangeLeaderCount))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	return n
}

func (m *ProcessStats) Size() (n int) {
	var l int
	_ = l
	if m.CpuProcRate != 0 {
		n += 9
	}
	if m.MemoryTotal != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryTotal))
	}
	if m.MemoryUsed != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryUsed))
	}
	if m.ConnectCount != 0 {
		n += 1 + sovStatspb(uint64(m.ConnectCount))
	}
	if m.DiskStats != nil {
		l = m.DiskStats.Size()
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.TpStats != nil {
		l = m.TpStats.Size()
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.DsInfo != nil {
		l = m.DsInfo.Size()
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.ThreadNum != 0 {
		n += 1 + sovStatspb(uint64(m.ThreadNum))
	}
	if m.HandleNum != 0 {
		n += 1 + sovStatspb(uint64(m.HandleNum))
	}
	if m.StartTime != 0 {
		n += 1 + sovStatspb(uint64(m.StartTime))
	}
	return n
}

func (m *MacStats) Size() (n int) {
	var l int
	_ = l
	if m.CpuProcRate != 0 {
		n += 9
	}
	if m.CpuCount != 0 {
		n += 1 + sovStatspb(uint64(m.CpuCount))
	}
	if m.Load1 != 0 {
		n += 9
	}
	if m.Load5 != 0 {
		n += 9
	}
	if m.Load15 != 0 {
		n += 9
	}
	if m.MemStats != nil {
		l = m.MemStats.Size()
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.NetStats != nil {
		l = m.NetStats.Size()
		n += 1 + l + sovStatspb(uint64(l))
	}
	if len(m.DiskStats) > 0 {
		for _, e := range m.DiskStats {
			l = e.Size()
			n += 1 + l + sovStatspb(uint64(l))
		}
	}
	if m.ProcessNum != 0 {
		n += 1 + sovStatspb(uint64(m.ProcessNum))
	}
	if m.ThreadNum != 0 {
		n += 1 + sovStatspb(uint64(m.ThreadNum))
	}
	if m.HandleNum != 0 {
		n += 1 + sovStatspb(uint64(m.HandleNum))
	}
	return n
}

func (m *RangeStats) Size() (n int) {
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovStatspb(uint64(m.Size_))
	}
	if m.Ops != 0 {
		n += 1 + sovStatspb(uint64(m.Ops))
	}
	if m.BytesInPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.BytesInPerSec))
	}
	if m.BytesOutPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.BytesOutPerSec))
	}
	if m.TotalCommandsProcessed != 0 {
		n += 1 + sovStatspb(uint64(m.TotalCommandsProcessed))
	}
	if m.KeyspaceMisses != 0 {
		n += 1 + sovStatspb(uint64(m.KeyspaceMisses))
	}
	return n
}

func (m *ReplicaStatus) Size() (n int) {
	var l int
	_ = l
	if m.Match != 0 {
		n += 1 + sovStatspb(uint64(m.Match))
	}
	if m.Commit != 0 {
		n += 1 + sovStatspb(uint64(m.Commit))
	}
	if m.Next != 0 {
		n += 1 + sovStatspb(uint64(m.Next))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.Snapshoting {
		n += 2
	}
	if m.Paused {
		n += 2
	}
	if m.Active {
		n += 2
	}
	if m.LastActive != 0 {
		n += 1 + sovStatspb(uint64(m.LastActive))
	}
	if m.Inflight != 0 {
		n += 1 + sovStatspb(uint64(m.Inflight))
	}
	if m.ID != 0 {
		n += 1 + sovStatspb(uint64(m.ID))
	}
	return n
}

func (m *RaftStatus) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovStatspb(uint64(m.ID))
	}
	if m.NodeID != 0 {
		n += 1 + sovStatspb(uint64(m.NodeID))
	}
	if m.Leader != 0 {
		n += 1 + sovStatspb(uint64(m.Leader))
	}
	if m.Term != 0 {
		n += 1 + sovStatspb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovStatspb(uint64(m.Index))
	}
	if m.Commit != 0 {
		n += 1 + sovStatspb(uint64(m.Commit))
	}
	if m.Applied != 0 {
		n += 1 + sovStatspb(uint64(m.Applied))
	}
	if m.Vote != 0 {
		n += 1 + sovStatspb(uint64(m.Vote))
	}
	if m.PendQueue != 0 {
		n += 1 + sovStatspb(uint64(m.PendQueue))
	}
	if m.RecvQueue != 0 {
		n += 1 + sovStatspb(uint64(m.RecvQueue))
	}
	if m.AppQueue != 0 {
		n += 1 + sovStatspb(uint64(m.AppQueue))
	}
	if m.Stopped {
		n += 2
	}
	if m.RestoringSnapshot {
		n += 2
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovStatspb(uint64(l))
		}
	}
	return n
}

func (m *SqlStats) Size() (n int) {
	var l int
	_ = l
	if m.Ops != 0 {
		n += 1 + sovStatspb(uint64(m.Ops))
	}
	if m.DelayAvg != 0 {
		n += 1 + sovStatspb(uint64(m.DelayAvg))
	}
	l = len(m.Tp)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	return n
}

func (m *SqlSlowlog) Size() (n int) {
	var l int
	_ = l
	if m.Len != 0 {
		n += 1 + sovStatspb(uint64(m.Len))
	}
	if m.Than != 0 {
		n += 1 + sovStatspb(uint64(m.Than))
	}
	if m.Idx != 0 {
		n += 1 + sovStatspb(uint64(m.Idx))
	}
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovStatspb(uint64(l))
		}
	}
	return n
}

func (m *SqlSlow) Size() (n int) {
	var l int
	_ = l
	if m.TimeSec != 0 {
		n += 1 + sovStatspb(uint64(m.TimeSec))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.TotalUsec != 0 {
		n += 1 + sovStatspb(uint64(m.TotalUsec))
	}
	if m.CallUsec != 0 {
		n += 1 + sovStatspb(uint64(m.CallUsec))
	}
	return n
}

func (m *SqlTp) Size() (n int) {
	var l int
	_ = l
	if m.Calls != 0 {
		n += 1 + sovStatspb(uint64(m.Calls))
	}
	if len(m.Tp) > 0 {
		l = 0
		for _, e := range m.Tp {
			l += sovStatspb(uint64(e))
		}
		n += 1 + sovStatspb(uint64(l)) + l
	}
	if m.DelayMax != 0 {
		n += 1 + sovStatspb(uint64(m.DelayMax))
	}
	return n
}

func sovStatspb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStatspb(x uint64) (n int) {
	return sovStatspb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityTotal", wireType)
			}
			m.CapacityTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapacityTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeUsed", wireType)
			}
			m.SizeUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeNum", wireType)
			}
			m.RangeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeNum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbNum", wireType)
			}
			m.DbNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbNum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNum", wireType)
			}
			m.TableNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableNum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskNum", wireType)
			}
			m.TaskNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskNum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUpCount", wireType)
			}
			m.NodeUpCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeUpCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDownCount", wireType)
			}
			m.NodeDownCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeDownCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOfflineCount", wireType)
			}
			m.NodeOfflineCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeOfflineCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeTombstoneCount", wireType)
			}
			m.NodeTombstoneCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeTombstoneCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderBalanceRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeaderBalanceRatio = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionBalanceRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RegionBalanceRatio = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNum", wireType)
			}
			m.TableNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeNum", wireType)
			}
			m.RangeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeNum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedTime = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Describe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Describe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotSpotStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotSpotStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotSpotStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWrittenBytesAsPeer", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalWrittenBytesAsPeer = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotWriteRegionAsPeer", wireType)
			}
			m.HotWriteRegionAsPeer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HotWriteRegionAsPeer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWrittenBytesAsLeader", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalWrittenBytesAsLeader = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotWriteRegionAsLeader", wireType)
			}
			m.HotWriteRegionAsLeader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HotWriteRegionAsLeader |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskTotal", wireType)
			}
			m.DiskTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsed", wireType)
			}
			m.DiskUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFree", wireType)
			}
			m.DiskFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskProcRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskProcRate = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskReadBytePerSec", wireType)
			}
			m.DiskReadBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskReadBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskWriteBytePerSec", wireType)
			}
			m.DiskWriteBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskWriteBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskReadCountPerSec", wireType)
			}
			m.DiskReadCountPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskReadCountPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskWriteCountPerSec", wireType)
			}
			m.DiskWriteCountPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskWriteCountPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIoInBytePerSec", wireType)
			}
			m.NetIoInBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIoInBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIoOutBytePerSec", wireType)
			}
			m.NetIoOutBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIoOutBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIoInPackagePerSec", wireType)
			}
			m.NetIoInPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIoInPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIoOutPackagePerSec", wireType)
			}
			m.NetIoOutPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIoOutPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpConnections", wireType)
			}
			m.NetTcpConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpConnections |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpActiveOpensPerSec", wireType)
			}
			m.NetTcpActiveOpensPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpActiveOpensPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIpRecvPackagePerSec", wireType)
			}
			m.NetIpRecvPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIpRecvPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIpSendPackagePerSec", wireType)
			}
			m.NetIpSendPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIpSendPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIpDropPackagePerSec", wireType)
			}
			m.NetIpDropPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIpDropPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpRecvPackagePerSec", wireType)
			}
			m.NetTcpRecvPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpRecvPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpSendPackagePerSec", wireType)
			}
			m.NetTcpSendPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpSendPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpErrPackagePerSec", wireType)
			}
			m.NetTcpErrPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpErrPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpRetransferPackagePerSec", wireType)
			}
			m.NetTcpRetransferPackagePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpRetransferPackagePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryTotal", wireType)
			}
			m.MemoryTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsedRss", wireType)
			}
			m.MemoryUsedRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsedRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsed", wireType)
			}
			m.MemoryUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryFree", wireType)
			}
			m.MemoryFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemoryUsedPercent = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryTotal", wireType)
			}
			m.SwapMemoryTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapMemoryTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryUsed", wireType)
			}
			m.SwapMemoryUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapMemoryUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryFree", wireType)
			}
			m.SwapMemoryFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapMemoryFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryUsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SwapMemoryUsedPercent = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TpStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TpStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TpStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tps", wireType)
			}
			m.Tps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tps |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avg", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Avg = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp_50", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tp_50 = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp_90", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tp_90 = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp_99", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tp_99 = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp_999", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tp_999 = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNumber", wireType)
			}
			m.TotalNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNumber", wireType)
			}
			m.ErrNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlowLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlowLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlowLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlowLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lats", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lats = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlowLogStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlowLogStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlowLogStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowLogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlowLogs = append(m.SlowLogs, &SlowLog{})
			if err := m.SlowLogs[len(m.SlowLogs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSplitCount", wireType)
			}
			m.RangeSplitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeSplitCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLeaderCount", wireType)
			}
			m.RangeLeaderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeLeaderCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuProcRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuProcRate = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryTotal", wireType)
			}
			m.MemoryTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsed", wireType)
			}
			m.MemoryUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectCount", wireType)
			}
			m.ConnectCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiskStats == nil {
				m.DiskStats = &DiskStats{}
			}
			if err := m.DiskStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TpStats == nil {
				m.TpStats = &TpStats{}
			}
			if err := m.TpStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DsInfo == nil {
				m.DsInfo = &DsInfo{}
			}
			if err := m.DsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadNum", wireType)
			}
			m.ThreadNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandleNum", wireType)
			}
			m.HandleNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandleNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuProcRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuProcRate = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Load1 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load5", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Load5 = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load15", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Load15 = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemStats == nil {
				m.MemStats = &MemStats{}
			}
			if err := m.MemStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetStats == nil {
				m.NetStats = &NetStats{}
			}
			if err := m.NetStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskStats = append(m.DiskStats, &DiskStats{})
			if err := m.DiskStats[len(m.DiskStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessNum", wireType)
			}
			m.ProcessNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadNum", wireType)
			}
			m.ThreadNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandleNum", wireType)
			}
			m.HandleNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandleNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesInPerSec", wireType)
			}
			m.BytesInPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesInPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOutPerSec", wireType)
			}
			m.BytesOutPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesOutPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCommandsProcessed", wireType)
			}
			m.TotalCommandsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCommandsProcessed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceMisses", wireType)
			}
			m.KeyspaceMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceMisses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			m.Match = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Match |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			m.Next = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Next |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshoting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshoting = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActive", wireType)
			}
			m.LastActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastActive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inflight", wireType)
			}
			m.Inflight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inflight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendQueue", wireType)
			}
			m.PendQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvQueue", wireType)
			}
			m.RecvQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppQueue", wireType)
			}
			m.AppQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stopped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stopped = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoringSnapshot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestoringSnapshot = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &ReplicaStatus{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayAvg", wireType)
			}
			m.DelayAvg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayAvg |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tp = append(m.Tp[:0], dAtA[iNdEx:postIndex]...)
			if m.Tp == nil {
				m.Tp = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlSlowlog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlSlowlog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlSlowlog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Than", wireType)
			}
			m.Than = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Than |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &SqlSlow{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlSlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlSlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlSlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSec", wireType)
			}
			m.TimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsec", wireType)
			}
			m.TotalUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallUsec", wireType)
			}
			m.CallUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallUsec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlTp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlTp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlTp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calls", wireType)
			}
			m.Calls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Calls |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tp = append(m.Tp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatspb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatspb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tp = append(m.Tp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayMax", wireType)
			}
			m.DelayMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatspb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStatspb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStatspb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStatspb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStatspb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatspb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("statspb.proto", fileDescriptorStatspb) }

var fileDescriptorStatspb = []byte{
	// 2366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0x5f, 0x73, 0x1b, 0x49,
	0x11, 0x3f, 0x49, 0xb6, 0xb4, 0xdb, 0xb2, 0xfc, 0x67, 0xe3, 0x73, 0x74, 0xf1, 0x25, 0x17, 0x16,
	0xb8, 0x33, 0xc7, 0x61, 0x92, 0x1c, 0xb9, 0x3b, 0x03, 0x57, 0x75, 0x4e, 0xcc, 0x15, 0xa2, 0x12,
	0xc7, 0xac, 0x1c, 0x78, 0xdc, 0x1a, 0xed, 0x8e, 0xa5, 0x2d, 0xaf, 0x76, 0x27, 0x3b, 0x23, 0x3b,
	0xe1, 0x09, 0xa8, 0xe2, 0x0b, 0xf0, 0xc4, 0x07, 0x00, 0xde, 0x78, 0xe7, 0x23, 0xf0, 0x44, 0xf1,
	0x05, 0xa8, 0xa2, 0xc2, 0x0b, 0x7c, 0x0a, 0xa8, 0xee, 0x9e, 0x5d, 0xad, 0x64, 0x87, 0xe3, 0x6d,
	0xba, 0x7f, 0xfd, 0x9b, 0x3f, 0xdd, 0x3d, 0x3d, 0xbd, 0x0b, 0x3d, 0x6d, 0x84, 0xd1, 0x6a, 0xb4,
	0xaf, 0x8a, 0xdc, 0xe4, 0x5e, 0xc7, 0x8a, 0xb7, 0xb6, 0xc7, 0xf9, 0x38, 0x27, 0xdd, 0x77, 0x71,
	0xc4, 0xb0, 0xff, 0xd7, 0x16, 0xac, 0x3d, 0x4e, 0x67, 0xda, 0xc8, 0x62, 0x88, 0x86, 0xde, 0x37,
	0x61, 0x3d, 0x12, 0x4a, 0x44, 0x89, 0x79, 0x15, 0x9a, 0xdc, 0x88, 0xb4, 0xdf, 0xb8, 0xdb, 0xd8,
	0x5b, 0x09, 0x7a, 0xa5, 0xf6, 0x14, 0x95, 0xde, 0x2e, 0xb8, 0x3a, 0xf9, 0x85, 0x0c, 0x67, 0x5a,
	0xc6, 0xfd, 0x26, 0x59, 0x38, 0xa8, 0x78, 0xae, 0x65, 0x8c, 0x60, 0x21, 0xb2, 0xb1, 0x0c, 0xb3,
	0xd9, 0xb4, 0xdf, 0x62, 0x90, 0x14, 0xc7, 0xb3, 0xa9, 0xf7, 0x36, 0xb4, 0xe3, 0x11, 0x21, 0x2b,
	0x84, 0xac, 0xc6, 0x23, 0x54, 0xef, 0x82, 0x6b, 0xc4, 0x28, 0x65, 0xce, 0x2a, 0x73, 0x48, 0x81,
	0xe0, 0x3b, 0xe0, 0x18, 0xa1, 0xcf, 0x09, 0x6b, 0x13, 0xd6, 0x41, 0x19, 0x21, 0x1f, 0x7a, 0x59,
	0x1e, 0xcb, 0x70, 0xa6, 0xc2, 0x28, 0x9f, 0x65, 0xa6, 0xdf, 0x21, 0xbc, 0x8b, 0xca, 0xe7, 0xea,
	0x31, 0xaa, 0xbc, 0xf7, 0x61, 0x83, 0x6c, 0xe2, 0xfc, 0x32, 0xb3, 0x56, 0x0e, 0x1f, 0x0a, 0xd5,
	0x47, 0xf9, 0x65, 0xc6, 0x76, 0x1f, 0x81, 0x47, 0x76, 0xf9, 0xd9, 0x59, 0x9a, 0x64, 0xd2, 0x9a,
	0xba, 0x64, 0xba, 0x89, 0xc8, 0x33, 0x06, 0xd8, 0xfa, 0x1e, 0x6c, 0x93, 0xb5, 0xc9, 0xa7, 0x23,
	0x6d, 0xf2, 0xca, 0x1e, 0xc8, 0x9e, 0x66, 0x3a, 0x2d, 0xa1, 0x8a, 0x91, 0x4a, 0x11, 0xcb, 0x22,
	0x1c, 0x89, 0x54, 0x64, 0x91, 0x0c, 0x0b, 0x61, 0x92, 0xbc, 0xdf, 0xbd, 0xdb, 0xd8, 0x6b, 0x04,
	0x1e, 0x63, 0x8f, 0x18, 0x0a, 0x10, 0x41, 0x46, 0x21, 0xc7, 0x49, 0x9e, 0x2d, 0x31, 0xd6, 0x98,
	0xc1, 0x58, 0x9d, 0xe1, 0x7f, 0x01, 0xbd, 0x23, 0x61, 0xc4, 0x48, 0x68, 0xc9, 0x01, 0xf5, 0x60,
	0x25, 0x13, 0x53, 0x49, 0x61, 0x74, 0x03, 0x1a, 0x2f, 0x3a, 0x1b, 0xa3, 0xd7, 0x9b, 0x3b, 0xdb,
	0x9f, 0x01, 0x9c, 0xe2, 0x98, 0xe9, 0x37, 0xa1, 0x83, 0xe1, 0x9a, 0xcf, 0xd0, 0x8e, 0x47, 0xc7,
	0x38, 0xc7, 0x6d, 0x00, 0x3b, 0x07, 0x62, 0x4d, 0xc2, 0x78, 0xd6, 0x63, 0xbb, 0xc4, 0x9b, 0x73,
	0xc0, 0x83, 0x15, 0x4c, 0x16, 0x9b, 0x01, 0x34, 0xf6, 0xff, 0xde, 0x00, 0xe7, 0x54, 0xe8, 0xf3,
	0x41, 0x76, 0x96, 0xe3, 0xaa, 0x14, 0xf0, 0x24, 0xb6, 0xe9, 0xd7, 0x46, 0x71, 0x10, 0x63, 0x26,
	0xf0, 0xb4, 0x49, 0x99, 0x76, 0x1d, 0x92, 0x07, 0x31, 0x4e, 0x7a, 0x9e, 0x64, 0x31, 0x2d, 0xe6,
	0x06, 0x34, 0xae, 0x0e, 0xbf, 0x52, 0x3b, 0xfc, 0x36, 0xac, 0xe2, 0x9d, 0x90, 0x94, 0x65, 0x6e,
	0xc0, 0x82, 0xd5, 0x16, 0x86, 0xf2, 0xab, 0x15, 0xb0, 0xe0, 0x6d, 0x42, 0x4b, 0x66, 0x31, 0xe5,
	0x54, 0x2b, 0xc0, 0x21, 0x9e, 0x0b, 0x73, 0x3e, 0x34, 0xc9, 0x54, 0x52, 0x16, 0x35, 0x02, 0x07,
	0x15, 0xa7, 0xc9, 0x54, 0x7a, 0xb7, 0xc0, 0x89, 0xa5, 0x8e, 0x8a, 0x64, 0x24, 0x29, 0x6d, 0xdc,
	0xa0, 0x92, 0xfd, 0x3f, 0x37, 0x61, 0xed, 0xc7, 0xb9, 0x19, 0xaa, 0xdc, 0x54, 0x9e, 0xa5, 0xfc,
	0x99, 0x9f, 0x11, 0xc5, 0x01, 0x2d, 0x41, 0x80, 0x88, 0xe3, 0xc2, 0x3a, 0xd6, 0x41, 0xc5, 0x61,
	0x1c, 0x17, 0xde, 0x0f, 0x61, 0x97, 0xae, 0x65, 0x78, 0x59, 0x24, 0xc6, 0xc8, 0x2c, 0x1c, 0xbd,
	0x32, 0x52, 0x87, 0x42, 0x87, 0x4a, 0xca, 0x82, 0x0e, 0xdf, 0x08, 0x6e, 0x92, 0xc9, 0xcf, 0xd9,
	0xe2, 0x11, 0x1a, 0x1c, 0xea, 0x13, 0x29, 0x0b, 0xef, 0x13, 0xe8, 0x4f, 0x72, 0x43, 0x5c, 0x19,
	0xda, 0xcc, 0x2a, 0xa9, 0x1c, 0x8c, 0xed, 0x49, 0x6e, 0x90, 0x28, 0x03, 0x42, 0x2d, 0xef, 0x0b,
	0xb8, 0xfd, 0x86, 0x55, 0x39, 0x69, 0xc9, 0x97, 0x8d, 0xe0, 0x9d, 0x6b, 0xd6, 0x7d, 0x42, 0x06,
	0xde, 0xf7, 0xe1, 0xd6, 0x75, 0x2b, 0x5b, 0x3a, 0x5f, 0xea, 0x9d, 0xe5, 0xb5, 0x99, 0xeb, 0x3f,
	0x83, 0xde, 0x30, 0x9a, 0xc8, 0x78, 0x96, 0xda, 0x8b, 0x74, 0x5d, 0x4e, 0x6f, 0xc3, 0x6a, 0x2a,
	0x46, 0x32, 0xb5, 0x1e, 0x63, 0x01, 0xb5, 0x7c, 0x2b, 0x39, 0x05, 0x59, 0xf0, 0xff, 0xd3, 0x04,
	0xf7, 0x28, 0xd1, 0xe7, 0x1c, 0x88, 0x5d, 0x70, 0xe3, 0x44, 0x9f, 0x87, 0x4a, 0x98, 0x89, 0x9d,
	0xd2, 0x41, 0xc5, 0x89, 0x30, 0x13, 0x4c, 0x73, 0x02, 0xb9, 0x16, 0x72, 0xca, 0x91, 0x79, 0x55,
	0x07, 0x09, 0xa6, 0x3a, 0x68, 0xd3, 0x1c, 0x15, 0x65, 0x1d, 0x24, 0xf0, 0xac, 0x90, 0x65, 0xae,
	0x13, 0xf8, 0x65, 0x21, 0xa5, 0xf7, 0x0d, 0x58, 0xe7, 0x55, 0x8b, 0x3c, 0xc2, 0x5b, 0x2d, 0xad,
	0x0f, 0xd7, 0x68, 0xe9, 0x22, 0x8f, 0x02, 0x4c, 0xcb, 0x07, 0xb0, 0x43, 0x56, 0x85, 0x14, 0x31,
	0x39, 0x3d, 0x54, 0xb2, 0x08, 0xb5, 0x8c, 0xac, 0xcb, 0x3c, 0x44, 0x03, 0x29, 0x62, 0xf4, 0xf6,
	0x89, 0x2c, 0x86, 0x32, 0xf2, 0xbe, 0x07, 0x37, 0x89, 0xc3, 0xbe, 0x5e, 0x20, 0x71, 0x71, 0xbc,
	0x81, 0x30, 0x39, 0xfa, 0x1a, 0x16, 0xad, 0x44, 0x6e, 0xaa, 0x58, 0xce, 0x9c, 0x85, 0x4b, 0x51,
	0x0c, 0x2c, 0xeb, 0x13, 0xe8, 0xd7, 0xd6, 0x5a, 0xa4, 0x71, 0xe1, 0xdc, 0xae, 0x16, 0xab, 0xf1,
	0xfc, 0xdf, 0xb6, 0xc1, 0x39, 0x96, 0xf6, 0x26, 0xdc, 0x87, 0x9d, 0x4c, 0x9a, 0x30, 0xc9, 0xc3,
	0x24, 0x5b, 0xdc, 0x2f, 0x5f, 0x8c, 0xad, 0x4c, 0x9a, 0x41, 0x3e, 0xc8, 0x6a, 0xbb, 0xfd, 0x18,
	0x6e, 0x5a, 0x4a, 0x3e, 0x33, 0x8b, 0x9c, 0xa6, 0xad, 0xbf, 0xc8, 0x79, 0x36, 0x33, 0x35, 0xd2,
	0xa7, 0xf0, 0xce, 0x7c, 0x1d, 0x25, 0xa2, 0x73, 0x31, 0x9e, 0xd3, 0x38, 0x78, 0xdb, 0x76, 0xa9,
	0x13, 0x46, 0x2d, 0xf1, 0x00, 0x6e, 0xd5, 0x56, 0x5b, 0x66, 0x72, 0x64, 0xdf, 0x2e, 0x17, 0x5c,
	0xa4, 0xee, 0xc3, 0x0d, 0xa4, 0x9a, 0x08, 0xdf, 0xa7, 0x2c, 0x93, 0x91, 0x49, 0xf2, 0x4c, 0x53,
	0xac, 0x7b, 0x74, 0xb0, 0xd3, 0x48, 0x3d, 0x9e, 0x03, 0xde, 0xe7, 0xf0, 0x6e, 0x69, 0x2f, 0x22,
	0x93, 0x5c, 0xc8, 0x30, 0x57, 0x32, 0xd3, 0x4b, 0x61, 0xbf, 0xc9, 0xc4, 0x43, 0xb2, 0x78, 0x86,
	0x06, 0x76, 0xb9, 0x1f, 0xc0, 0x2e, 0xed, 0x54, 0x85, 0x85, 0x8c, 0x2e, 0xae, 0x6c, 0x95, 0xe3,
	0x8f, 0xde, 0x1e, 0xa8, 0x40, 0x46, 0x17, 0x8b, 0x7b, 0x9d, 0x93, 0xb5, 0xcc, 0xe2, 0x2b, 0x64,
	0xa7, 0x46, 0x1e, 0xca, 0x2c, 0x7e, 0x13, 0x39, 0x2e, 0x72, 0x75, 0x85, 0xec, 0xd6, 0xc8, 0x47,
	0x45, 0xae, 0x16, 0xc9, 0xb5, 0x53, 0x5f, 0xbb, 0x6f, 0xa8, 0x9f, 0xfa, 0xea, 0xc6, 0x6b, 0xf4,
	0x6b, 0x77, 0xde, 0xad, 0xd3, 0xdf, 0xb8, 0x75, 0xa4, 0xcb, 0xa2, 0xb8, 0xc2, 0x5e, 0xab, 0xb6,
	0x7e, 0x1a, 0xa9, 0x1f, 0x15, 0xc5, 0x22, 0x79, 0x00, 0xfe, 0x7c, 0xeb, 0xa6, 0x10, 0x99, 0x3e,
	0x93, 0x57, 0xe7, 0xe8, 0xd1, 0x1c, 0xb7, 0xcb, 0x03, 0x94, 0x76, 0x0b, 0x53, 0xf9, 0xbf, 0x6c,
	0x81, 0xf3, 0x54, 0x4e, 0xf9, 0x52, 0x7c, 0x0d, 0xd6, 0xa6, 0x72, 0x9a, 0x17, 0x8b, 0x6d, 0x58,
	0x97, 0x75, 0x5c, 0x7c, 0xde, 0x87, 0x0d, 0x6b, 0x42, 0x4f, 0x52, 0xa1, 0xb5, 0x4d, 0xfe, 0x1e,
	0xab, 0xb1, 0x08, 0x05, 0x5a, 0x7b, 0xef, 0x41, 0xb7, 0x66, 0x67, 0x33, 0x1d, 0xe6, 0x36, 0x35,
	0x83, 0x5a, 0xa9, 0xb2, 0x06, 0x54, 0xac, 0xf6, 0xe1, 0x46, 0x7d, 0x25, 0x25, 0x8b, 0x48, 0x66,
	0xc6, 0x56, 0xac, 0xad, 0xf9, 0x4c, 0x27, 0x0c, 0x78, 0x1f, 0xc2, 0x96, 0xbe, 0x14, 0x2a, 0x5c,
	0x38, 0x01, 0xa7, 0xee, 0x06, 0x02, 0x4f, 0x6b, 0xa7, 0xd8, 0x83, 0xcd, 0xba, 0x2d, 0x6d, 0x91,
	0xf3, 0x74, 0x7d, 0x6e, 0x4a, 0xdb, 0x5c, 0xb2, 0xa4, 0xbd, 0x3a, 0xcb, 0x96, 0xb4, 0xdf, 0x4f,
	0xa1, 0xbf, 0x3c, 0x67, 0xb5, 0x69, 0x97, 0x36, 0xfd, 0xf6, 0xe2, 0xdc, 0x76, 0xe3, 0xfe, 0xbf,
	0x1b, 0xd0, 0x39, 0x55, 0x1c, 0x81, 0x4d, 0x68, 0x19, 0xa5, 0xad, 0xe3, 0x71, 0x88, 0x9a, 0x69,
	0x92, 0x91, 0x93, 0x1b, 0x01, 0x0e, 0x49, 0x23, 0x5e, 0xda, 0x67, 0x17, 0x87, 0xa8, 0x11, 0x17,
	0x63, 0xf2, 0x61, 0x23, 0xc0, 0xa1, 0x77, 0x03, 0x56, 0x8d, 0x0a, 0x1f, 0xde, 0xb3, 0xee, 0x5a,
	0x31, 0xea, 0xe1, 0x3d, 0xab, 0x3c, 0xb8, 0x47, 0x5e, 0x21, 0xe5, 0x41, 0xa5, 0x3c, 0xa0, 0xf3,
	0xb3, 0xf2, 0x00, 0x1b, 0x66, 0x52, 0x1e, 0xd8, 0x76, 0x63, 0x15, 0xb5, 0x07, 0x98, 0x1f, 0xfc,
	0x24, 0x67, 0xb3, 0xe9, 0x48, 0x16, 0xf6, 0x82, 0x75, 0x49, 0x77, 0x4c, 0x2a, 0x7c, 0xbb, 0x30,
	0x9f, 0xad, 0x01, 0xdf, 0x21, 0x57, 0x16, 0x05, 0xc3, 0xfe, 0x67, 0xd0, 0x19, 0xa6, 0xf9, 0xe5,
	0x93, 0x7c, 0x8c, 0x6d, 0x95, 0x4e, 0xf3, 0xcb, 0x30, 0xcd, 0xc7, 0xf6, 0x05, 0xec, 0x68, 0x0b,
	0x79, 0xb0, 0x92, 0x0a, 0xa3, 0xed, 0xa1, 0x69, 0xec, 0x7f, 0x0e, 0x6b, 0x96, 0xc9, 0x9e, 0xfa,
	0x0e, 0xb8, 0x25, 0x1d, 0xfd, 0xd5, 0xda, 0xeb, 0x3e, 0xd8, 0xdc, 0x2f, 0xbf, 0x43, 0xac, 0x65,
	0xe0, 0xd8, 0x19, 0xb5, 0xff, 0xa7, 0x26, 0xb4, 0x8f, 0x34, 0x35, 0x7a, 0xef, 0x41, 0x97, 0xfb,
	0x39, 0x7e, 0xa5, 0xd9, 0xd7, 0x40, 0x2a, 0x7e, 0xea, 0x3f, 0x84, 0x2d, 0x36, 0xd0, 0x2a, 0x4d,
	0x8c, 0x35, 0xe3, 0x96, 0x75, 0x83, 0x80, 0x21, 0xea, 0xab, 0xfe, 0x1d, 0xaf, 0x7f, 0x92, 0x8d,
	0x43, 0x9d, 0x89, 0xf2, 0x83, 0xa0, 0x45, 0xc6, 0x9b, 0x16, 0x19, 0x66, 0x42, 0x55, 0xdd, 0x78,
	0x21, 0x23, 0x99, 0x5c, 0x2c, 0xd9, 0xaf, 0x90, 0xbd, 0x57, 0x61, 0x73, 0xc6, 0x3e, 0xdc, 0x10,
	0x4a, 0xa5, 0xaf, 0x96, 0x08, 0xb6, 0x96, 0x97, 0xd0, 0xdc, 0xfe, 0x23, 0xf0, 0x78, 0xef, 0xb6,
	0xeb, 0x67, 0xf3, 0x36, 0xef, 0x87, 0x10, 0x6e, 0x70, 0xd8, 0xba, 0x0f, 0x9d, 0x0b, 0x59, 0xe8,
	0x24, 0xcf, 0x28, 0xfc, 0x6e, 0x50, 0x8a, 0xfe, 0xaf, 0x5b, 0xb0, 0x86, 0x1d, 0x81, 0xd4, 0x9a,
	0xfd, 0xed, 0x43, 0x2f, 0x52, 0xb3, 0x5a, 0xeb, 0xd0, 0xa0, 0xe0, 0x74, 0x23, 0x35, 0xab, 0x3a,
	0x87, 0xe5, 0xfa, 0xd1, 0xbc, 0x5a, 0x3f, 0xbe, 0xb2, 0x2e, 0x7c, 0x1d, 0x7a, 0xf6, 0xd1, 0xaa,
	0xf9, 0x66, 0x25, 0x58, 0xb3, 0x4a, 0xde, 0xf7, 0x7d, 0xdb, 0x21, 0x51, 0xbc, 0x29, 0x47, 0xbb,
	0x0f, 0xbc, 0x2a, 0xfa, 0x55, 0x9b, 0xc5, 0x5d, 0x13, 0xef, 0xff, 0xdb, 0xe0, 0x18, 0x65, 0x09,
	0x2e, 0x11, 0xe6, 0xe9, 0x62, 0x6f, 0x5f, 0xd0, 0x31, 0xf6, 0x1a, 0xee, 0x41, 0x27, 0xd6, 0x61,
	0x92, 0x9d, 0xe5, 0x94, 0xc2, 0xdd, 0x07, 0x1b, 0xf3, 0xc9, 0x29, 0x89, 0x82, 0x76, 0xcc, 0xc9,
	0x84, 0x9f, 0x24, 0x13, 0xea, 0x5f, 0xf0, 0xa3, 0xa3, 0x4b, 0x7e, 0x76, 0x59, 0x83, 0x5f, 0x1d,
	0xb7, 0x01, 0x26, 0x22, 0x8b, 0xed, 0x67, 0xcf, 0x1a, 0xc3, 0xac, 0xb1, 0x30, 0x35, 0xfd, 0xdc,
	0xda, 0xf7, 0xa8, 0xe5, 0x77, 0x49, 0x83, 0xbd, 0xbd, 0xff, 0x2b, 0x2c, 0xce, 0x22, 0xfa, 0xff,
	0x03, 0xb0, 0x0b, 0x2e, 0xda, 0xd4, 0x33, 0xd6, 0x89, 0xd4, 0x8c, 0x9d, 0x86, 0xdd, 0x6a, 0x2e,
	0xe2, 0xfb, 0xb6, 0x72, 0xb0, 0x50, 0x6a, 0x1f, 0xda, 0xea, 0xc1, 0x82, 0xb7, 0x03, 0x6d, 0x82,
	0x1f, 0xda, 0x02, 0x62, 0x25, 0x6f, 0x1f, 0xdc, 0xa9, 0x9c, 0x5a, 0x37, 0xb6, 0xc9, 0x35, 0x5b,
	0x95, 0x6b, 0xca, 0x77, 0x24, 0x70, 0xa6, 0xe5, 0x8b, 0xb2, 0x0f, 0x2e, 0xbe, 0x54, 0x6c, 0xdf,
	0x59, 0xb2, 0x2f, 0x9b, 0xb1, 0xc0, 0xc9, 0xe6, 0x6d, 0xd9, 0x62, 0x60, 0x5b, 0x5f, 0x1d, 0xd8,
	0xf7, 0xa0, 0xab, 0x38, 0x51, 0xc9, 0xc7, 0x2e, 0x9d, 0x1a, 0xac, 0xca, 0x3a, 0xb9, 0x16, 0x22,
	0xf8, 0xdf, 0x21, 0xea, 0x2e, 0x85, 0x08, 0xab, 0x33, 0x04, 0x74, 0xe9, 0xcb, 0x4f, 0x5b, 0xfa,
	0x8c, 0x6c, 0xcc, 0x3f, 0x23, 0xb1, 0xfc, 0xe6, 0xaa, 0x7c, 0x07, 0x71, 0xe8, 0x7d, 0x00, 0x9b,
	0xfc, 0xb5, 0x82, 0x4d, 0xdf, 0x42, 0xb3, 0xd7, 0x23, 0xfd, 0x20, 0xb3, 0x2f, 0xf9, 0xb7, 0x60,
	0x8b, 0x0d, 0xa9, 0xc9, 0x5b, 0x68, 0xee, 0xd6, 0x09, 0xc0, 0xe6, 0x8e, 0x4d, 0x3f, 0x83, 0x3e,
	0x17, 0xdf, 0x28, 0x9f, 0x4e, 0x45, 0x16, 0xeb, 0xd0, 0x9e, 0x51, 0xc6, 0xf6, 0xe7, 0xc5, 0x0e,
	0xe1, 0x8f, 0x2d, 0x7c, 0x52, 0xa2, 0xde, 0x07, 0xb0, 0x71, 0x2e, 0x5f, 0x69, 0x25, 0x22, 0x19,
	0x4e, 0x13, 0xad, 0xa5, 0xb6, 0xef, 0xe2, 0x7a, 0xa9, 0x7e, 0x4a, 0x5a, 0xff, 0x37, 0x4d, 0xe8,
	0x05, 0x52, 0xa5, 0x49, 0x24, 0xf0, 0xb4, 0x33, 0x8d, 0xd9, 0xf1, 0x54, 0x98, 0x68, 0x62, 0xcf,
	0xcb, 0x02, 0x66, 0x07, 0xae, 0x92, 0x18, 0x7b, 0x66, 0x2b, 0xa1, 0x73, 0x8e, 0xe5, 0xcb, 0xf2,
	0xc3, 0x87, 0xc6, 0x38, 0xc3, 0x90, 0x3e, 0x7d, 0xf9, 0x7b, 0x98, 0x05, 0xef, 0x2e, 0x74, 0xb1,
	0x66, 0xe9, 0x49, 0x6e, 0x92, 0x6c, 0x4c, 0xfb, 0x77, 0x82, 0xba, 0x0a, 0xd7, 0x38, 0x11, 0x54,
	0x23, 0xda, 0x04, 0x5a, 0x09, 0xf5, 0xdc, 0x82, 0x52, 0x3a, 0x39, 0x81, 0x95, 0xbc, 0x3b, 0x00,
	0x4f, 0x84, 0x36, 0x16, 0x73, 0xe8, 0x2a, 0xd5, 0x34, 0xf8, 0x9d, 0x3c, 0xc8, 0xce, 0xd2, 0x64,
	0x3c, 0xe1, 0xe7, 0x78, 0x35, 0xa8, 0x64, 0x6f, 0x1d, 0x9a, 0x83, 0x23, 0xfb, 0x58, 0x35, 0x07,
	0x47, 0xfe, 0x1f, 0x5b, 0x18, 0xf3, 0x33, 0x63, 0x9d, 0xc0, 0x70, 0xa3, 0x84, 0x71, 0x0b, 0xc7,
	0xf8, 0xd9, 0x7c, 0x54, 0x1e, 0x9f, 0x25, 0xd4, 0x73, 0x71, 0xb5, 0x0e, 0xb0, 0x12, 0xba, 0xe5,
	0x54, 0x16, 0xe5, 0xcf, 0x27, 0x1a, 0xa3, 0x5b, 0x06, 0x59, 0x2c, 0x5f, 0xda, 0xd0, 0xb1, 0x50,
	0x73, 0x6c, 0x7b, 0xc1, 0xb1, 0x7d, 0xe8, 0x1c, 0x2a, 0x95, 0x26, 0x55, 0x9b, 0x52, 0x8a, 0x38,
	0xf7, 0xcf, 0x72, 0x53, 0xf6, 0x24, 0x34, 0xf6, 0xde, 0x05, 0xf7, 0x44, 0x66, 0xf1, 0x4f, 0x67,
	0x72, 0x26, 0xed, 0x59, 0xe7, 0x0a, 0x44, 0xb1, 0x9b, 0x65, 0x14, 0x18, 0xad, 0x14, 0xe8, 0xa6,
	0x43, 0xa5, 0x18, 0xec, 0xb2, 0x9b, 0x4a, 0x19, 0x77, 0x31, 0x34, 0xb9, 0x52, 0x32, 0xa6, 0x4a,
	0xe6, 0x04, 0xa5, 0xe8, 0x7d, 0x04, 0x5b, 0x81, 0xd4, 0x26, 0x2f, 0xec, 0x5b, 0x84, 0x41, 0xa4,
	0x72, 0xe6, 0x04, 0x57, 0x81, 0x79, 0x4a, 0xac, 0xd7, 0x53, 0xe2, 0x01, 0x38, 0x36, 0xf7, 0x74,
	0x7f, 0x83, 0x2e, 0xfe, 0x4e, 0x75, 0xf1, 0x17, 0x92, 0x32, 0xa8, 0xec, 0xfc, 0x01, 0x38, 0xc3,
	0x17, 0x69, 0xd5, 0x3a, 0xe5, 0xb6, 0x75, 0x6a, 0xf1, 0x2d, 0xc4, 0x6f, 0x61, 0x99, 0x8a, 0x57,
	0x21, 0x36, 0x47, 0x4d, 0xd2, 0x3b, 0xa4, 0x38, 0xbc, 0x18, 0x63, 0x50, 0x8d, 0xa2, 0x40, 0xad,
	0x05, 0x4d, 0xa3, 0xfc, 0x09, 0x00, 0x4e, 0x95, 0xe6, 0x97, 0x69, 0x3e, 0xc6, 0xc9, 0x52, 0x99,
	0xd1, 0x64, 0xbd, 0x00, 0x87, 0xe8, 0x68, 0x33, 0x11, 0xdc, 0x88, 0xad, 0x06, 0x34, 0x46, 0xab,
	0x24, 0x7e, 0x69, 0x5f, 0x7b, 0x1c, 0x7a, 0x3e, 0xb4, 0xb0, 0x9f, 0x59, 0x59, 0xee, 0x47, 0x78,
	0xe6, 0x00, 0x41, 0xbf, 0x80, 0x8e, 0x95, 0xe9, 0x27, 0x63, 0x32, 0x95, 0xd5, 0x77, 0x67, 0x2b,
	0xe8, 0xa0, 0x8c, 0xd7, 0x7d, 0x13, 0x5a, 0xfa, 0x45, 0xf9, 0x67, 0x01, 0x87, 0x54, 0xc7, 0xa8,
	0x00, 0xcc, 0xca, 0x72, 0xd2, 0x0a, 0x5c, 0xd2, 0x3c, 0xd7, 0x32, 0xa2, 0xda, 0x2f, 0x52, 0x8b,
	0xae, 0xf0, 0x69, 0x51, 0x81, 0xa0, 0xff, 0x13, 0x58, 0x1d, 0xbe, 0x48, 0x4f, 0x15, 0xfd, 0x9c,
	0x10, 0x69, 0x5a, 0xfa, 0x89, 0x05, 0xeb, 0x8c, 0xe6, 0xdd, 0xd6, 0x5e, 0x0b, 0x9d, 0x31, 0xf7,
	0x5c, 0xd9, 0x68, 0x96, 0x9e, 0x7b, 0x2a, 0x5e, 0x7e, 0xf8, 0x25, 0xb4, 0x4f, 0xd5, 0x61, 0x31,
	0xd6, 0x5e, 0x17, 0x3a, 0x49, 0x76, 0x21, 0xd2, 0x24, 0xde, 0x7c, 0xcb, 0xdb, 0x00, 0x98, 0x6a,
	0x19, 0x85, 0x09, 0x66, 0xf2, 0xe6, 0xbf, 0x3a, 0xde, 0x3a, 0xb8, 0x73, 0xf9, 0xf7, 0x0e, 0xca,
	0xd3, 0x24, 0xb3, 0xf2, 0x1f, 0x9c, 0x47, 0x9b, 0x7f, 0x79, 0x7d, 0xa7, 0xf1, 0xb7, 0xd7, 0x77,
	0x1a, 0xff, 0x78, 0x7d, 0xa7, 0xf1, 0xbb, 0x7f, 0xde, 0x79, 0x6b, 0xd4, 0xa6, 0x1f, 0xc4, 0x1f,
	0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x4c, 0xa6, 0x30, 0x7f, 0x50, 0x16, 0x00, 0x00,
}
