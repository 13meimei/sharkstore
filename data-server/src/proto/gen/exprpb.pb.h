// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exprpb.proto

#ifndef PROTOBUF_exprpb_2eproto__INCLUDED
#define PROTOBUF_exprpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
// @@protoc_insertion_point(includes)
namespace exprpb {
class ColumnInfo;
class ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
}  // namespace exprpb

namespace exprpb {

namespace protobuf_exprpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_exprpb_2eproto

enum ExprType {
  Invalid = 0,
  Column = 1,
  Const_Int = 2,
  Const_UInt = 3,
  Const_Double = 4,
  Const_Bytes = 5,
  LogicAnd = 10,
  LogicOr = 11,
  LogicNot = 12,
  Equal = 20,
  NotEqual = 21,
  Less = 22,
  LessOrEqual = 23,
  Larger = 24,
  LargerOrEqual = 25,
  Plus = 31,
  Minus = 32,
  Mult = 33,
  Div = 34,
  ExprType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExprType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExprType_IsValid(int value);
const ExprType ExprType_MIN = Invalid;
const ExprType ExprType_MAX = Div;
const int ExprType_ARRAYSIZE = ExprType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExprType_descriptor();
inline const ::std::string& ExprType_Name(ExprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExprType_descriptor(), value);
}
inline bool ExprType_Parse(
    const ::std::string& name, ExprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExprType>(
    ExprType_descriptor(), name, value);
}
// ===================================================================

class ColumnInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exprpb.ColumnInfo) */ {
 public:
  ColumnInfo();
  virtual ~ColumnInfo();

  ColumnInfo(const ColumnInfo& from);

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnInfo& default_instance();

  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ColumnInfo* other);
  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ColumnInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ColumnInfo& from);
  void MergeFrom(const ColumnInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ColumnInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .metapb.DataType typ = 2;
  void clear_typ();
  static const int kTypFieldNumber = 2;
  ::metapb::DataType typ() const;
  void set_typ(::metapb::DataType value);

  // bool unsigned = 3;
  void clear_unsigned_();
  static const int kUnsignedFieldNumber = 3;
  bool unsigned_() const;
  void set_unsigned_(bool value);

  // @@protoc_insertion_point(class_scope:exprpb.ColumnInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 id_;
  int typ_;
  bool unsigned__;
  mutable int _cached_size_;
  friend struct protobuf_exprpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:exprpb.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Expr* other);
  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const PROTOBUF_FINAL { return New(NULL); }

  Expr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Expr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .exprpb.Expr child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  const ::exprpb::Expr& child(int index) const;
  ::exprpb::Expr* mutable_child(int index);
  ::exprpb::Expr* add_child();
  ::google::protobuf::RepeatedPtrField< ::exprpb::Expr >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::exprpb::Expr >&
      child() const;

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .exprpb.ColumnInfo column = 2;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 2;
  const ::exprpb::ColumnInfo& column() const;
  ::exprpb::ColumnInfo* mutable_column();
  ::exprpb::ColumnInfo* release_column();
  void set_allocated_column(::exprpb::ColumnInfo* column);

  // .exprpb.ExprType expr_type = 1;
  void clear_expr_type();
  static const int kExprTypeFieldNumber = 1;
  ::exprpb::ExprType expr_type() const;
  void set_expr_type(::exprpb::ExprType value);

  // @@protoc_insertion_point(class_scope:exprpb.Expr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::exprpb::Expr > child_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::exprpb::ColumnInfo* column_;
  int expr_type_;
  mutable int _cached_size_;
  friend struct protobuf_exprpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ColumnInfo

// uint32 id = 1;
inline void ColumnInfo::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 ColumnInfo::id() const {
  // @@protoc_insertion_point(field_get:exprpb.ColumnInfo.id)
  return id_;
}
inline void ColumnInfo::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:exprpb.ColumnInfo.id)
}

// .metapb.DataType typ = 2;
inline void ColumnInfo::clear_typ() {
  typ_ = 0;
}
inline ::metapb::DataType ColumnInfo::typ() const {
  // @@protoc_insertion_point(field_get:exprpb.ColumnInfo.typ)
  return static_cast< ::metapb::DataType >(typ_);
}
inline void ColumnInfo::set_typ(::metapb::DataType value) {
  
  typ_ = value;
  // @@protoc_insertion_point(field_set:exprpb.ColumnInfo.typ)
}

// bool unsigned = 3;
inline void ColumnInfo::clear_unsigned_() {
  unsigned__ = false;
}
inline bool ColumnInfo::unsigned_() const {
  // @@protoc_insertion_point(field_get:exprpb.ColumnInfo.unsigned)
  return unsigned__;
}
inline void ColumnInfo::set_unsigned_(bool value) {
  
  unsigned__ = value;
  // @@protoc_insertion_point(field_set:exprpb.ColumnInfo.unsigned)
}

// -------------------------------------------------------------------

// Expr

// .exprpb.ExprType expr_type = 1;
inline void Expr::clear_expr_type() {
  expr_type_ = 0;
}
inline ::exprpb::ExprType Expr::expr_type() const {
  // @@protoc_insertion_point(field_get:exprpb.Expr.expr_type)
  return static_cast< ::exprpb::ExprType >(expr_type_);
}
inline void Expr::set_expr_type(::exprpb::ExprType value) {
  
  expr_type_ = value;
  // @@protoc_insertion_point(field_set:exprpb.Expr.expr_type)
}

// .exprpb.ColumnInfo column = 2;
inline bool Expr::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void Expr::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::exprpb::ColumnInfo& Expr::column() const {
  const ::exprpb::ColumnInfo* p = column_;
  // @@protoc_insertion_point(field_get:exprpb.Expr.column)
  return p != NULL ? *p : *reinterpret_cast<const ::exprpb::ColumnInfo*>(
      &::exprpb::_ColumnInfo_default_instance_);
}
inline ::exprpb::ColumnInfo* Expr::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::exprpb::ColumnInfo;
  }
  // @@protoc_insertion_point(field_mutable:exprpb.Expr.column)
  return column_;
}
inline ::exprpb::ColumnInfo* Expr::release_column() {
  // @@protoc_insertion_point(field_release:exprpb.Expr.column)
  
  ::exprpb::ColumnInfo* temp = column_;
  column_ = NULL;
  return temp;
}
inline void Expr::set_allocated_column(::exprpb::ColumnInfo* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:exprpb.Expr.column)
}

// bytes value = 3;
inline void Expr::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expr::value() const {
  // @@protoc_insertion_point(field_get:exprpb.Expr.value)
  return value_.GetNoArena();
}
inline void Expr::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:exprpb.Expr.value)
}
#if LANG_CXX11
inline void Expr::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:exprpb.Expr.value)
}
#endif
inline void Expr::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:exprpb.Expr.value)
}
inline void Expr::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:exprpb.Expr.value)
}
inline ::std::string* Expr::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:exprpb.Expr.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expr::release_value() {
  // @@protoc_insertion_point(field_release:exprpb.Expr.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expr::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:exprpb.Expr.value)
}

// repeated .exprpb.Expr child = 4;
inline int Expr::child_size() const {
  return child_.size();
}
inline void Expr::clear_child() {
  child_.Clear();
}
inline const ::exprpb::Expr& Expr::child(int index) const {
  // @@protoc_insertion_point(field_get:exprpb.Expr.child)
  return child_.Get(index);
}
inline ::exprpb::Expr* Expr::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:exprpb.Expr.child)
  return child_.Mutable(index);
}
inline ::exprpb::Expr* Expr::add_child() {
  // @@protoc_insertion_point(field_add:exprpb.Expr.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::exprpb::Expr >*
Expr::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:exprpb.Expr.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::exprpb::Expr >&
Expr::child() const {
  // @@protoc_insertion_point(field_list:exprpb.Expr.child)
  return child_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace exprpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::exprpb::ExprType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::exprpb::ExprType>() {
  return ::exprpb::ExprType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_exprpb_2eproto__INCLUDED
