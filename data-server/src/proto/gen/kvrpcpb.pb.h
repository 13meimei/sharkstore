// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvrpcpb.proto

#ifndef PROTOBUF_kvrpcpb_2eproto__INCLUDED
#define PROTOBUF_kvrpcpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "errorpb.pb.h"
#include "timestamp.pb.h"
// @@protoc_insertion_point(includes)
namespace kvrpcpb {
class BatchInsertRequest;
class BatchInsertRequestDefaultTypeInternal;
extern BatchInsertRequestDefaultTypeInternal _BatchInsertRequest_default_instance_;
class BatchInsertResponse;
class BatchInsertResponseDefaultTypeInternal;
extern BatchInsertResponseDefaultTypeInternal _BatchInsertResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class DsDeleteRequest;
class DsDeleteRequestDefaultTypeInternal;
extern DsDeleteRequestDefaultTypeInternal _DsDeleteRequest_default_instance_;
class DsDeleteResponse;
class DsDeleteResponseDefaultTypeInternal;
extern DsDeleteResponseDefaultTypeInternal _DsDeleteResponse_default_instance_;
class DsInsertRequest;
class DsInsertRequestDefaultTypeInternal;
extern DsInsertRequestDefaultTypeInternal _DsInsertRequest_default_instance_;
class DsInsertResponse;
class DsInsertResponseDefaultTypeInternal;
extern DsInsertResponseDefaultTypeInternal _DsInsertResponse_default_instance_;
class DsKvBatchDeleteRequest;
class DsKvBatchDeleteRequestDefaultTypeInternal;
extern DsKvBatchDeleteRequestDefaultTypeInternal _DsKvBatchDeleteRequest_default_instance_;
class DsKvBatchDeleteResponse;
class DsKvBatchDeleteResponseDefaultTypeInternal;
extern DsKvBatchDeleteResponseDefaultTypeInternal _DsKvBatchDeleteResponse_default_instance_;
class DsKvBatchGetRequest;
class DsKvBatchGetRequestDefaultTypeInternal;
extern DsKvBatchGetRequestDefaultTypeInternal _DsKvBatchGetRequest_default_instance_;
class DsKvBatchGetResponse;
class DsKvBatchGetResponseDefaultTypeInternal;
extern DsKvBatchGetResponseDefaultTypeInternal _DsKvBatchGetResponse_default_instance_;
class DsKvBatchSetRequest;
class DsKvBatchSetRequestDefaultTypeInternal;
extern DsKvBatchSetRequestDefaultTypeInternal _DsKvBatchSetRequest_default_instance_;
class DsKvBatchSetResponse;
class DsKvBatchSetResponseDefaultTypeInternal;
extern DsKvBatchSetResponseDefaultTypeInternal _DsKvBatchSetResponse_default_instance_;
class DsKvDeleteRequest;
class DsKvDeleteRequestDefaultTypeInternal;
extern DsKvDeleteRequestDefaultTypeInternal _DsKvDeleteRequest_default_instance_;
class DsKvDeleteResponse;
class DsKvDeleteResponseDefaultTypeInternal;
extern DsKvDeleteResponseDefaultTypeInternal _DsKvDeleteResponse_default_instance_;
class DsKvGetRequest;
class DsKvGetRequestDefaultTypeInternal;
extern DsKvGetRequestDefaultTypeInternal _DsKvGetRequest_default_instance_;
class DsKvGetResponse;
class DsKvGetResponseDefaultTypeInternal;
extern DsKvGetResponseDefaultTypeInternal _DsKvGetResponse_default_instance_;
class DsKvRangeDeleteRequest;
class DsKvRangeDeleteRequestDefaultTypeInternal;
extern DsKvRangeDeleteRequestDefaultTypeInternal _DsKvRangeDeleteRequest_default_instance_;
class DsKvRangeDeleteResponse;
class DsKvRangeDeleteResponseDefaultTypeInternal;
extern DsKvRangeDeleteResponseDefaultTypeInternal _DsKvRangeDeleteResponse_default_instance_;
class DsKvRawDeleteRequest;
class DsKvRawDeleteRequestDefaultTypeInternal;
extern DsKvRawDeleteRequestDefaultTypeInternal _DsKvRawDeleteRequest_default_instance_;
class DsKvRawDeleteResponse;
class DsKvRawDeleteResponseDefaultTypeInternal;
extern DsKvRawDeleteResponseDefaultTypeInternal _DsKvRawDeleteResponse_default_instance_;
class DsKvRawExecuteRequest;
class DsKvRawExecuteRequestDefaultTypeInternal;
extern DsKvRawExecuteRequestDefaultTypeInternal _DsKvRawExecuteRequest_default_instance_;
class DsKvRawExecuteResponse;
class DsKvRawExecuteResponseDefaultTypeInternal;
extern DsKvRawExecuteResponseDefaultTypeInternal _DsKvRawExecuteResponse_default_instance_;
class DsKvRawGetRequest;
class DsKvRawGetRequestDefaultTypeInternal;
extern DsKvRawGetRequestDefaultTypeInternal _DsKvRawGetRequest_default_instance_;
class DsKvRawGetResponse;
class DsKvRawGetResponseDefaultTypeInternal;
extern DsKvRawGetResponseDefaultTypeInternal _DsKvRawGetResponse_default_instance_;
class DsKvRawPutRequest;
class DsKvRawPutRequestDefaultTypeInternal;
extern DsKvRawPutRequestDefaultTypeInternal _DsKvRawPutRequest_default_instance_;
class DsKvRawPutResponse;
class DsKvRawPutResponseDefaultTypeInternal;
extern DsKvRawPutResponseDefaultTypeInternal _DsKvRawPutResponse_default_instance_;
class DsKvScanRequest;
class DsKvScanRequestDefaultTypeInternal;
extern DsKvScanRequestDefaultTypeInternal _DsKvScanRequest_default_instance_;
class DsKvScanResponse;
class DsKvScanResponseDefaultTypeInternal;
extern DsKvScanResponseDefaultTypeInternal _DsKvScanResponse_default_instance_;
class DsKvSetRequest;
class DsKvSetRequestDefaultTypeInternal;
extern DsKvSetRequestDefaultTypeInternal _DsKvSetRequest_default_instance_;
class DsKvSetResponse;
class DsKvSetResponseDefaultTypeInternal;
extern DsKvSetResponseDefaultTypeInternal _DsKvSetResponse_default_instance_;
class DsLockRequest;
class DsLockRequestDefaultTypeInternal;
extern DsLockRequestDefaultTypeInternal _DsLockRequest_default_instance_;
class DsLockResponse;
class DsLockResponseDefaultTypeInternal;
extern DsLockResponseDefaultTypeInternal _DsLockResponse_default_instance_;
class DsLockScanRequest;
class DsLockScanRequestDefaultTypeInternal;
extern DsLockScanRequestDefaultTypeInternal _DsLockScanRequest_default_instance_;
class DsLockScanResponse;
class DsLockScanResponseDefaultTypeInternal;
extern DsLockScanResponseDefaultTypeInternal _DsLockScanResponse_default_instance_;
class DsLockUpdateRequest;
class DsLockUpdateRequestDefaultTypeInternal;
extern DsLockUpdateRequestDefaultTypeInternal _DsLockUpdateRequest_default_instance_;
class DsLockUpdateResponse;
class DsLockUpdateResponseDefaultTypeInternal;
extern DsLockUpdateResponseDefaultTypeInternal _DsLockUpdateResponse_default_instance_;
class DsSelectRequest;
class DsSelectRequestDefaultTypeInternal;
extern DsSelectRequestDefaultTypeInternal _DsSelectRequest_default_instance_;
class DsSelectResponse;
class DsSelectResponseDefaultTypeInternal;
extern DsSelectResponseDefaultTypeInternal _DsSelectResponse_default_instance_;
class DsUnlockForceRequest;
class DsUnlockForceRequestDefaultTypeInternal;
extern DsUnlockForceRequestDefaultTypeInternal _DsUnlockForceRequest_default_instance_;
class DsUnlockForceResponse;
class DsUnlockForceResponseDefaultTypeInternal;
extern DsUnlockForceResponseDefaultTypeInternal _DsUnlockForceResponse_default_instance_;
class DsUnlockRequest;
class DsUnlockRequestDefaultTypeInternal;
extern DsUnlockRequestDefaultTypeInternal _DsUnlockRequest_default_instance_;
class DsUnlockResponse;
class DsUnlockResponseDefaultTypeInternal;
extern DsUnlockResponseDefaultTypeInternal _DsUnlockResponse_default_instance_;
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class InsertRequest;
class InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertResponse;
class InsertResponseDefaultTypeInternal;
extern InsertResponseDefaultTypeInternal _InsertResponse_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class KvBatchDeleteRequest;
class KvBatchDeleteRequestDefaultTypeInternal;
extern KvBatchDeleteRequestDefaultTypeInternal _KvBatchDeleteRequest_default_instance_;
class KvBatchDeleteResponse;
class KvBatchDeleteResponseDefaultTypeInternal;
extern KvBatchDeleteResponseDefaultTypeInternal _KvBatchDeleteResponse_default_instance_;
class KvBatchGetRequest;
class KvBatchGetRequestDefaultTypeInternal;
extern KvBatchGetRequestDefaultTypeInternal _KvBatchGetRequest_default_instance_;
class KvBatchGetResponse;
class KvBatchGetResponseDefaultTypeInternal;
extern KvBatchGetResponseDefaultTypeInternal _KvBatchGetResponse_default_instance_;
class KvBatchSetRequest;
class KvBatchSetRequestDefaultTypeInternal;
extern KvBatchSetRequestDefaultTypeInternal _KvBatchSetRequest_default_instance_;
class KvBatchSetResponse;
class KvBatchSetResponseDefaultTypeInternal;
extern KvBatchSetResponseDefaultTypeInternal _KvBatchSetResponse_default_instance_;
class KvDeleteRequest;
class KvDeleteRequestDefaultTypeInternal;
extern KvDeleteRequestDefaultTypeInternal _KvDeleteRequest_default_instance_;
class KvDeleteResponse;
class KvDeleteResponseDefaultTypeInternal;
extern KvDeleteResponseDefaultTypeInternal _KvDeleteResponse_default_instance_;
class KvGetRequest;
class KvGetRequestDefaultTypeInternal;
extern KvGetRequestDefaultTypeInternal _KvGetRequest_default_instance_;
class KvGetResponse;
class KvGetResponseDefaultTypeInternal;
extern KvGetResponseDefaultTypeInternal _KvGetResponse_default_instance_;
class KvPair;
class KvPairDefaultTypeInternal;
extern KvPairDefaultTypeInternal _KvPair_default_instance_;
class KvPairRawExecute;
class KvPairRawExecuteDefaultTypeInternal;
extern KvPairRawExecuteDefaultTypeInternal _KvPairRawExecute_default_instance_;
class KvRangeDeleteRequest;
class KvRangeDeleteRequestDefaultTypeInternal;
extern KvRangeDeleteRequestDefaultTypeInternal _KvRangeDeleteRequest_default_instance_;
class KvRangeDeleteResponse;
class KvRangeDeleteResponseDefaultTypeInternal;
extern KvRangeDeleteResponseDefaultTypeInternal _KvRangeDeleteResponse_default_instance_;
class KvRawDeleteRequest;
class KvRawDeleteRequestDefaultTypeInternal;
extern KvRawDeleteRequestDefaultTypeInternal _KvRawDeleteRequest_default_instance_;
class KvRawDeleteResponse;
class KvRawDeleteResponseDefaultTypeInternal;
extern KvRawDeleteResponseDefaultTypeInternal _KvRawDeleteResponse_default_instance_;
class KvRawExecuteRequest;
class KvRawExecuteRequestDefaultTypeInternal;
extern KvRawExecuteRequestDefaultTypeInternal _KvRawExecuteRequest_default_instance_;
class KvRawExecuteResponse;
class KvRawExecuteResponseDefaultTypeInternal;
extern KvRawExecuteResponseDefaultTypeInternal _KvRawExecuteResponse_default_instance_;
class KvRawGetRequest;
class KvRawGetRequestDefaultTypeInternal;
extern KvRawGetRequestDefaultTypeInternal _KvRawGetRequest_default_instance_;
class KvRawGetResponse;
class KvRawGetResponseDefaultTypeInternal;
extern KvRawGetResponseDefaultTypeInternal _KvRawGetResponse_default_instance_;
class KvRawPutRequest;
class KvRawPutRequestDefaultTypeInternal;
extern KvRawPutRequestDefaultTypeInternal _KvRawPutRequest_default_instance_;
class KvRawPutResponse;
class KvRawPutResponseDefaultTypeInternal;
extern KvRawPutResponseDefaultTypeInternal _KvRawPutResponse_default_instance_;
class KvScanRequest;
class KvScanRequestDefaultTypeInternal;
extern KvScanRequestDefaultTypeInternal _KvScanRequest_default_instance_;
class KvScanResponse;
class KvScanResponseDefaultTypeInternal;
extern KvScanResponseDefaultTypeInternal _KvScanResponse_default_instance_;
class KvSetRequest;
class KvSetRequestDefaultTypeInternal;
extern KvSetRequestDefaultTypeInternal _KvSetRequest_default_instance_;
class KvSetResponse;
class KvSetResponseDefaultTypeInternal;
extern KvSetResponseDefaultTypeInternal _KvSetResponse_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class LockInfo;
class LockInfoDefaultTypeInternal;
extern LockInfoDefaultTypeInternal _LockInfo_default_instance_;
class LockRequest;
class LockRequestDefaultTypeInternal;
extern LockRequestDefaultTypeInternal _LockRequest_default_instance_;
class LockResponse;
class LockResponseDefaultTypeInternal;
extern LockResponseDefaultTypeInternal _LockResponse_default_instance_;
class LockScanRequest;
class LockScanRequestDefaultTypeInternal;
extern LockScanRequestDefaultTypeInternal _LockScanRequest_default_instance_;
class LockScanResponse;
class LockScanResponseDefaultTypeInternal;
extern LockScanResponseDefaultTypeInternal _LockScanResponse_default_instance_;
class LockUpdateRequest;
class LockUpdateRequestDefaultTypeInternal;
extern LockUpdateRequestDefaultTypeInternal _LockUpdateRequest_default_instance_;
class LockValue;
class LockValueDefaultTypeInternal;
extern LockValueDefaultTypeInternal _LockValue_default_instance_;
class Match;
class MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class RedisDo;
class RedisDoDefaultTypeInternal;
extern RedisDoDefaultTypeInternal _RedisDo_default_instance_;
class RedisKeyValue;
class RedisKeyValueDefaultTypeInternal;
extern RedisKeyValueDefaultTypeInternal _RedisKeyValue_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class Row;
class RowDefaultTypeInternal;
extern RowDefaultTypeInternal _Row_default_instance_;
class Scope;
class ScopeDefaultTypeInternal;
extern ScopeDefaultTypeInternal _Scope_default_instance_;
class SelectField;
class SelectFieldDefaultTypeInternal;
extern SelectFieldDefaultTypeInternal _SelectField_default_instance_;
class SelectRequest;
class SelectRequestDefaultTypeInternal;
extern SelectRequestDefaultTypeInternal _SelectRequest_default_instance_;
class SelectResponse;
class SelectResponseDefaultTypeInternal;
extern SelectResponseDefaultTypeInternal _SelectResponse_default_instance_;
class UnlockForceRequest;
class UnlockForceRequestDefaultTypeInternal;
extern UnlockForceRequestDefaultTypeInternal _UnlockForceRequest_default_instance_;
class UnlockRequest;
class UnlockRequestDefaultTypeInternal;
extern UnlockRequestDefaultTypeInternal _UnlockRequest_default_instance_;
}  // namespace kvrpcpb

namespace kvrpcpb {

namespace protobuf_kvrpcpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_kvrpcpb_2eproto

enum SelectField_Type {
  SelectField_Type_Column = 0,
  SelectField_Type_AggreFunction = 1,
  SelectField_Type_SelectField_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SelectField_Type_SelectField_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SelectField_Type_IsValid(int value);
const SelectField_Type SelectField_Type_Type_MIN = SelectField_Type_Column;
const SelectField_Type SelectField_Type_Type_MAX = SelectField_Type_AggreFunction;
const int SelectField_Type_Type_ARRAYSIZE = SelectField_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectField_Type_descriptor();
inline const ::std::string& SelectField_Type_Name(SelectField_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectField_Type_descriptor(), value);
}
inline bool SelectField_Type_Parse(
    const ::std::string& name, SelectField_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectField_Type>(
    SelectField_Type_descriptor(), name, value);
}
enum ExecuteType {
  ExecInvalid = 0,
  ExecPut = 1,
  ExecDelete = 2,
  ExecuteType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExecuteType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExecuteType_IsValid(int value);
const ExecuteType ExecuteType_MIN = ExecInvalid;
const ExecuteType ExecuteType_MAX = ExecDelete;
const int ExecuteType_ARRAYSIZE = ExecuteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteType_descriptor();
inline const ::std::string& ExecuteType_Name(ExecuteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteType_descriptor(), value);
}
inline bool ExecuteType_Parse(
    const ::std::string& name, ExecuteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteType>(
    ExecuteType_descriptor(), name, value);
}
enum MatchType {
  Invalid = 0,
  Equal = 1,
  NotEqual = 2,
  Less = 3,
  LessOrEqual = 4,
  Larger = 5,
  LargerOrEqual = 6,
  MatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MatchType_IsValid(int value);
const MatchType MatchType_MIN = Invalid;
const MatchType MatchType_MAX = LargerOrEqual;
const int MatchType_ARRAYSIZE = MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatchType_descriptor();
inline const ::std::string& MatchType_Name(MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatchType_descriptor(), value);
}
inline bool MatchType_Parse(
    const ::std::string& name, MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchType>(
    MatchType_descriptor(), name, value);
}
enum ExistCase {
  EC_Invalid = 0,
  EC_NotExists = 1,
  EC_Exists = 2,
  EC_AnyCase = 3,
  EC_Force = 4,
  ExistCase_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExistCase_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExistCase_IsValid(int value);
const ExistCase ExistCase_MIN = EC_Invalid;
const ExistCase ExistCase_MAX = EC_Force;
const int ExistCase_ARRAYSIZE = ExistCase_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExistCase_descriptor();
inline const ::std::string& ExistCase_Name(ExistCase value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExistCase_descriptor(), value);
}
inline bool ExistCase_Parse(
    const ::std::string& name, ExistCase* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExistCase>(
    ExistCase_descriptor(), name, value);
}
enum Operation {
  OP_Invalid = 0,
  OP_Set = 1,
  OP_Delete = 2,
  OP_Get = 3,
  Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operation_IsValid(int value);
const Operation Operation_MIN = OP_Invalid;
const Operation Operation_MAX = OP_Get;
const int Operation_ARRAYSIZE = Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_descriptor();
inline const ::std::string& Operation_Name(Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_descriptor(), value);
}
inline bool Operation_Parse(
    const ::std::string& name, Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation>(
    Operation_descriptor(), name, value);
}
// ===================================================================

class KvPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvPair) */ {
 public:
  KvPair();
  virtual ~KvPair();

  KvPair(const KvPair& from);

  inline KvPair& operator=(const KvPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvPair(KvPair&& from) noexcept
    : KvPair() {
    *this = ::std::move(from);
  }

  inline KvPair& operator=(KvPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPair& default_instance();

  static inline const KvPair* internal_default_instance() {
    return reinterpret_cast<const KvPair*>(
               &_KvPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(KvPair* other);
  friend void swap(KvPair& a, KvPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvPair* New() const PROTOBUF_FINAL { return New(NULL); }

  KvPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvPair& from);
  void MergeFrom(const KvPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .timestamp.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // .metapb.RangeEpoch range_epoch = 5;
  bool has_range_epoch() const;
  void clear_range_epoch();
  static const int kRangeEpochFieldNumber = 5;
  const ::metapb::RangeEpoch& range_epoch() const;
  ::metapb::RangeEpoch* mutable_range_epoch();
  ::metapb::RangeEpoch* release_range_epoch();
  void set_allocated_range_epoch(::metapb::RangeEpoch* range_epoch);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // uint64 trace_id = 3;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 3;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // uint64 range_id = 4;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 4;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::timestamp::Timestamp* timestamp_;
  ::metapb::RangeEpoch* range_epoch_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .timestamp.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // .timestamp.Timestamp now = 4;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 4;
  const ::timestamp::Timestamp& now() const;
  ::timestamp::Timestamp* mutable_now();
  ::timestamp::Timestamp* release_now();
  void set_allocated_now(::timestamp::Timestamp* now);

  // .errorpb.Error error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  const ::errorpb::Error& error() const;
  ::errorpb::Error* mutable_error();
  ::errorpb::Error* release_error();
  void set_allocated_error(::errorpb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // uint64 trace_id = 3;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 3;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::timestamp::Timestamp* timestamp_;
  ::timestamp::Timestamp* now_;
  ::errorpb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint64 trace_id_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawGetRequest) */ {
 public:
  DsKvRawGetRequest();
  virtual ~DsKvRawGetRequest();

  DsKvRawGetRequest(const DsKvRawGetRequest& from);

  inline DsKvRawGetRequest& operator=(const DsKvRawGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawGetRequest(DsKvRawGetRequest&& from) noexcept
    : DsKvRawGetRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawGetRequest& operator=(DsKvRawGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawGetRequest& default_instance();

  static inline const DsKvRawGetRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawGetRequest*>(
               &_DsKvRawGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DsKvRawGetRequest* other);
  friend void swap(DsKvRawGetRequest& a, DsKvRawGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawGetRequest& from);
  void MergeFrom(const DsKvRawGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawGetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawGetRequest& req() const;
  ::kvrpcpb::KvRawGetRequest* mutable_req();
  ::kvrpcpb::KvRawGetRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawGetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawGetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawGetResponse) */ {
 public:
  DsKvRawGetResponse();
  virtual ~DsKvRawGetResponse();

  DsKvRawGetResponse(const DsKvRawGetResponse& from);

  inline DsKvRawGetResponse& operator=(const DsKvRawGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawGetResponse(DsKvRawGetResponse&& from) noexcept
    : DsKvRawGetResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawGetResponse& operator=(DsKvRawGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawGetResponse& default_instance();

  static inline const DsKvRawGetResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawGetResponse*>(
               &_DsKvRawGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DsKvRawGetResponse* other);
  friend void swap(DsKvRawGetResponse& a, DsKvRawGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawGetResponse& from);
  void MergeFrom(const DsKvRawGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawGetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawGetResponse& resp() const;
  ::kvrpcpb::KvRawGetResponse* mutable_resp();
  ::kvrpcpb::KvRawGetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawGetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawGetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawGetRequest) */ {
 public:
  KvRawGetRequest();
  virtual ~KvRawGetRequest();

  KvRawGetRequest(const KvRawGetRequest& from);

  inline KvRawGetRequest& operator=(const KvRawGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawGetRequest(KvRawGetRequest&& from) noexcept
    : KvRawGetRequest() {
    *this = ::std::move(from);
  }

  inline KvRawGetRequest& operator=(KvRawGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawGetRequest& default_instance();

  static inline const KvRawGetRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawGetRequest*>(
               &_KvRawGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(KvRawGetRequest* other);
  friend void swap(KvRawGetRequest& a, KvRawGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawGetRequest& from);
  void MergeFrom(const KvRawGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawGetResponse) */ {
 public:
  KvRawGetResponse();
  virtual ~KvRawGetResponse();

  KvRawGetResponse(const KvRawGetResponse& from);

  inline KvRawGetResponse& operator=(const KvRawGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawGetResponse(KvRawGetResponse&& from) noexcept
    : KvRawGetResponse() {
    *this = ::std::move(from);
  }

  inline KvRawGetResponse& operator=(KvRawGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawGetResponse& default_instance();

  static inline const KvRawGetResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawGetResponse*>(
               &_KvRawGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(KvRawGetResponse* other);
  friend void swap(KvRawGetResponse& a, KvRawGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawGetResponse& from);
  void MergeFrom(const KvRawGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawPutRequest) */ {
 public:
  DsKvRawPutRequest();
  virtual ~DsKvRawPutRequest();

  DsKvRawPutRequest(const DsKvRawPutRequest& from);

  inline DsKvRawPutRequest& operator=(const DsKvRawPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawPutRequest(DsKvRawPutRequest&& from) noexcept
    : DsKvRawPutRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawPutRequest& operator=(DsKvRawPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawPutRequest& default_instance();

  static inline const DsKvRawPutRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawPutRequest*>(
               &_DsKvRawPutRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DsKvRawPutRequest* other);
  friend void swap(DsKvRawPutRequest& a, DsKvRawPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawPutRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawPutRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawPutRequest& from);
  void MergeFrom(const DsKvRawPutRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawPutRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawPutRequest& req() const;
  ::kvrpcpb::KvRawPutRequest* mutable_req();
  ::kvrpcpb::KvRawPutRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawPutRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawPutRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawPutResponse) */ {
 public:
  DsKvRawPutResponse();
  virtual ~DsKvRawPutResponse();

  DsKvRawPutResponse(const DsKvRawPutResponse& from);

  inline DsKvRawPutResponse& operator=(const DsKvRawPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawPutResponse(DsKvRawPutResponse&& from) noexcept
    : DsKvRawPutResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawPutResponse& operator=(DsKvRawPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawPutResponse& default_instance();

  static inline const DsKvRawPutResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawPutResponse*>(
               &_DsKvRawPutResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DsKvRawPutResponse* other);
  friend void swap(DsKvRawPutResponse& a, DsKvRawPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawPutResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawPutResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawPutResponse& from);
  void MergeFrom(const DsKvRawPutResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawPutResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawPutResponse& resp() const;
  ::kvrpcpb::KvRawPutResponse* mutable_resp();
  ::kvrpcpb::KvRawPutResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawPutResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawPutResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawPutRequest) */ {
 public:
  KvRawPutRequest();
  virtual ~KvRawPutRequest();

  KvRawPutRequest(const KvRawPutRequest& from);

  inline KvRawPutRequest& operator=(const KvRawPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawPutRequest(KvRawPutRequest&& from) noexcept
    : KvRawPutRequest() {
    *this = ::std::move(from);
  }

  inline KvRawPutRequest& operator=(KvRawPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawPutRequest& default_instance();

  static inline const KvRawPutRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawPutRequest*>(
               &_KvRawPutRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(KvRawPutRequest* other);
  friend void swap(KvRawPutRequest& a, KvRawPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawPutRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawPutRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawPutRequest& from);
  void MergeFrom(const KvRawPutRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawPutResponse) */ {
 public:
  KvRawPutResponse();
  virtual ~KvRawPutResponse();

  KvRawPutResponse(const KvRawPutResponse& from);

  inline KvRawPutResponse& operator=(const KvRawPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawPutResponse(KvRawPutResponse&& from) noexcept
    : KvRawPutResponse() {
    *this = ::std::move(from);
  }

  inline KvRawPutResponse& operator=(KvRawPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawPutResponse& default_instance();

  static inline const KvRawPutResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawPutResponse*>(
               &_KvRawPutResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(KvRawPutResponse* other);
  friend void swap(KvRawPutResponse& a, KvRawPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawPutResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawPutResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawPutResponse& from);
  void MergeFrom(const KvRawPutResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawDeleteRequest) */ {
 public:
  DsKvRawDeleteRequest();
  virtual ~DsKvRawDeleteRequest();

  DsKvRawDeleteRequest(const DsKvRawDeleteRequest& from);

  inline DsKvRawDeleteRequest& operator=(const DsKvRawDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawDeleteRequest(DsKvRawDeleteRequest&& from) noexcept
    : DsKvRawDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawDeleteRequest& operator=(DsKvRawDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawDeleteRequest& default_instance();

  static inline const DsKvRawDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawDeleteRequest*>(
               &_DsKvRawDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DsKvRawDeleteRequest* other);
  friend void swap(DsKvRawDeleteRequest& a, DsKvRawDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawDeleteRequest& from);
  void MergeFrom(const DsKvRawDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawDeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawDeleteRequest& req() const;
  ::kvrpcpb::KvRawDeleteRequest* mutable_req();
  ::kvrpcpb::KvRawDeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawDeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawDeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawDeleteResponse) */ {
 public:
  DsKvRawDeleteResponse();
  virtual ~DsKvRawDeleteResponse();

  DsKvRawDeleteResponse(const DsKvRawDeleteResponse& from);

  inline DsKvRawDeleteResponse& operator=(const DsKvRawDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawDeleteResponse(DsKvRawDeleteResponse&& from) noexcept
    : DsKvRawDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawDeleteResponse& operator=(DsKvRawDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawDeleteResponse& default_instance();

  static inline const DsKvRawDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawDeleteResponse*>(
               &_DsKvRawDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DsKvRawDeleteResponse* other);
  friend void swap(DsKvRawDeleteResponse& a, DsKvRawDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawDeleteResponse& from);
  void MergeFrom(const DsKvRawDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawDeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawDeleteResponse& resp() const;
  ::kvrpcpb::KvRawDeleteResponse* mutable_resp();
  ::kvrpcpb::KvRawDeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawDeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawDeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawDeleteRequest) */ {
 public:
  KvRawDeleteRequest();
  virtual ~KvRawDeleteRequest();

  KvRawDeleteRequest(const KvRawDeleteRequest& from);

  inline KvRawDeleteRequest& operator=(const KvRawDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawDeleteRequest(KvRawDeleteRequest&& from) noexcept
    : KvRawDeleteRequest() {
    *this = ::std::move(from);
  }

  inline KvRawDeleteRequest& operator=(KvRawDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawDeleteRequest& default_instance();

  static inline const KvRawDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawDeleteRequest*>(
               &_KvRawDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(KvRawDeleteRequest* other);
  friend void swap(KvRawDeleteRequest& a, KvRawDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawDeleteRequest& from);
  void MergeFrom(const KvRawDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawDeleteResponse) */ {
 public:
  KvRawDeleteResponse();
  virtual ~KvRawDeleteResponse();

  KvRawDeleteResponse(const KvRawDeleteResponse& from);

  inline KvRawDeleteResponse& operator=(const KvRawDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawDeleteResponse(KvRawDeleteResponse&& from) noexcept
    : KvRawDeleteResponse() {
    *this = ::std::move(from);
  }

  inline KvRawDeleteResponse& operator=(KvRawDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawDeleteResponse& default_instance();

  static inline const KvRawDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawDeleteResponse*>(
               &_KvRawDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(KvRawDeleteResponse* other);
  friend void swap(KvRawDeleteResponse& a, KvRawDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawDeleteResponse& from);
  void MergeFrom(const KvRawDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvPairRawExecute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvPairRawExecute) */ {
 public:
  KvPairRawExecute();
  virtual ~KvPairRawExecute();

  KvPairRawExecute(const KvPairRawExecute& from);

  inline KvPairRawExecute& operator=(const KvPairRawExecute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvPairRawExecute(KvPairRawExecute&& from) noexcept
    : KvPairRawExecute() {
    *this = ::std::move(from);
  }

  inline KvPairRawExecute& operator=(KvPairRawExecute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPairRawExecute& default_instance();

  static inline const KvPairRawExecute* internal_default_instance() {
    return reinterpret_cast<const KvPairRawExecute*>(
               &_KvPairRawExecute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(KvPairRawExecute* other);
  friend void swap(KvPairRawExecute& a, KvPairRawExecute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvPairRawExecute* New() const PROTOBUF_FINAL { return New(NULL); }

  KvPairRawExecute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvPairRawExecute& from);
  void MergeFrom(const KvPairRawExecute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvPairRawExecute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.KvPair kv_pair = 2;
  bool has_kv_pair() const;
  void clear_kv_pair();
  static const int kKvPairFieldNumber = 2;
  const ::kvrpcpb::KvPair& kv_pair() const;
  ::kvrpcpb::KvPair* mutable_kv_pair();
  ::kvrpcpb::KvPair* release_kv_pair();
  void set_allocated_kv_pair(::kvrpcpb::KvPair* kv_pair);

  // .kvrpcpb.ExecuteType do = 1;
  void clear_do_();
  static const int kDoFieldNumber = 1;
  ::kvrpcpb::ExecuteType do_() const;
  void set_do_(::kvrpcpb::ExecuteType value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvPairRawExecute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::KvPair* kv_pair_;
  int do__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawExecuteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawExecuteRequest) */ {
 public:
  DsKvRawExecuteRequest();
  virtual ~DsKvRawExecuteRequest();

  DsKvRawExecuteRequest(const DsKvRawExecuteRequest& from);

  inline DsKvRawExecuteRequest& operator=(const DsKvRawExecuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawExecuteRequest(DsKvRawExecuteRequest&& from) noexcept
    : DsKvRawExecuteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawExecuteRequest& operator=(DsKvRawExecuteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawExecuteRequest& default_instance();

  static inline const DsKvRawExecuteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawExecuteRequest*>(
               &_DsKvRawExecuteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(DsKvRawExecuteRequest* other);
  friend void swap(DsKvRawExecuteRequest& a, DsKvRawExecuteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawExecuteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawExecuteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawExecuteRequest& from);
  void MergeFrom(const DsKvRawExecuteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawExecuteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawExecuteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawExecuteRequest& req() const;
  ::kvrpcpb::KvRawExecuteRequest* mutable_req();
  ::kvrpcpb::KvRawExecuteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawExecuteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawExecuteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawExecuteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawExecuteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawExecuteResponse) */ {
 public:
  DsKvRawExecuteResponse();
  virtual ~DsKvRawExecuteResponse();

  DsKvRawExecuteResponse(const DsKvRawExecuteResponse& from);

  inline DsKvRawExecuteResponse& operator=(const DsKvRawExecuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawExecuteResponse(DsKvRawExecuteResponse&& from) noexcept
    : DsKvRawExecuteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawExecuteResponse& operator=(DsKvRawExecuteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawExecuteResponse& default_instance();

  static inline const DsKvRawExecuteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawExecuteResponse*>(
               &_DsKvRawExecuteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DsKvRawExecuteResponse* other);
  friend void swap(DsKvRawExecuteResponse& a, DsKvRawExecuteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawExecuteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawExecuteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawExecuteResponse& from);
  void MergeFrom(const DsKvRawExecuteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawExecuteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawExecuteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawExecuteResponse& resp() const;
  ::kvrpcpb::KvRawExecuteResponse* mutable_resp();
  ::kvrpcpb::KvRawExecuteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawExecuteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawExecuteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawExecuteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawExecuteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawExecuteRequest) */ {
 public:
  KvRawExecuteRequest();
  virtual ~KvRawExecuteRequest();

  KvRawExecuteRequest(const KvRawExecuteRequest& from);

  inline KvRawExecuteRequest& operator=(const KvRawExecuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawExecuteRequest(KvRawExecuteRequest&& from) noexcept
    : KvRawExecuteRequest() {
    *this = ::std::move(from);
  }

  inline KvRawExecuteRequest& operator=(KvRawExecuteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawExecuteRequest& default_instance();

  static inline const KvRawExecuteRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawExecuteRequest*>(
               &_KvRawExecuteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(KvRawExecuteRequest* other);
  friend void swap(KvRawExecuteRequest& a, KvRawExecuteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawExecuteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawExecuteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawExecuteRequest& from);
  void MergeFrom(const KvRawExecuteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawExecuteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPairRawExecute execs = 1;
  int execs_size() const;
  void clear_execs();
  static const int kExecsFieldNumber = 1;
  const ::kvrpcpb::KvPairRawExecute& execs(int index) const;
  ::kvrpcpb::KvPairRawExecute* mutable_execs(int index);
  ::kvrpcpb::KvPairRawExecute* add_execs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >*
      mutable_execs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >&
      execs() const;

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawExecuteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute > execs_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawExecuteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawExecuteResponse) */ {
 public:
  KvRawExecuteResponse();
  virtual ~KvRawExecuteResponse();

  KvRawExecuteResponse(const KvRawExecuteResponse& from);

  inline KvRawExecuteResponse& operator=(const KvRawExecuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawExecuteResponse(KvRawExecuteResponse&& from) noexcept
    : KvRawExecuteResponse() {
    *this = ::std::move(from);
  }

  inline KvRawExecuteResponse& operator=(KvRawExecuteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawExecuteResponse& default_instance();

  static inline const KvRawExecuteResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawExecuteResponse*>(
               &_KvRawExecuteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(KvRawExecuteResponse* other);
  friend void swap(KvRawExecuteResponse& a, KvRawExecuteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawExecuteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawExecuteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawExecuteResponse& from);
  void MergeFrom(const KvRawExecuteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawExecuteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawExecuteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Scope) */ {
 public:
  Scope();
  virtual ~Scope();

  Scope(const Scope& from);

  inline Scope& operator=(const Scope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scope(Scope&& from) noexcept
    : Scope() {
    *this = ::std::move(from);
  }

  inline Scope& operator=(Scope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scope& default_instance();

  static inline const Scope* internal_default_instance() {
    return reinterpret_cast<const Scope*>(
               &_Scope_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Scope* other);
  friend void swap(Scope& a, Scope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scope* New() const PROTOBUF_FINAL { return New(NULL); }

  Scope* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Scope& from);
  void MergeFrom(const Scope& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Scope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Scope)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SelectField) */ {
 public:
  SelectField();
  virtual ~SelectField();

  SelectField(const SelectField& from);

  inline SelectField& operator=(const SelectField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectField(SelectField&& from) noexcept
    : SelectField() {
    *this = ::std::move(from);
  }

  inline SelectField& operator=(SelectField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectField& default_instance();

  static inline const SelectField* internal_default_instance() {
    return reinterpret_cast<const SelectField*>(
               &_SelectField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(SelectField* other);
  friend void swap(SelectField& a, SelectField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectField* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectField& from);
  void MergeFrom(const SelectField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SelectField_Type Type;
  static const Type Column =
    SelectField_Type_Column;
  static const Type AggreFunction =
    SelectField_Type_AggreFunction;
  static inline bool Type_IsValid(int value) {
    return SelectField_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SelectField_Type_Type_MIN;
  static const Type Type_MAX =
    SelectField_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SelectField_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SelectField_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SelectField_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SelectField_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string aggre_func = 2;
  void clear_aggre_func();
  static const int kAggreFuncFieldNumber = 2;
  const ::std::string& aggre_func() const;
  void set_aggre_func(const ::std::string& value);
  #if LANG_CXX11
  void set_aggre_func(::std::string&& value);
  #endif
  void set_aggre_func(const char* value);
  void set_aggre_func(const char* value, size_t size);
  ::std::string* mutable_aggre_func();
  ::std::string* release_aggre_func();
  void set_allocated_aggre_func(::std::string* aggre_func);

  // .metapb.Column column = 3;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 3;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // .kvrpcpb.SelectField.Type typ = 1;
  void clear_typ();
  static const int kTypFieldNumber = 1;
  ::kvrpcpb::SelectField_Type typ() const;
  void set_typ(::kvrpcpb::SelectField_Type value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SelectField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr aggre_func_;
  ::metapb::Column* column_;
  int typ_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Match : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Match) */ {
 public:
  Match();
  virtual ~Match();

  Match(const Match& from);

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(Match&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();

  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Match* other);
  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Match* New() const PROTOBUF_FINAL { return New(NULL); }

  Match* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Match* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  const ::std::string& threshold() const;
  void set_threshold(const ::std::string& value);
  #if LANG_CXX11
  void set_threshold(::std::string&& value);
  #endif
  void set_threshold(const char* value);
  void set_threshold(const void* value, size_t size);
  ::std::string* mutable_threshold();
  ::std::string* release_threshold();
  void set_allocated_threshold(::std::string* threshold);

  // .metapb.Column column = 1;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 1;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // .kvrpcpb.MatchType match_type = 3;
  void clear_match_type();
  static const int kMatchTypeFieldNumber = 3;
  ::kvrpcpb::MatchType match_type() const;
  void set_match_type(::kvrpcpb::MatchType value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Match)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr threshold_;
  ::metapb::Column* column_;
  int match_type_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Limit* other);
  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const PROTOBUF_FINAL { return New(NULL); }

  Limit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // uint64 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Limit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 count_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsSelectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsSelectRequest) */ {
 public:
  DsSelectRequest();
  virtual ~DsSelectRequest();

  DsSelectRequest(const DsSelectRequest& from);

  inline DsSelectRequest& operator=(const DsSelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsSelectRequest(DsSelectRequest&& from) noexcept
    : DsSelectRequest() {
    *this = ::std::move(from);
  }

  inline DsSelectRequest& operator=(DsSelectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsSelectRequest& default_instance();

  static inline const DsSelectRequest* internal_default_instance() {
    return reinterpret_cast<const DsSelectRequest*>(
               &_DsSelectRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(DsSelectRequest* other);
  friend void swap(DsSelectRequest& a, DsSelectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsSelectRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsSelectRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsSelectRequest& from);
  void MergeFrom(const DsSelectRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsSelectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.SelectRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::SelectRequest& req() const;
  ::kvrpcpb::SelectRequest* mutable_req();
  ::kvrpcpb::SelectRequest* release_req();
  void set_allocated_req(::kvrpcpb::SelectRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsSelectRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::SelectRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SelectRequest) */ {
 public:
  SelectRequest();
  virtual ~SelectRequest();

  SelectRequest(const SelectRequest& from);

  inline SelectRequest& operator=(const SelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectRequest(SelectRequest&& from) noexcept
    : SelectRequest() {
    *this = ::std::move(from);
  }

  inline SelectRequest& operator=(SelectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectRequest& default_instance();

  static inline const SelectRequest* internal_default_instance() {
    return reinterpret_cast<const SelectRequest*>(
               &_SelectRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(SelectRequest* other);
  friend void swap(SelectRequest& a, SelectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectRequest& from);
  void MergeFrom(const SelectRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.SelectField field_list = 3;
  int field_list_size() const;
  void clear_field_list();
  static const int kFieldListFieldNumber = 3;
  const ::kvrpcpb::SelectField& field_list(int index) const;
  ::kvrpcpb::SelectField* mutable_field_list(int index);
  ::kvrpcpb::SelectField* add_field_list();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >*
      mutable_field_list();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >&
      field_list() const;

  // repeated .kvrpcpb.Match where_filters = 4;
  int where_filters_size() const;
  void clear_where_filters();
  static const int kWhereFiltersFieldNumber = 4;
  const ::kvrpcpb::Match& where_filters(int index) const;
  ::kvrpcpb::Match* mutable_where_filters(int index);
  ::kvrpcpb::Match* add_where_filters();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
      mutable_where_filters();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
      where_filters() const;

  // repeated .metapb.Column group_bys = 5;
  int group_bys_size() const;
  void clear_group_bys();
  static const int kGroupBysFieldNumber = 5;
  const ::metapb::Column& group_bys(int index) const;
  ::metapb::Column* mutable_group_bys(int index);
  ::metapb::Column* add_group_bys();
  ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
      mutable_group_bys();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
      group_bys() const;

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // .kvrpcpb.Limit limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  const ::kvrpcpb::Limit& limit() const;
  ::kvrpcpb::Limit* mutable_limit();
  ::kvrpcpb::Limit* release_limit();
  void set_allocated_limit(::kvrpcpb::Limit* limit);

  // .timestamp.Timestamp timestamp = 7;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SelectRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField > field_list_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match > where_filters_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Column > group_bys_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  ::kvrpcpb::Limit* limit_;
  ::timestamp::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Row : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Row) */ {
 public:
  Row();
  virtual ~Row();

  Row(const Row& from);

  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Row(Row&& from) noexcept
    : Row() {
    *this = ::std::move(from);
  }

  inline Row& operator=(Row&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Row& default_instance();

  static inline const Row* internal_default_instance() {
    return reinterpret_cast<const Row*>(
               &_Row_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Row* other);
  friend void swap(Row& a, Row& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Row* New() const PROTOBUF_FINAL { return New(NULL); }

  Row* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Row& from);
  void MergeFrom(const Row& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Row* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 aggred_counts = 3;
  int aggred_counts_size() const;
  void clear_aggred_counts();
  static const int kAggredCountsFieldNumber = 3;
  ::google::protobuf::int64 aggred_counts(int index) const;
  void set_aggred_counts(int index, ::google::protobuf::int64 value);
  void add_aggred_counts(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      aggred_counts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_aggred_counts();

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes fields = 2;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields() const;
  void set_fields(const ::std::string& value);
  #if LANG_CXX11
  void set_fields(::std::string&& value);
  #endif
  void set_fields(const char* value);
  void set_fields(const void* value, size_t size);
  ::std::string* mutable_fields();
  ::std::string* release_fields();
  void set_allocated_fields(::std::string* fields);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Row)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > aggred_counts_;
  mutable int _aggred_counts_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr fields_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsSelectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsSelectResponse) */ {
 public:
  DsSelectResponse();
  virtual ~DsSelectResponse();

  DsSelectResponse(const DsSelectResponse& from);

  inline DsSelectResponse& operator=(const DsSelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsSelectResponse(DsSelectResponse&& from) noexcept
    : DsSelectResponse() {
    *this = ::std::move(from);
  }

  inline DsSelectResponse& operator=(DsSelectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsSelectResponse& default_instance();

  static inline const DsSelectResponse* internal_default_instance() {
    return reinterpret_cast<const DsSelectResponse*>(
               &_DsSelectResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(DsSelectResponse* other);
  friend void swap(DsSelectResponse& a, DsSelectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsSelectResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsSelectResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsSelectResponse& from);
  void MergeFrom(const DsSelectResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsSelectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.SelectResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::SelectResponse& resp() const;
  ::kvrpcpb::SelectResponse* mutable_resp();
  ::kvrpcpb::SelectResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::SelectResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsSelectResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::SelectResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SelectResponse) */ {
 public:
  SelectResponse();
  virtual ~SelectResponse();

  SelectResponse(const SelectResponse& from);

  inline SelectResponse& operator=(const SelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectResponse(SelectResponse&& from) noexcept
    : SelectResponse() {
    *this = ::std::move(from);
  }

  inline SelectResponse& operator=(SelectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectResponse& default_instance();

  static inline const SelectResponse* internal_default_instance() {
    return reinterpret_cast<const SelectResponse*>(
               &_SelectResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(SelectResponse* other);
  friend void swap(SelectResponse& a, SelectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectResponse& from);
  void MergeFrom(const SelectResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Row rows = 2;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  const ::kvrpcpb::Row& rows(int index) const;
  ::kvrpcpb::Row* mutable_rows(int index);
  ::kvrpcpb::Row* add_rows();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >&
      rows() const;

  // uint64 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SelectResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row > rows_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(KeyValue* other);
  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes Value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int64 ExpireAt = 3;
  void clear_expireat();
  static const int kExpireAtFieldNumber = 3;
  ::google::protobuf::int64 expireat() const;
  void set_expireat(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int64 expireat_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsInsertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsInsertRequest) */ {
 public:
  DsInsertRequest();
  virtual ~DsInsertRequest();

  DsInsertRequest(const DsInsertRequest& from);

  inline DsInsertRequest& operator=(const DsInsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsInsertRequest(DsInsertRequest&& from) noexcept
    : DsInsertRequest() {
    *this = ::std::move(from);
  }

  inline DsInsertRequest& operator=(DsInsertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsInsertRequest& default_instance();

  static inline const DsInsertRequest* internal_default_instance() {
    return reinterpret_cast<const DsInsertRequest*>(
               &_DsInsertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(DsInsertRequest* other);
  friend void swap(DsInsertRequest& a, DsInsertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsInsertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsInsertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsInsertRequest& from);
  void MergeFrom(const DsInsertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsInsertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.InsertRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::InsertRequest& req() const;
  ::kvrpcpb::InsertRequest* mutable_req();
  ::kvrpcpb::InsertRequest* release_req();
  void set_allocated_req(::kvrpcpb::InsertRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsInsertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::InsertRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsInsertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsInsertResponse) */ {
 public:
  DsInsertResponse();
  virtual ~DsInsertResponse();

  DsInsertResponse(const DsInsertResponse& from);

  inline DsInsertResponse& operator=(const DsInsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsInsertResponse(DsInsertResponse&& from) noexcept
    : DsInsertResponse() {
    *this = ::std::move(from);
  }

  inline DsInsertResponse& operator=(DsInsertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsInsertResponse& default_instance();

  static inline const DsInsertResponse* internal_default_instance() {
    return reinterpret_cast<const DsInsertResponse*>(
               &_DsInsertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(DsInsertResponse* other);
  friend void swap(DsInsertResponse& a, DsInsertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsInsertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsInsertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsInsertResponse& from);
  void MergeFrom(const DsInsertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsInsertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.InsertResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::InsertResponse& resp() const;
  ::kvrpcpb::InsertResponse* mutable_resp();
  ::kvrpcpb::InsertResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::InsertResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsInsertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::InsertResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.InsertRequest) */ {
 public:
  InsertRequest();
  virtual ~InsertRequest();

  InsertRequest(const InsertRequest& from);

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertRequest& default_instance();

  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(InsertRequest* other);
  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  InsertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InsertRequest& from);
  void MergeFrom(const InsertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InsertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KeyValue rows = 1;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  const ::kvrpcpb::KeyValue& rows(int index) const;
  ::kvrpcpb::KeyValue* mutable_rows(int index);
  ::kvrpcpb::KeyValue* add_rows();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >&
      rows() const;

  // .timestamp.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // bool check_duplicate = 2;
  void clear_check_duplicate();
  static const int kCheckDuplicateFieldNumber = 2;
  bool check_duplicate() const;
  void set_check_duplicate(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.InsertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue > rows_;
  ::timestamp::Timestamp* timestamp_;
  bool check_duplicate_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.InsertResponse) */ {
 public:
  InsertResponse();
  virtual ~InsertResponse();

  InsertResponse(const InsertResponse& from);

  inline InsertResponse& operator=(const InsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertResponse(InsertResponse&& from) noexcept
    : InsertResponse() {
    *this = ::std::move(from);
  }

  inline InsertResponse& operator=(InsertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertResponse& default_instance();

  static inline const InsertResponse* internal_default_instance() {
    return reinterpret_cast<const InsertResponse*>(
               &_InsertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(InsertResponse* other);
  friend void swap(InsertResponse& a, InsertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  InsertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InsertResponse& from);
  void MergeFrom(const InsertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InsertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes duplicate_key = 3;
  void clear_duplicate_key();
  static const int kDuplicateKeyFieldNumber = 3;
  const ::std::string& duplicate_key() const;
  void set_duplicate_key(const ::std::string& value);
  #if LANG_CXX11
  void set_duplicate_key(::std::string&& value);
  #endif
  void set_duplicate_key(const char* value);
  void set_duplicate_key(const void* value, size_t size);
  ::std::string* mutable_duplicate_key();
  ::std::string* release_duplicate_key();
  void set_allocated_duplicate_key(::std::string* duplicate_key);

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.InsertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr duplicate_key_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchInsertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchInsertRequest) */ {
 public:
  BatchInsertRequest();
  virtual ~BatchInsertRequest();

  BatchInsertRequest(const BatchInsertRequest& from);

  inline BatchInsertRequest& operator=(const BatchInsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchInsertRequest(BatchInsertRequest&& from) noexcept
    : BatchInsertRequest() {
    *this = ::std::move(from);
  }

  inline BatchInsertRequest& operator=(BatchInsertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchInsertRequest& default_instance();

  static inline const BatchInsertRequest* internal_default_instance() {
    return reinterpret_cast<const BatchInsertRequest*>(
               &_BatchInsertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(BatchInsertRequest* other);
  friend void swap(BatchInsertRequest& a, BatchInsertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchInsertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchInsertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchInsertRequest& from);
  void MergeFrom(const BatchInsertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchInsertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.InsertRequest reqs = 1;
  int reqs_size() const;
  void clear_reqs();
  static const int kReqsFieldNumber = 1;
  const ::kvrpcpb::InsertRequest& reqs(int index) const;
  ::kvrpcpb::InsertRequest* mutable_reqs(int index);
  ::kvrpcpb::InsertRequest* add_reqs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >*
      mutable_reqs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >&
      reqs() const;

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchInsertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest > reqs_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchInsertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchInsertResponse) */ {
 public:
  BatchInsertResponse();
  virtual ~BatchInsertResponse();

  BatchInsertResponse(const BatchInsertResponse& from);

  inline BatchInsertResponse& operator=(const BatchInsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchInsertResponse(BatchInsertResponse&& from) noexcept
    : BatchInsertResponse() {
    *this = ::std::move(from);
  }

  inline BatchInsertResponse& operator=(BatchInsertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchInsertResponse& default_instance();

  static inline const BatchInsertResponse* internal_default_instance() {
    return reinterpret_cast<const BatchInsertResponse*>(
               &_BatchInsertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(BatchInsertResponse* other);
  friend void swap(BatchInsertResponse& a, BatchInsertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchInsertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchInsertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchInsertResponse& from);
  void MergeFrom(const BatchInsertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchInsertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.InsertResponse resps = 2;
  int resps_size() const;
  void clear_resps();
  static const int kRespsFieldNumber = 2;
  const ::kvrpcpb::InsertResponse& resps(int index) const;
  ::kvrpcpb::InsertResponse* mutable_resps(int index);
  ::kvrpcpb::InsertResponse* add_resps();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >*
      mutable_resps();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >&
      resps() const;

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchInsertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse > resps_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsDeleteRequest) */ {
 public:
  DsDeleteRequest();
  virtual ~DsDeleteRequest();

  DsDeleteRequest(const DsDeleteRequest& from);

  inline DsDeleteRequest& operator=(const DsDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsDeleteRequest(DsDeleteRequest&& from) noexcept
    : DsDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsDeleteRequest& operator=(DsDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsDeleteRequest& default_instance();

  static inline const DsDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsDeleteRequest*>(
               &_DsDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(DsDeleteRequest* other);
  friend void swap(DsDeleteRequest& a, DsDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsDeleteRequest& from);
  void MergeFrom(const DsDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.DeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::DeleteRequest& req() const;
  ::kvrpcpb::DeleteRequest* mutable_req();
  ::kvrpcpb::DeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::DeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::DeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsDeleteResponse) */ {
 public:
  DsDeleteResponse();
  virtual ~DsDeleteResponse();

  DsDeleteResponse(const DsDeleteResponse& from);

  inline DsDeleteResponse& operator=(const DsDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsDeleteResponse(DsDeleteResponse&& from) noexcept
    : DsDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsDeleteResponse& operator=(DsDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsDeleteResponse& default_instance();

  static inline const DsDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsDeleteResponse*>(
               &_DsDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(DsDeleteResponse* other);
  friend void swap(DsDeleteResponse& a, DsDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsDeleteResponse& from);
  void MergeFrom(const DsDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.DeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::DeleteResponse& resp() const;
  ::kvrpcpb::DeleteResponse* mutable_resp();
  ::kvrpcpb::DeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::DeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::DeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Match where_filters = 3;
  int where_filters_size() const;
  void clear_where_filters();
  static const int kWhereFiltersFieldNumber = 3;
  const ::kvrpcpb::Match& where_filters(int index) const;
  ::kvrpcpb::Match* mutable_where_filters(int index);
  ::kvrpcpb::Match* add_where_filters();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
      mutable_where_filters();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
      where_filters() const;

  // repeated uint64 indexs = 4;
  int indexs_size() const;
  void clear_indexs();
  static const int kIndexsFieldNumber = 4;
  ::google::protobuf::uint64 indexs(int index) const;
  void set_indexs(int index, ::google::protobuf::uint64 value);
  void add_indexs(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      indexs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_indexs();

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // .timestamp.Timestamp timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match > where_filters_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > indexs_;
  mutable int _indexs_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  ::timestamp::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();

  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Field* other);
  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const PROTOBUF_FINAL { return New(NULL); }

  Field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // uint64 column_id = 1;
  void clear_column_id();
  static const int kColumnIdFieldNumber = 1;
  ::google::protobuf::uint64 column_id() const;
  void set_column_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint64 column_id_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedisKeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RedisKeyValue) */ {
 public:
  RedisKeyValue();
  virtual ~RedisKeyValue();

  RedisKeyValue(const RedisKeyValue& from);

  inline RedisKeyValue& operator=(const RedisKeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedisKeyValue(RedisKeyValue&& from) noexcept
    : RedisKeyValue() {
    *this = ::std::move(from);
  }

  inline RedisKeyValue& operator=(RedisKeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisKeyValue& default_instance();

  static inline const RedisKeyValue* internal_default_instance() {
    return reinterpret_cast<const RedisKeyValue*>(
               &_RedisKeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(RedisKeyValue* other);
  friend void swap(RedisKeyValue& a, RedisKeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedisKeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  RedisKeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedisKeyValue& from);
  void MergeFrom(const RedisKeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedisKeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RedisKeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedisDo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RedisDo) */ {
 public:
  RedisDo();
  virtual ~RedisDo();

  RedisDo(const RedisDo& from);

  inline RedisDo& operator=(const RedisDo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedisDo(RedisDo&& from) noexcept
    : RedisDo() {
    *this = ::std::move(from);
  }

  inline RedisDo& operator=(RedisDo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisDo& default_instance();

  static inline const RedisDo* internal_default_instance() {
    return reinterpret_cast<const RedisDo*>(
               &_RedisDo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(RedisDo* other);
  friend void swap(RedisDo& a, RedisDo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedisDo* New() const PROTOBUF_FINAL { return New(NULL); }

  RedisDo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedisDo& from);
  void MergeFrom(const RedisDo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedisDo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .kvrpcpb.Operation op = 3;
  void clear_op();
  static const int kOpFieldNumber = 3;
  ::kvrpcpb::Operation op() const;
  void set_op(::kvrpcpb::Operation value);

  // .kvrpcpb.ExistCase case = 4;
  void clear_case_();
  static const int kCaseFieldNumber = 4;
  ::kvrpcpb::ExistCase case_() const;
  void set_case_(::kvrpcpb::ExistCase value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RedisDo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int op_;
  int case__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvSetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvSetRequest) */ {
 public:
  KvSetRequest();
  virtual ~KvSetRequest();

  KvSetRequest(const KvSetRequest& from);

  inline KvSetRequest& operator=(const KvSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvSetRequest(KvSetRequest&& from) noexcept
    : KvSetRequest() {
    *this = ::std::move(from);
  }

  inline KvSetRequest& operator=(KvSetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvSetRequest& default_instance();

  static inline const KvSetRequest* internal_default_instance() {
    return reinterpret_cast<const KvSetRequest*>(
               &_KvSetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(KvSetRequest* other);
  friend void swap(KvSetRequest& a, KvSetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvSetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvSetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvSetRequest& from);
  void MergeFrom(const KvSetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RedisKeyValue kv = 1;
  bool has_kv() const;
  void clear_kv();
  static const int kKvFieldNumber = 1;
  const ::kvrpcpb::RedisKeyValue& kv() const;
  ::kvrpcpb::RedisKeyValue* mutable_kv();
  ::kvrpcpb::RedisKeyValue* release_kv();
  void set_allocated_kv(::kvrpcpb::RedisKeyValue* kv);

  // .kvrpcpb.ExistCase case = 2;
  void clear_case_();
  static const int kCaseFieldNumber = 2;
  ::kvrpcpb::ExistCase case_() const;
  void set_case_(::kvrpcpb::ExistCase value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RedisKeyValue* kv_;
  int case__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvSetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvSetResponse) */ {
 public:
  KvSetResponse();
  virtual ~KvSetResponse();

  KvSetResponse(const KvSetResponse& from);

  inline KvSetResponse& operator=(const KvSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvSetResponse(KvSetResponse&& from) noexcept
    : KvSetResponse() {
    *this = ::std::move(from);
  }

  inline KvSetResponse& operator=(KvSetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvSetResponse& default_instance();

  static inline const KvSetResponse* internal_default_instance() {
    return reinterpret_cast<const KvSetResponse*>(
               &_KvSetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(KvSetResponse* other);
  friend void swap(KvSetResponse& a, KvSetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvSetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvSetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvSetResponse& from);
  void MergeFrom(const KvSetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvSetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvSetRequest) */ {
 public:
  DsKvSetRequest();
  virtual ~DsKvSetRequest();

  DsKvSetRequest(const DsKvSetRequest& from);

  inline DsKvSetRequest& operator=(const DsKvSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvSetRequest(DsKvSetRequest&& from) noexcept
    : DsKvSetRequest() {
    *this = ::std::move(from);
  }

  inline DsKvSetRequest& operator=(DsKvSetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvSetRequest& default_instance();

  static inline const DsKvSetRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvSetRequest*>(
               &_DsKvSetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(DsKvSetRequest* other);
  friend void swap(DsKvSetRequest& a, DsKvSetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvSetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvSetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvSetRequest& from);
  void MergeFrom(const DsKvSetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvSetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvSetRequest& req() const;
  ::kvrpcpb::KvSetRequest* mutable_req();
  ::kvrpcpb::KvSetRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvSetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvSetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvSetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvSetResponse) */ {
 public:
  DsKvSetResponse();
  virtual ~DsKvSetResponse();

  DsKvSetResponse(const DsKvSetResponse& from);

  inline DsKvSetResponse& operator=(const DsKvSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvSetResponse(DsKvSetResponse&& from) noexcept
    : DsKvSetResponse() {
    *this = ::std::move(from);
  }

  inline DsKvSetResponse& operator=(DsKvSetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvSetResponse& default_instance();

  static inline const DsKvSetResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvSetResponse*>(
               &_DsKvSetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(DsKvSetResponse* other);
  friend void swap(DsKvSetResponse& a, DsKvSetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvSetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvSetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvSetResponse& from);
  void MergeFrom(const DsKvSetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvSetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvSetResponse& resp() const;
  ::kvrpcpb::KvSetResponse* mutable_resp();
  ::kvrpcpb::KvSetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvSetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvSetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvGetRequest) */ {
 public:
  KvGetRequest();
  virtual ~KvGetRequest();

  KvGetRequest(const KvGetRequest& from);

  inline KvGetRequest& operator=(const KvGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvGetRequest(KvGetRequest&& from) noexcept
    : KvGetRequest() {
    *this = ::std::move(from);
  }

  inline KvGetRequest& operator=(KvGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvGetRequest& default_instance();

  static inline const KvGetRequest* internal_default_instance() {
    return reinterpret_cast<const KvGetRequest*>(
               &_KvGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(KvGetRequest* other);
  friend void swap(KvGetRequest& a, KvGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvGetRequest& from);
  void MergeFrom(const KvGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvGetResponse) */ {
 public:
  KvGetResponse();
  virtual ~KvGetResponse();

  KvGetResponse(const KvGetResponse& from);

  inline KvGetResponse& operator=(const KvGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvGetResponse(KvGetResponse&& from) noexcept
    : KvGetResponse() {
    *this = ::std::move(from);
  }

  inline KvGetResponse& operator=(KvGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvGetResponse& default_instance();

  static inline const KvGetResponse* internal_default_instance() {
    return reinterpret_cast<const KvGetResponse*>(
               &_KvGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(KvGetResponse* other);
  friend void swap(KvGetResponse& a, KvGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvGetResponse& from);
  void MergeFrom(const KvGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvGetRequest) */ {
 public:
  DsKvGetRequest();
  virtual ~DsKvGetRequest();

  DsKvGetRequest(const DsKvGetRequest& from);

  inline DsKvGetRequest& operator=(const DsKvGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvGetRequest(DsKvGetRequest&& from) noexcept
    : DsKvGetRequest() {
    *this = ::std::move(from);
  }

  inline DsKvGetRequest& operator=(DsKvGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvGetRequest& default_instance();

  static inline const DsKvGetRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvGetRequest*>(
               &_DsKvGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(DsKvGetRequest* other);
  friend void swap(DsKvGetRequest& a, DsKvGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvGetRequest& from);
  void MergeFrom(const DsKvGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvGetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvGetRequest& req() const;
  ::kvrpcpb::KvGetRequest* mutable_req();
  ::kvrpcpb::KvGetRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvGetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvGetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvGetResponse) */ {
 public:
  DsKvGetResponse();
  virtual ~DsKvGetResponse();

  DsKvGetResponse(const DsKvGetResponse& from);

  inline DsKvGetResponse& operator=(const DsKvGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvGetResponse(DsKvGetResponse&& from) noexcept
    : DsKvGetResponse() {
    *this = ::std::move(from);
  }

  inline DsKvGetResponse& operator=(DsKvGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvGetResponse& default_instance();

  static inline const DsKvGetResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvGetResponse*>(
               &_DsKvGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(DsKvGetResponse* other);
  friend void swap(DsKvGetResponse& a, DsKvGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvGetResponse& from);
  void MergeFrom(const DsKvGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvGetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvGetResponse& resp() const;
  ::kvrpcpb::KvGetResponse* mutable_resp();
  ::kvrpcpb::KvGetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvGetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvGetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvBatchSetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvBatchSetRequest) */ {
 public:
  KvBatchSetRequest();
  virtual ~KvBatchSetRequest();

  KvBatchSetRequest(const KvBatchSetRequest& from);

  inline KvBatchSetRequest& operator=(const KvBatchSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvBatchSetRequest(KvBatchSetRequest&& from) noexcept
    : KvBatchSetRequest() {
    *this = ::std::move(from);
  }

  inline KvBatchSetRequest& operator=(KvBatchSetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvBatchSetRequest& default_instance();

  static inline const KvBatchSetRequest* internal_default_instance() {
    return reinterpret_cast<const KvBatchSetRequest*>(
               &_KvBatchSetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(KvBatchSetRequest* other);
  friend void swap(KvBatchSetRequest& a, KvBatchSetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvBatchSetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvBatchSetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvBatchSetRequest& from);
  void MergeFrom(const KvBatchSetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvBatchSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.RedisKeyValue kvs = 1;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 1;
  const ::kvrpcpb::RedisKeyValue& kvs(int index) const;
  ::kvrpcpb::RedisKeyValue* mutable_kvs(int index);
  ::kvrpcpb::RedisKeyValue* add_kvs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >*
      mutable_kvs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >&
      kvs() const;

  // .kvrpcpb.ExistCase case = 2;
  void clear_case_();
  static const int kCaseFieldNumber = 2;
  ::kvrpcpb::ExistCase case_() const;
  void set_case_(::kvrpcpb::ExistCase value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvBatchSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue > kvs_;
  int case__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvBatchSetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvBatchSetResponse) */ {
 public:
  KvBatchSetResponse();
  virtual ~KvBatchSetResponse();

  KvBatchSetResponse(const KvBatchSetResponse& from);

  inline KvBatchSetResponse& operator=(const KvBatchSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvBatchSetResponse(KvBatchSetResponse&& from) noexcept
    : KvBatchSetResponse() {
    *this = ::std::move(from);
  }

  inline KvBatchSetResponse& operator=(KvBatchSetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvBatchSetResponse& default_instance();

  static inline const KvBatchSetResponse* internal_default_instance() {
    return reinterpret_cast<const KvBatchSetResponse*>(
               &_KvBatchSetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(KvBatchSetResponse* other);
  friend void swap(KvBatchSetResponse& a, KvBatchSetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvBatchSetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvBatchSetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvBatchSetResponse& from);
  void MergeFrom(const KvBatchSetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvBatchSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvBatchSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvBatchSetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvBatchSetRequest) */ {
 public:
  DsKvBatchSetRequest();
  virtual ~DsKvBatchSetRequest();

  DsKvBatchSetRequest(const DsKvBatchSetRequest& from);

  inline DsKvBatchSetRequest& operator=(const DsKvBatchSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvBatchSetRequest(DsKvBatchSetRequest&& from) noexcept
    : DsKvBatchSetRequest() {
    *this = ::std::move(from);
  }

  inline DsKvBatchSetRequest& operator=(DsKvBatchSetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvBatchSetRequest& default_instance();

  static inline const DsKvBatchSetRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvBatchSetRequest*>(
               &_DsKvBatchSetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(DsKvBatchSetRequest* other);
  friend void swap(DsKvBatchSetRequest& a, DsKvBatchSetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvBatchSetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvBatchSetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvBatchSetRequest& from);
  void MergeFrom(const DsKvBatchSetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvBatchSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvBatchSetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvBatchSetRequest& req() const;
  ::kvrpcpb::KvBatchSetRequest* mutable_req();
  ::kvrpcpb::KvBatchSetRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvBatchSetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvBatchSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvBatchSetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvBatchSetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvBatchSetResponse) */ {
 public:
  DsKvBatchSetResponse();
  virtual ~DsKvBatchSetResponse();

  DsKvBatchSetResponse(const DsKvBatchSetResponse& from);

  inline DsKvBatchSetResponse& operator=(const DsKvBatchSetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvBatchSetResponse(DsKvBatchSetResponse&& from) noexcept
    : DsKvBatchSetResponse() {
    *this = ::std::move(from);
  }

  inline DsKvBatchSetResponse& operator=(DsKvBatchSetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvBatchSetResponse& default_instance();

  static inline const DsKvBatchSetResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvBatchSetResponse*>(
               &_DsKvBatchSetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(DsKvBatchSetResponse* other);
  friend void swap(DsKvBatchSetResponse& a, DsKvBatchSetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvBatchSetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvBatchSetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvBatchSetResponse& from);
  void MergeFrom(const DsKvBatchSetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvBatchSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvBatchSetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvBatchSetResponse& resp() const;
  ::kvrpcpb::KvBatchSetResponse* mutable_resp();
  ::kvrpcpb::KvBatchSetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvBatchSetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvBatchSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvBatchSetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvBatchGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvBatchGetRequest) */ {
 public:
  KvBatchGetRequest();
  virtual ~KvBatchGetRequest();

  KvBatchGetRequest(const KvBatchGetRequest& from);

  inline KvBatchGetRequest& operator=(const KvBatchGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvBatchGetRequest(KvBatchGetRequest&& from) noexcept
    : KvBatchGetRequest() {
    *this = ::std::move(from);
  }

  inline KvBatchGetRequest& operator=(KvBatchGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvBatchGetRequest& default_instance();

  static inline const KvBatchGetRequest* internal_default_instance() {
    return reinterpret_cast<const KvBatchGetRequest*>(
               &_KvBatchGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(KvBatchGetRequest* other);
  friend void swap(KvBatchGetRequest& a, KvBatchGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvBatchGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvBatchGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvBatchGetRequest& from);
  void MergeFrom(const KvBatchGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvBatchGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvBatchGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvBatchGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvBatchGetResponse) */ {
 public:
  KvBatchGetResponse();
  virtual ~KvBatchGetResponse();

  KvBatchGetResponse(const KvBatchGetResponse& from);

  inline KvBatchGetResponse& operator=(const KvBatchGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvBatchGetResponse(KvBatchGetResponse&& from) noexcept
    : KvBatchGetResponse() {
    *this = ::std::move(from);
  }

  inline KvBatchGetResponse& operator=(KvBatchGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvBatchGetResponse& default_instance();

  static inline const KvBatchGetResponse* internal_default_instance() {
    return reinterpret_cast<const KvBatchGetResponse*>(
               &_KvBatchGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(KvBatchGetResponse* other);
  friend void swap(KvBatchGetResponse& a, KvBatchGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvBatchGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvBatchGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvBatchGetResponse& from);
  void MergeFrom(const KvBatchGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvBatchGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.RedisKeyValue kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::kvrpcpb::RedisKeyValue& kvs(int index) const;
  ::kvrpcpb::RedisKeyValue* mutable_kvs(int index);
  ::kvrpcpb::RedisKeyValue* add_kvs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >*
      mutable_kvs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >&
      kvs() const;

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvBatchGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue > kvs_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvBatchGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvBatchGetRequest) */ {
 public:
  DsKvBatchGetRequest();
  virtual ~DsKvBatchGetRequest();

  DsKvBatchGetRequest(const DsKvBatchGetRequest& from);

  inline DsKvBatchGetRequest& operator=(const DsKvBatchGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvBatchGetRequest(DsKvBatchGetRequest&& from) noexcept
    : DsKvBatchGetRequest() {
    *this = ::std::move(from);
  }

  inline DsKvBatchGetRequest& operator=(DsKvBatchGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvBatchGetRequest& default_instance();

  static inline const DsKvBatchGetRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvBatchGetRequest*>(
               &_DsKvBatchGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(DsKvBatchGetRequest* other);
  friend void swap(DsKvBatchGetRequest& a, DsKvBatchGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvBatchGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvBatchGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvBatchGetRequest& from);
  void MergeFrom(const DsKvBatchGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvBatchGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvBatchGetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvBatchGetRequest& req() const;
  ::kvrpcpb::KvBatchGetRequest* mutable_req();
  ::kvrpcpb::KvBatchGetRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvBatchGetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvBatchGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvBatchGetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvBatchGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvBatchGetResponse) */ {
 public:
  DsKvBatchGetResponse();
  virtual ~DsKvBatchGetResponse();

  DsKvBatchGetResponse(const DsKvBatchGetResponse& from);

  inline DsKvBatchGetResponse& operator=(const DsKvBatchGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvBatchGetResponse(DsKvBatchGetResponse&& from) noexcept
    : DsKvBatchGetResponse() {
    *this = ::std::move(from);
  }

  inline DsKvBatchGetResponse& operator=(DsKvBatchGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvBatchGetResponse& default_instance();

  static inline const DsKvBatchGetResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvBatchGetResponse*>(
               &_DsKvBatchGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(DsKvBatchGetResponse* other);
  friend void swap(DsKvBatchGetResponse& a, DsKvBatchGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvBatchGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvBatchGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvBatchGetResponse& from);
  void MergeFrom(const DsKvBatchGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvBatchGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvBatchGetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvBatchGetResponse& resp() const;
  ::kvrpcpb::KvBatchGetResponse* mutable_resp();
  ::kvrpcpb::KvBatchGetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvBatchGetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvBatchGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvBatchGetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvScanRequest) */ {
 public:
  KvScanRequest();
  virtual ~KvScanRequest();

  KvScanRequest(const KvScanRequest& from);

  inline KvScanRequest& operator=(const KvScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvScanRequest(KvScanRequest&& from) noexcept
    : KvScanRequest() {
    *this = ::std::move(from);
  }

  inline KvScanRequest& operator=(KvScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvScanRequest& default_instance();

  static inline const KvScanRequest* internal_default_instance() {
    return reinterpret_cast<const KvScanRequest*>(
               &_KvScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(KvScanRequest* other);
  friend void swap(KvScanRequest& a, KvScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvScanRequest& from);
  void MergeFrom(const KvScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // int64 max_count = 5;
  void clear_max_count();
  static const int kMaxCountFieldNumber = 5;
  ::google::protobuf::int64 max_count() const;
  void set_max_count(::google::protobuf::int64 value);

  // bool count_only = 3;
  void clear_count_only();
  static const int kCountOnlyFieldNumber = 3;
  bool count_only() const;
  void set_count_only(bool value);

  // bool key_only = 4;
  void clear_key_only();
  static const int kKeyOnlyFieldNumber = 4;
  bool key_only() const;
  void set_key_only(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  ::google::protobuf::int64 max_count_;
  bool count_only_;
  bool key_only_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvScanResponse) */ {
 public:
  KvScanResponse();
  virtual ~KvScanResponse();

  KvScanResponse(const KvScanResponse& from);

  inline KvScanResponse& operator=(const KvScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvScanResponse(KvScanResponse&& from) noexcept
    : KvScanResponse() {
    *this = ::std::move(from);
  }

  inline KvScanResponse& operator=(KvScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvScanResponse& default_instance();

  static inline const KvScanResponse* internal_default_instance() {
    return reinterpret_cast<const KvScanResponse*>(
               &_KvScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(KvScanResponse* other);
  friend void swap(KvScanResponse& a, KvScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvScanResponse& from);
  void MergeFrom(const KvScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.RedisKeyValue kvs = 3;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 3;
  const ::kvrpcpb::RedisKeyValue& kvs(int index) const;
  ::kvrpcpb::RedisKeyValue* mutable_kvs(int index);
  ::kvrpcpb::RedisKeyValue* add_kvs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >*
      mutable_kvs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >&
      kvs() const;

  // bytes last_key = 4;
  void clear_last_key();
  static const int kLastKeyFieldNumber = 4;
  const ::std::string& last_key() const;
  void set_last_key(const ::std::string& value);
  #if LANG_CXX11
  void set_last_key(::std::string&& value);
  #endif
  void set_last_key(const char* value);
  void set_last_key(const void* value, size_t size);
  ::std::string* mutable_last_key();
  ::std::string* release_last_key();
  void set_allocated_last_key(::std::string* last_key);

  // int64 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue > kvs_;
  ::google::protobuf::internal::ArenaStringPtr last_key_;
  ::google::protobuf::int64 count_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvScanRequest) */ {
 public:
  DsKvScanRequest();
  virtual ~DsKvScanRequest();

  DsKvScanRequest(const DsKvScanRequest& from);

  inline DsKvScanRequest& operator=(const DsKvScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvScanRequest(DsKvScanRequest&& from) noexcept
    : DsKvScanRequest() {
    *this = ::std::move(from);
  }

  inline DsKvScanRequest& operator=(DsKvScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvScanRequest& default_instance();

  static inline const DsKvScanRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvScanRequest*>(
               &_DsKvScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(DsKvScanRequest* other);
  friend void swap(DsKvScanRequest& a, DsKvScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvScanRequest& from);
  void MergeFrom(const DsKvScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvScanRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvScanRequest& req() const;
  ::kvrpcpb::KvScanRequest* mutable_req();
  ::kvrpcpb::KvScanRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvScanRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvScanRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvScanResponse) */ {
 public:
  DsKvScanResponse();
  virtual ~DsKvScanResponse();

  DsKvScanResponse(const DsKvScanResponse& from);

  inline DsKvScanResponse& operator=(const DsKvScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvScanResponse(DsKvScanResponse&& from) noexcept
    : DsKvScanResponse() {
    *this = ::std::move(from);
  }

  inline DsKvScanResponse& operator=(DsKvScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvScanResponse& default_instance();

  static inline const DsKvScanResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvScanResponse*>(
               &_DsKvScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(DsKvScanResponse* other);
  friend void swap(DsKvScanResponse& a, DsKvScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvScanResponse& from);
  void MergeFrom(const DsKvScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvScanResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvScanResponse& resp() const;
  ::kvrpcpb::KvScanResponse* mutable_resp();
  ::kvrpcpb::KvScanResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvScanResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvScanResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvDeleteRequest) */ {
 public:
  KvDeleteRequest();
  virtual ~KvDeleteRequest();

  KvDeleteRequest(const KvDeleteRequest& from);

  inline KvDeleteRequest& operator=(const KvDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvDeleteRequest(KvDeleteRequest&& from) noexcept
    : KvDeleteRequest() {
    *this = ::std::move(from);
  }

  inline KvDeleteRequest& operator=(KvDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvDeleteRequest& default_instance();

  static inline const KvDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KvDeleteRequest*>(
               &_KvDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(KvDeleteRequest* other);
  friend void swap(KvDeleteRequest& a, KvDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvDeleteRequest& from);
  void MergeFrom(const KvDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.ExistCase case = 2;
  void clear_case_();
  static const int kCaseFieldNumber = 2;
  ::kvrpcpb::ExistCase case_() const;
  void set_case_(::kvrpcpb::ExistCase value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  int case__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvDeleteResponse) */ {
 public:
  KvDeleteResponse();
  virtual ~KvDeleteResponse();

  KvDeleteResponse(const KvDeleteResponse& from);

  inline KvDeleteResponse& operator=(const KvDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvDeleteResponse(KvDeleteResponse&& from) noexcept
    : KvDeleteResponse() {
    *this = ::std::move(from);
  }

  inline KvDeleteResponse& operator=(KvDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvDeleteResponse& default_instance();

  static inline const KvDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const KvDeleteResponse*>(
               &_KvDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(KvDeleteResponse* other);
  friend void swap(KvDeleteResponse& a, KvDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvDeleteResponse& from);
  void MergeFrom(const KvDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvDeleteRequest) */ {
 public:
  DsKvDeleteRequest();
  virtual ~DsKvDeleteRequest();

  DsKvDeleteRequest(const DsKvDeleteRequest& from);

  inline DsKvDeleteRequest& operator=(const DsKvDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvDeleteRequest(DsKvDeleteRequest&& from) noexcept
    : DsKvDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvDeleteRequest& operator=(DsKvDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvDeleteRequest& default_instance();

  static inline const DsKvDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvDeleteRequest*>(
               &_DsKvDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(DsKvDeleteRequest* other);
  friend void swap(DsKvDeleteRequest& a, DsKvDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvDeleteRequest& from);
  void MergeFrom(const DsKvDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvDeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvDeleteRequest& req() const;
  ::kvrpcpb::KvDeleteRequest* mutable_req();
  ::kvrpcpb::KvDeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvDeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvDeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvDeleteResponse) */ {
 public:
  DsKvDeleteResponse();
  virtual ~DsKvDeleteResponse();

  DsKvDeleteResponse(const DsKvDeleteResponse& from);

  inline DsKvDeleteResponse& operator=(const DsKvDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvDeleteResponse(DsKvDeleteResponse&& from) noexcept
    : DsKvDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvDeleteResponse& operator=(DsKvDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvDeleteResponse& default_instance();

  static inline const DsKvDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvDeleteResponse*>(
               &_DsKvDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(DsKvDeleteResponse* other);
  friend void swap(DsKvDeleteResponse& a, DsKvDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvDeleteResponse& from);
  void MergeFrom(const DsKvDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvDeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvDeleteResponse& resp() const;
  ::kvrpcpb::KvDeleteResponse* mutable_resp();
  ::kvrpcpb::KvDeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvDeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvDeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvBatchDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvBatchDeleteRequest) */ {
 public:
  KvBatchDeleteRequest();
  virtual ~KvBatchDeleteRequest();

  KvBatchDeleteRequest(const KvBatchDeleteRequest& from);

  inline KvBatchDeleteRequest& operator=(const KvBatchDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvBatchDeleteRequest(KvBatchDeleteRequest&& from) noexcept
    : KvBatchDeleteRequest() {
    *this = ::std::move(from);
  }

  inline KvBatchDeleteRequest& operator=(KvBatchDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvBatchDeleteRequest& default_instance();

  static inline const KvBatchDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KvBatchDeleteRequest*>(
               &_KvBatchDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(KvBatchDeleteRequest* other);
  friend void swap(KvBatchDeleteRequest& a, KvBatchDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvBatchDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvBatchDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvBatchDeleteRequest& from);
  void MergeFrom(const KvBatchDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvBatchDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // .kvrpcpb.ExistCase case = 2;
  void clear_case_();
  static const int kCaseFieldNumber = 2;
  ::kvrpcpb::ExistCase case_() const;
  void set_case_(::kvrpcpb::ExistCase value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvBatchDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  int case__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvBatchDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvBatchDeleteResponse) */ {
 public:
  KvBatchDeleteResponse();
  virtual ~KvBatchDeleteResponse();

  KvBatchDeleteResponse(const KvBatchDeleteResponse& from);

  inline KvBatchDeleteResponse& operator=(const KvBatchDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvBatchDeleteResponse(KvBatchDeleteResponse&& from) noexcept
    : KvBatchDeleteResponse() {
    *this = ::std::move(from);
  }

  inline KvBatchDeleteResponse& operator=(KvBatchDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvBatchDeleteResponse& default_instance();

  static inline const KvBatchDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const KvBatchDeleteResponse*>(
               &_KvBatchDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(KvBatchDeleteResponse* other);
  friend void swap(KvBatchDeleteResponse& a, KvBatchDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvBatchDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvBatchDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvBatchDeleteResponse& from);
  void MergeFrom(const KvBatchDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvBatchDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvBatchDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvBatchDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvBatchDeleteRequest) */ {
 public:
  DsKvBatchDeleteRequest();
  virtual ~DsKvBatchDeleteRequest();

  DsKvBatchDeleteRequest(const DsKvBatchDeleteRequest& from);

  inline DsKvBatchDeleteRequest& operator=(const DsKvBatchDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvBatchDeleteRequest(DsKvBatchDeleteRequest&& from) noexcept
    : DsKvBatchDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvBatchDeleteRequest& operator=(DsKvBatchDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvBatchDeleteRequest& default_instance();

  static inline const DsKvBatchDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvBatchDeleteRequest*>(
               &_DsKvBatchDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void Swap(DsKvBatchDeleteRequest* other);
  friend void swap(DsKvBatchDeleteRequest& a, DsKvBatchDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvBatchDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvBatchDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvBatchDeleteRequest& from);
  void MergeFrom(const DsKvBatchDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvBatchDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvBatchDeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvBatchDeleteRequest& req() const;
  ::kvrpcpb::KvBatchDeleteRequest* mutable_req();
  ::kvrpcpb::KvBatchDeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvBatchDeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvBatchDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvBatchDeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvBatchDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvBatchDeleteResponse) */ {
 public:
  DsKvBatchDeleteResponse();
  virtual ~DsKvBatchDeleteResponse();

  DsKvBatchDeleteResponse(const DsKvBatchDeleteResponse& from);

  inline DsKvBatchDeleteResponse& operator=(const DsKvBatchDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvBatchDeleteResponse(DsKvBatchDeleteResponse&& from) noexcept
    : DsKvBatchDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvBatchDeleteResponse& operator=(DsKvBatchDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvBatchDeleteResponse& default_instance();

  static inline const DsKvBatchDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvBatchDeleteResponse*>(
               &_DsKvBatchDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(DsKvBatchDeleteResponse* other);
  friend void swap(DsKvBatchDeleteResponse& a, DsKvBatchDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvBatchDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvBatchDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvBatchDeleteResponse& from);
  void MergeFrom(const DsKvBatchDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvBatchDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvBatchDeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvBatchDeleteResponse& resp() const;
  ::kvrpcpb::KvBatchDeleteResponse* mutable_resp();
  ::kvrpcpb::KvBatchDeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvBatchDeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvBatchDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvBatchDeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRangeDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRangeDeleteRequest) */ {
 public:
  KvRangeDeleteRequest();
  virtual ~KvRangeDeleteRequest();

  KvRangeDeleteRequest(const KvRangeDeleteRequest& from);

  inline KvRangeDeleteRequest& operator=(const KvRangeDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRangeDeleteRequest(KvRangeDeleteRequest&& from) noexcept
    : KvRangeDeleteRequest() {
    *this = ::std::move(from);
  }

  inline KvRangeDeleteRequest& operator=(KvRangeDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRangeDeleteRequest& default_instance();

  static inline const KvRangeDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KvRangeDeleteRequest*>(
               &_KvRangeDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(KvRangeDeleteRequest* other);
  friend void swap(KvRangeDeleteRequest& a, KvRangeDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRangeDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRangeDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRangeDeleteRequest& from);
  void MergeFrom(const KvRangeDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRangeDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // int64 max_count = 3;
  void clear_max_count();
  static const int kMaxCountFieldNumber = 3;
  ::google::protobuf::int64 max_count() const;
  void set_max_count(::google::protobuf::int64 value);

  // .kvrpcpb.ExistCase case = 4;
  void clear_case_();
  static const int kCaseFieldNumber = 4;
  ::kvrpcpb::ExistCase case_() const;
  void set_case_(::kvrpcpb::ExistCase value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRangeDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  ::google::protobuf::int64 max_count_;
  int case__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRangeDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRangeDeleteResponse) */ {
 public:
  KvRangeDeleteResponse();
  virtual ~KvRangeDeleteResponse();

  KvRangeDeleteResponse(const KvRangeDeleteResponse& from);

  inline KvRangeDeleteResponse& operator=(const KvRangeDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRangeDeleteResponse(KvRangeDeleteResponse&& from) noexcept
    : KvRangeDeleteResponse() {
    *this = ::std::move(from);
  }

  inline KvRangeDeleteResponse& operator=(KvRangeDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRangeDeleteResponse& default_instance();

  static inline const KvRangeDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const KvRangeDeleteResponse*>(
               &_KvRangeDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void Swap(KvRangeDeleteResponse* other);
  friend void swap(KvRangeDeleteResponse& a, KvRangeDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRangeDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRangeDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRangeDeleteResponse& from);
  void MergeFrom(const KvRangeDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRangeDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes last_key = 3;
  void clear_last_key();
  static const int kLastKeyFieldNumber = 3;
  const ::std::string& last_key() const;
  void set_last_key(const ::std::string& value);
  #if LANG_CXX11
  void set_last_key(::std::string&& value);
  #endif
  void set_last_key(const char* value);
  void set_last_key(const void* value, size_t size);
  ::std::string* mutable_last_key();
  ::std::string* release_last_key();
  void set_allocated_last_key(::std::string* last_key);

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRangeDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr last_key_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRangeDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRangeDeleteRequest) */ {
 public:
  DsKvRangeDeleteRequest();
  virtual ~DsKvRangeDeleteRequest();

  DsKvRangeDeleteRequest(const DsKvRangeDeleteRequest& from);

  inline DsKvRangeDeleteRequest& operator=(const DsKvRangeDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRangeDeleteRequest(DsKvRangeDeleteRequest&& from) noexcept
    : DsKvRangeDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRangeDeleteRequest& operator=(DsKvRangeDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRangeDeleteRequest& default_instance();

  static inline const DsKvRangeDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRangeDeleteRequest*>(
               &_DsKvRangeDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    73;

  void Swap(DsKvRangeDeleteRequest* other);
  friend void swap(DsKvRangeDeleteRequest& a, DsKvRangeDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRangeDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRangeDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRangeDeleteRequest& from);
  void MergeFrom(const DsKvRangeDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRangeDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRangeDeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRangeDeleteRequest& req() const;
  ::kvrpcpb::KvRangeDeleteRequest* mutable_req();
  ::kvrpcpb::KvRangeDeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRangeDeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRangeDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRangeDeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRangeDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRangeDeleteResponse) */ {
 public:
  DsKvRangeDeleteResponse();
  virtual ~DsKvRangeDeleteResponse();

  DsKvRangeDeleteResponse(const DsKvRangeDeleteResponse& from);

  inline DsKvRangeDeleteResponse& operator=(const DsKvRangeDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRangeDeleteResponse(DsKvRangeDeleteResponse&& from) noexcept
    : DsKvRangeDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRangeDeleteResponse& operator=(DsKvRangeDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRangeDeleteResponse& default_instance();

  static inline const DsKvRangeDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRangeDeleteResponse*>(
               &_DsKvRangeDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void Swap(DsKvRangeDeleteResponse* other);
  friend void swap(DsKvRangeDeleteResponse& a, DsKvRangeDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRangeDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRangeDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRangeDeleteResponse& from);
  void MergeFrom(const DsKvRangeDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRangeDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRangeDeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRangeDeleteResponse& resp() const;
  ::kvrpcpb::KvRangeDeleteResponse* mutable_resp();
  ::kvrpcpb::KvRangeDeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRangeDeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRangeDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRangeDeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockValue) */ {
 public:
  LockValue();
  virtual ~LockValue();

  LockValue(const LockValue& from);

  inline LockValue& operator=(const LockValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockValue(LockValue&& from) noexcept
    : LockValue() {
    *this = ::std::move(from);
  }

  inline LockValue& operator=(LockValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockValue& default_instance();

  static inline const LockValue* internal_default_instance() {
    return reinterpret_cast<const LockValue*>(
               &_LockValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void Swap(LockValue* other);
  friend void swap(LockValue& a, LockValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockValue* New() const PROTOBUF_FINAL { return New(NULL); }

  LockValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockValue& from);
  void MergeFrom(const LockValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // int64 delete_time = 4;
  void clear_delete_time();
  static const int kDeleteTimeFieldNumber = 4;
  ::google::protobuf::int64 delete_time() const;
  void set_delete_time(::google::protobuf::int64 value);

  // int64 update_time = 5;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 5;
  ::google::protobuf::int64 update_time() const;
  void set_update_time(::google::protobuf::int64 value);

  // bool delete_flag = 6;
  void clear_delete_flag();
  static const int kDeleteFlagFieldNumber = 6;
  bool delete_flag() const;
  void set_delete_flag(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::int64 delete_time_;
  ::google::protobuf::int64 update_time_;
  bool delete_flag_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockRequest) */ {
 public:
  LockRequest();
  virtual ~LockRequest();

  LockRequest(const LockRequest& from);

  inline LockRequest& operator=(const LockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockRequest(LockRequest&& from) noexcept
    : LockRequest() {
    *this = ::std::move(from);
  }

  inline LockRequest& operator=(LockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockRequest& default_instance();

  static inline const LockRequest* internal_default_instance() {
    return reinterpret_cast<const LockRequest*>(
               &_LockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void Swap(LockRequest* other);
  friend void swap(LockRequest& a, LockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockRequest& from);
  void MergeFrom(const LockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string by = 11;
  void clear_by();
  static const int kByFieldNumber = 11;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // .kvrpcpb.LockValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::kvrpcpb::LockValue& value() const;
  ::kvrpcpb::LockValue* mutable_value();
  ::kvrpcpb::LockValue* release_value();
  void set_allocated_value(::kvrpcpb::LockValue* value);

  // .timestamp.Timestamp timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  ::kvrpcpb::LockValue* value_;
  ::timestamp::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockRequest) */ {
 public:
  DsLockRequest();
  virtual ~DsLockRequest();

  DsLockRequest(const DsLockRequest& from);

  inline DsLockRequest& operator=(const DsLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockRequest(DsLockRequest&& from) noexcept
    : DsLockRequest() {
    *this = ::std::move(from);
  }

  inline DsLockRequest& operator=(DsLockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockRequest& default_instance();

  static inline const DsLockRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockRequest*>(
               &_DsLockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    77;

  void Swap(DsLockRequest* other);
  friend void swap(DsLockRequest& a, DsLockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockRequest& from);
  void MergeFrom(const DsLockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockRequest& req() const;
  ::kvrpcpb::LockRequest* mutable_req();
  ::kvrpcpb::LockRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockResponse) */ {
 public:
  LockResponse();
  virtual ~LockResponse();

  LockResponse(const LockResponse& from);

  inline LockResponse& operator=(const LockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockResponse(LockResponse&& from) noexcept
    : LockResponse() {
    *this = ::std::move(from);
  }

  inline LockResponse& operator=(LockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockResponse& default_instance();

  static inline const LockResponse* internal_default_instance() {
    return reinterpret_cast<const LockResponse*>(
               &_LockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    78;

  void Swap(LockResponse* other);
  friend void swap(LockResponse& a, LockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockResponse& from);
  void MergeFrom(const LockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int64 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int64 code() const;
  void set_code(::google::protobuf::int64 value);

  // int64 update_time = 4;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  ::google::protobuf::int64 update_time() const;
  void set_update_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int64 code_;
  ::google::protobuf::int64 update_time_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockInfo) */ {
 public:
  LockInfo();
  virtual ~LockInfo();

  LockInfo(const LockInfo& from);

  inline LockInfo& operator=(const LockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockInfo(LockInfo&& from) noexcept
    : LockInfo() {
    *this = ::std::move(from);
  }

  inline LockInfo& operator=(LockInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInfo& default_instance();

  static inline const LockInfo* internal_default_instance() {
    return reinterpret_cast<const LockInfo*>(
               &_LockInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    79;

  void Swap(LockInfo* other);
  friend void swap(LockInfo& a, LockInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LockInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockInfo& from);
  void MergeFrom(const LockInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.LockValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::kvrpcpb::LockValue& value() const;
  ::kvrpcpb::LockValue* mutable_value();
  ::kvrpcpb::LockValue* release_value();
  void set_allocated_value(::kvrpcpb::LockValue* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::LockValue* value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockScanResponse) */ {
 public:
  LockScanResponse();
  virtual ~LockScanResponse();

  LockScanResponse(const LockScanResponse& from);

  inline LockScanResponse& operator=(const LockScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockScanResponse(LockScanResponse&& from) noexcept
    : LockScanResponse() {
    *this = ::std::move(from);
  }

  inline LockScanResponse& operator=(LockScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockScanResponse& default_instance();

  static inline const LockScanResponse* internal_default_instance() {
    return reinterpret_cast<const LockScanResponse*>(
               &_LockScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    80;

  void Swap(LockScanResponse* other);
  friend void swap(LockScanResponse& a, LockScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockScanResponse& from);
  void MergeFrom(const LockScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.LockInfo info = 1;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::kvrpcpb::LockInfo& info(int index) const;
  ::kvrpcpb::LockInfo* mutable_info(int index);
  ::kvrpcpb::LockInfo* add_info();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
      mutable_info();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
      info() const;

  // bytes last_key = 2;
  void clear_last_key();
  static const int kLastKeyFieldNumber = 2;
  const ::std::string& last_key() const;
  void set_last_key(const ::std::string& value);
  #if LANG_CXX11
  void set_last_key(::std::string&& value);
  #endif
  void set_last_key(const char* value);
  void set_last_key(const void* value, size_t size);
  ::std::string* mutable_last_key();
  ::std::string* release_last_key();
  void set_allocated_last_key(::std::string* last_key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo > info_;
  ::google::protobuf::internal::ArenaStringPtr last_key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockResponse) */ {
 public:
  DsLockResponse();
  virtual ~DsLockResponse();

  DsLockResponse(const DsLockResponse& from);

  inline DsLockResponse& operator=(const DsLockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockResponse(DsLockResponse&& from) noexcept
    : DsLockResponse() {
    *this = ::std::move(from);
  }

  inline DsLockResponse& operator=(DsLockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockResponse& default_instance();

  static inline const DsLockResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockResponse*>(
               &_DsLockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    81;

  void Swap(DsLockResponse* other);
  friend void swap(DsLockResponse& a, DsLockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockResponse& from);
  void MergeFrom(const DsLockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockUpdateRequest) */ {
 public:
  LockUpdateRequest();
  virtual ~LockUpdateRequest();

  LockUpdateRequest(const LockUpdateRequest& from);

  inline LockUpdateRequest& operator=(const LockUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockUpdateRequest(LockUpdateRequest&& from) noexcept
    : LockUpdateRequest() {
    *this = ::std::move(from);
  }

  inline LockUpdateRequest& operator=(LockUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockUpdateRequest& default_instance();

  static inline const LockUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const LockUpdateRequest*>(
               &_LockUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    82;

  void Swap(LockUpdateRequest* other);
  friend void swap(LockUpdateRequest& a, LockUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockUpdateRequest& from);
  void MergeFrom(const LockUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bytes update_value = 6;
  void clear_update_value();
  static const int kUpdateValueFieldNumber = 6;
  const ::std::string& update_value() const;
  void set_update_value(const ::std::string& value);
  #if LANG_CXX11
  void set_update_value(::std::string&& value);
  #endif
  void set_update_value(const char* value);
  void set_update_value(const void* value, size_t size);
  ::std::string* mutable_update_value();
  ::std::string* release_update_value();
  void set_allocated_update_value(::std::string* update_value);

  // .timestamp.Timestamp timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // int64 update_time = 5;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 5;
  ::google::protobuf::int64 update_time() const;
  void set_update_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr update_value_;
  ::timestamp::Timestamp* timestamp_;
  ::google::protobuf::int64 update_time_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockUpdateRequest) */ {
 public:
  DsLockUpdateRequest();
  virtual ~DsLockUpdateRequest();

  DsLockUpdateRequest(const DsLockUpdateRequest& from);

  inline DsLockUpdateRequest& operator=(const DsLockUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockUpdateRequest(DsLockUpdateRequest&& from) noexcept
    : DsLockUpdateRequest() {
    *this = ::std::move(from);
  }

  inline DsLockUpdateRequest& operator=(DsLockUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockUpdateRequest& default_instance();

  static inline const DsLockUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockUpdateRequest*>(
               &_DsLockUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    83;

  void Swap(DsLockUpdateRequest* other);
  friend void swap(DsLockUpdateRequest& a, DsLockUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockUpdateRequest& from);
  void MergeFrom(const DsLockUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockUpdateRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockUpdateRequest& req() const;
  ::kvrpcpb::LockUpdateRequest* mutable_req();
  ::kvrpcpb::LockUpdateRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockUpdateRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockUpdateRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockUpdateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockUpdateResponse) */ {
 public:
  DsLockUpdateResponse();
  virtual ~DsLockUpdateResponse();

  DsLockUpdateResponse(const DsLockUpdateResponse& from);

  inline DsLockUpdateResponse& operator=(const DsLockUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockUpdateResponse(DsLockUpdateResponse&& from) noexcept
    : DsLockUpdateResponse() {
    *this = ::std::move(from);
  }

  inline DsLockUpdateResponse& operator=(DsLockUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockUpdateResponse& default_instance();

  static inline const DsLockUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockUpdateResponse*>(
               &_DsLockUpdateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    84;

  void Swap(DsLockUpdateResponse* other);
  friend void swap(DsLockUpdateResponse& a, DsLockUpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockUpdateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockUpdateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockUpdateResponse& from);
  void MergeFrom(const DsLockUpdateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockUpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockUpdateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.UnlockRequest) */ {
 public:
  UnlockRequest();
  virtual ~UnlockRequest();

  UnlockRequest(const UnlockRequest& from);

  inline UnlockRequest& operator=(const UnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockRequest(UnlockRequest&& from) noexcept
    : UnlockRequest() {
    *this = ::std::move(from);
  }

  inline UnlockRequest& operator=(UnlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockRequest& default_instance();

  static inline const UnlockRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockRequest*>(
               &_UnlockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    85;

  void Swap(UnlockRequest* other);
  friend void swap(UnlockRequest& a, UnlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockRequest& from);
  void MergeFrom(const UnlockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string by = 11;
  void clear_by();
  static const int kByFieldNumber = 11;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // .timestamp.Timestamp timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.UnlockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  ::timestamp::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockRequest) */ {
 public:
  DsUnlockRequest();
  virtual ~DsUnlockRequest();

  DsUnlockRequest(const DsUnlockRequest& from);

  inline DsUnlockRequest& operator=(const DsUnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockRequest(DsUnlockRequest&& from) noexcept
    : DsUnlockRequest() {
    *this = ::std::move(from);
  }

  inline DsUnlockRequest& operator=(DsUnlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockRequest& default_instance();

  static inline const DsUnlockRequest* internal_default_instance() {
    return reinterpret_cast<const DsUnlockRequest*>(
               &_DsUnlockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    86;

  void Swap(DsUnlockRequest* other);
  friend void swap(DsUnlockRequest& a, DsUnlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockRequest& from);
  void MergeFrom(const DsUnlockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.UnlockRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::UnlockRequest& req() const;
  ::kvrpcpb::UnlockRequest* mutable_req();
  ::kvrpcpb::UnlockRequest* release_req();
  void set_allocated_req(::kvrpcpb::UnlockRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::UnlockRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockResponse) */ {
 public:
  DsUnlockResponse();
  virtual ~DsUnlockResponse();

  DsUnlockResponse(const DsUnlockResponse& from);

  inline DsUnlockResponse& operator=(const DsUnlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockResponse(DsUnlockResponse&& from) noexcept
    : DsUnlockResponse() {
    *this = ::std::move(from);
  }

  inline DsUnlockResponse& operator=(DsUnlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockResponse& default_instance();

  static inline const DsUnlockResponse* internal_default_instance() {
    return reinterpret_cast<const DsUnlockResponse*>(
               &_DsUnlockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    87;

  void Swap(DsUnlockResponse* other);
  friend void swap(DsUnlockResponse& a, DsUnlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockResponse& from);
  void MergeFrom(const DsUnlockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnlockForceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.UnlockForceRequest) */ {
 public:
  UnlockForceRequest();
  virtual ~UnlockForceRequest();

  UnlockForceRequest(const UnlockForceRequest& from);

  inline UnlockForceRequest& operator=(const UnlockForceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockForceRequest(UnlockForceRequest&& from) noexcept
    : UnlockForceRequest() {
    *this = ::std::move(from);
  }

  inline UnlockForceRequest& operator=(UnlockForceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockForceRequest& default_instance();

  static inline const UnlockForceRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockForceRequest*>(
               &_UnlockForceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    88;

  void Swap(UnlockForceRequest* other);
  friend void swap(UnlockForceRequest& a, UnlockForceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockForceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockForceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockForceRequest& from);
  void MergeFrom(const UnlockForceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockForceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string by = 11;
  void clear_by();
  static const int kByFieldNumber = 11;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // .timestamp.Timestamp timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  const ::timestamp::Timestamp& timestamp() const;
  ::timestamp::Timestamp* mutable_timestamp();
  ::timestamp::Timestamp* release_timestamp();
  void set_allocated_timestamp(::timestamp::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.UnlockForceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  ::timestamp::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockForceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockForceRequest) */ {
 public:
  DsUnlockForceRequest();
  virtual ~DsUnlockForceRequest();

  DsUnlockForceRequest(const DsUnlockForceRequest& from);

  inline DsUnlockForceRequest& operator=(const DsUnlockForceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockForceRequest(DsUnlockForceRequest&& from) noexcept
    : DsUnlockForceRequest() {
    *this = ::std::move(from);
  }

  inline DsUnlockForceRequest& operator=(DsUnlockForceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockForceRequest& default_instance();

  static inline const DsUnlockForceRequest* internal_default_instance() {
    return reinterpret_cast<const DsUnlockForceRequest*>(
               &_DsUnlockForceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    89;

  void Swap(DsUnlockForceRequest* other);
  friend void swap(DsUnlockForceRequest& a, DsUnlockForceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockForceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockForceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockForceRequest& from);
  void MergeFrom(const DsUnlockForceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockForceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.UnlockForceRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::UnlockForceRequest& req() const;
  ::kvrpcpb::UnlockForceRequest* mutable_req();
  ::kvrpcpb::UnlockForceRequest* release_req();
  void set_allocated_req(::kvrpcpb::UnlockForceRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockForceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::UnlockForceRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockForceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockForceResponse) */ {
 public:
  DsUnlockForceResponse();
  virtual ~DsUnlockForceResponse();

  DsUnlockForceResponse(const DsUnlockForceResponse& from);

  inline DsUnlockForceResponse& operator=(const DsUnlockForceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockForceResponse(DsUnlockForceResponse&& from) noexcept
    : DsUnlockForceResponse() {
    *this = ::std::move(from);
  }

  inline DsUnlockForceResponse& operator=(DsUnlockForceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockForceResponse& default_instance();

  static inline const DsUnlockForceResponse* internal_default_instance() {
    return reinterpret_cast<const DsUnlockForceResponse*>(
               &_DsUnlockForceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    90;

  void Swap(DsUnlockForceResponse* other);
  friend void swap(DsUnlockForceResponse& a, DsUnlockForceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockForceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockForceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockForceResponse& from);
  void MergeFrom(const DsUnlockForceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockForceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockForceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockScanRequest) */ {
 public:
  LockScanRequest();
  virtual ~LockScanRequest();

  LockScanRequest(const LockScanRequest& from);

  inline LockScanRequest& operator=(const LockScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockScanRequest(LockScanRequest&& from) noexcept
    : LockScanRequest() {
    *this = ::std::move(from);
  }

  inline LockScanRequest& operator=(LockScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockScanRequest& default_instance();

  static inline const LockScanRequest* internal_default_instance() {
    return reinterpret_cast<const LockScanRequest*>(
               &_LockScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    91;

  void Swap(LockScanRequest* other);
  friend void swap(LockScanRequest& a, LockScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockScanRequest& from);
  void MergeFrom(const LockScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // uint32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  ::google::protobuf::uint32 count_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockScanRequest) */ {
 public:
  DsLockScanRequest();
  virtual ~DsLockScanRequest();

  DsLockScanRequest(const DsLockScanRequest& from);

  inline DsLockScanRequest& operator=(const DsLockScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockScanRequest(DsLockScanRequest&& from) noexcept
    : DsLockScanRequest() {
    *this = ::std::move(from);
  }

  inline DsLockScanRequest& operator=(DsLockScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockScanRequest& default_instance();

  static inline const DsLockScanRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockScanRequest*>(
               &_DsLockScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    92;

  void Swap(DsLockScanRequest* other);
  friend void swap(DsLockScanRequest& a, DsLockScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockScanRequest& from);
  void MergeFrom(const DsLockScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockScanRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockScanRequest& req() const;
  ::kvrpcpb::LockScanRequest* mutable_req();
  ::kvrpcpb::LockScanRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockScanRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockScanRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockScanResponse) */ {
 public:
  DsLockScanResponse();
  virtual ~DsLockScanResponse();

  DsLockScanResponse(const DsLockScanResponse& from);

  inline DsLockScanResponse& operator=(const DsLockScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockScanResponse(DsLockScanResponse&& from) noexcept
    : DsLockScanResponse() {
    *this = ::std::move(from);
  }

  inline DsLockScanResponse& operator=(DsLockScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockScanResponse& default_instance();

  static inline const DsLockScanResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockScanResponse*>(
               &_DsLockScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    93;

  void Swap(DsLockScanResponse* other);
  friend void swap(DsLockScanResponse& a, DsLockScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockScanResponse& from);
  void MergeFrom(const DsLockScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockScanResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockScanResponse& resp() const;
  ::kvrpcpb::LockScanResponse* mutable_resp();
  ::kvrpcpb::LockScanResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockScanResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockScanResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KvPair

// bytes key = 1;
inline void KvPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvPair::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.key)
  return key_.GetNoArena();
}
inline void KvPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.key)
}
#if LANG_CXX11
inline void KvPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvPair.key)
}
#endif
inline void KvPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.key)
}
inline void KvPair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.key)
}
inline ::std::string* KvPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.key)
}

// bytes value = 2;
inline void KvPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvPair::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.value)
  return value_.GetNoArena();
}
inline void KvPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.value)
}
#if LANG_CXX11
inline void KvPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvPair.value)
}
#endif
inline void KvPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.value)
}
inline void KvPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.value)
}
inline ::std::string* KvPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.value)
}

// -------------------------------------------------------------------

// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.cluster_id)
}

// .timestamp.Timestamp timestamp = 2;
inline bool RequestHeader::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void RequestHeader::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& RequestHeader::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* RequestHeader::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RequestHeader.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* RequestHeader::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RequestHeader.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RequestHeader.timestamp)
}

// uint64 trace_id = 3;
inline void RequestHeader::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::trace_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.trace_id)
  return trace_id_;
}
inline void RequestHeader::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.trace_id)
}

// uint64 range_id = 4;
inline void RequestHeader::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::range_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.range_id)
  return range_id_;
}
inline void RequestHeader::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.range_id)
}

// .metapb.RangeEpoch range_epoch = 5;
inline bool RequestHeader::has_range_epoch() const {
  return this != internal_default_instance() && range_epoch_ != NULL;
}
inline void RequestHeader::clear_range_epoch() {
  if (GetArenaNoVirtual() == NULL && range_epoch_ != NULL) delete range_epoch_;
  range_epoch_ = NULL;
}
inline const ::metapb::RangeEpoch& RequestHeader::range_epoch() const {
  const ::metapb::RangeEpoch* p = range_epoch_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.range_epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::RangeEpoch*>(
      &::metapb::_RangeEpoch_default_instance_);
}
inline ::metapb::RangeEpoch* RequestHeader::mutable_range_epoch() {
  
  if (range_epoch_ == NULL) {
    range_epoch_ = new ::metapb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RequestHeader.range_epoch)
  return range_epoch_;
}
inline ::metapb::RangeEpoch* RequestHeader::release_range_epoch() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RequestHeader.range_epoch)
  
  ::metapb::RangeEpoch* temp = range_epoch_;
  range_epoch_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_range_epoch(::metapb::RangeEpoch* range_epoch) {
  delete range_epoch_;
  range_epoch_ = range_epoch;
  if (range_epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RequestHeader.range_epoch)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResponseHeader.cluster_id)
}

// .timestamp.Timestamp timestamp = 2;
inline bool ResponseHeader::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void ResponseHeader::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& ResponseHeader::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* ResponseHeader::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResponseHeader.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* ResponseHeader::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResponseHeader.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResponseHeader.timestamp)
}

// uint64 trace_id = 3;
inline void ResponseHeader::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::trace_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.trace_id)
  return trace_id_;
}
inline void ResponseHeader::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResponseHeader.trace_id)
}

// .timestamp.Timestamp now = 4;
inline bool ResponseHeader::has_now() const {
  return this != internal_default_instance() && now_ != NULL;
}
inline void ResponseHeader::clear_now() {
  if (GetArenaNoVirtual() == NULL && now_ != NULL) delete now_;
  now_ = NULL;
}
inline const ::timestamp::Timestamp& ResponseHeader::now() const {
  const ::timestamp::Timestamp* p = now_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.now)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* ResponseHeader::mutable_now() {
  
  if (now_ == NULL) {
    now_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResponseHeader.now)
  return now_;
}
inline ::timestamp::Timestamp* ResponseHeader::release_now() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResponseHeader.now)
  
  ::timestamp::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_now(::timestamp::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResponseHeader.now)
}

// .errorpb.Error error = 5;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::errorpb::Error& ResponseHeader::error() const {
  const ::errorpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::errorpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResponseHeader.error)
  return error_;
}
inline ::errorpb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResponseHeader.error)
  
  ::errorpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_error(::errorpb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// DsKvRawGetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawGetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawGetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawGetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawGetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawGetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawGetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetRequest.header)
}

// .kvrpcpb.KvRawGetRequest req = 2;
inline bool DsKvRawGetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawGetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawGetRequest& DsKvRawGetRequest::req() const {
  const ::kvrpcpb::KvRawGetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawGetRequest*>(
      &::kvrpcpb::_KvRawGetRequest_default_instance_);
}
inline ::kvrpcpb::KvRawGetRequest* DsKvRawGetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawGetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawGetRequest* DsKvRawGetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetRequest.req)
  
  ::kvrpcpb::KvRawGetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawGetRequest::set_allocated_req(::kvrpcpb::KvRawGetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawGetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawGetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawGetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawGetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawGetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawGetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawGetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetResponse.header)
}

// .kvrpcpb.KvRawGetResponse resp = 2;
inline bool DsKvRawGetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawGetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawGetResponse& DsKvRawGetResponse::resp() const {
  const ::kvrpcpb::KvRawGetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawGetResponse*>(
      &::kvrpcpb::_KvRawGetResponse_default_instance_);
}
inline ::kvrpcpb::KvRawGetResponse* DsKvRawGetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawGetResponse* DsKvRawGetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetResponse.resp)
  
  ::kvrpcpb::KvRawGetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawGetResponse::set_allocated_resp(::kvrpcpb::KvRawGetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetResponse.resp)
}

// -------------------------------------------------------------------

// KvRawGetRequest

// bytes key = 1;
inline void KvRawGetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawGetRequest.key)
  return key_.GetNoArena();
}
inline void KvRawGetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawGetRequest.key)
}
#if LANG_CXX11
inline void KvRawGetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawGetRequest.key)
}
#endif
inline void KvRawGetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawGetRequest.key)
}
inline void KvRawGetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawGetRequest.key)
}
inline ::std::string* KvRawGetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawGetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawGetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawGetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawGetRequest.key)
}

// -------------------------------------------------------------------

// KvRawGetResponse

// int32 code = 1;
inline void KvRawGetResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawGetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawGetResponse.code)
  return code_;
}
inline void KvRawGetResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawGetResponse.code)
}

// bytes value = 2;
inline void KvRawGetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawGetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawGetResponse.value)
  return value_.GetNoArena();
}
inline void KvRawGetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawGetResponse.value)
}
#if LANG_CXX11
inline void KvRawGetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawGetResponse.value)
}
#endif
inline void KvRawGetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawGetResponse.value)
}
inline void KvRawGetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawGetResponse.value)
}
inline ::std::string* KvRawGetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawGetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawGetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawGetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawGetResponse.value)
}

// -------------------------------------------------------------------

// DsKvRawPutRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawPutRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawPutRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawPutRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawPutRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawPutRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawPutRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutRequest.header)
}

// .kvrpcpb.KvRawPutRequest req = 2;
inline bool DsKvRawPutRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawPutRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawPutRequest& DsKvRawPutRequest::req() const {
  const ::kvrpcpb::KvRawPutRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawPutRequest*>(
      &::kvrpcpb::_KvRawPutRequest_default_instance_);
}
inline ::kvrpcpb::KvRawPutRequest* DsKvRawPutRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawPutRequest* DsKvRawPutRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutRequest.req)
  
  ::kvrpcpb::KvRawPutRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawPutRequest::set_allocated_req(::kvrpcpb::KvRawPutRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawPutResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawPutResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawPutResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawPutResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawPutResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawPutResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawPutResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutResponse.header)
}

// .kvrpcpb.KvRawPutResponse resp = 2;
inline bool DsKvRawPutResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawPutResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawPutResponse& DsKvRawPutResponse::resp() const {
  const ::kvrpcpb::KvRawPutResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawPutResponse*>(
      &::kvrpcpb::_KvRawPutResponse_default_instance_);
}
inline ::kvrpcpb::KvRawPutResponse* DsKvRawPutResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawPutResponse* DsKvRawPutResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutResponse.resp)
  
  ::kvrpcpb::KvRawPutResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawPutResponse::set_allocated_resp(::kvrpcpb::KvRawPutResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutResponse.resp)
}

// -------------------------------------------------------------------

// KvRawPutRequest

// bytes key = 1;
inline void KvRawPutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawPutRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawPutRequest.key)
  return key_.GetNoArena();
}
inline void KvRawPutRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawPutRequest.key)
}
#if LANG_CXX11
inline void KvRawPutRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawPutRequest.key)
}
#endif
inline void KvRawPutRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawPutRequest.key)
}
inline void KvRawPutRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawPutRequest.key)
}
inline ::std::string* KvRawPutRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawPutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawPutRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawPutRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawPutRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawPutRequest.key)
}

// bytes value = 2;
inline void KvRawPutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawPutRequest::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawPutRequest.value)
  return value_.GetNoArena();
}
inline void KvRawPutRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawPutRequest.value)
}
#if LANG_CXX11
inline void KvRawPutRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawPutRequest.value)
}
#endif
inline void KvRawPutRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawPutRequest.value)
}
inline void KvRawPutRequest::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawPutRequest.value)
}
inline ::std::string* KvRawPutRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawPutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawPutRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawPutRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawPutRequest.value)
}

// -------------------------------------------------------------------

// KvRawPutResponse

// int32 code = 1;
inline void KvRawPutResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawPutResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawPutResponse.code)
  return code_;
}
inline void KvRawPutResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawPutResponse.code)
}

// -------------------------------------------------------------------

// DsKvRawDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteRequest.header)
}

// .kvrpcpb.KvRawDeleteRequest req = 2;
inline bool DsKvRawDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawDeleteRequest& DsKvRawDeleteRequest::req() const {
  const ::kvrpcpb::KvRawDeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawDeleteRequest*>(
      &::kvrpcpb::_KvRawDeleteRequest_default_instance_);
}
inline ::kvrpcpb::KvRawDeleteRequest* DsKvRawDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawDeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawDeleteRequest* DsKvRawDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteRequest.req)
  
  ::kvrpcpb::KvRawDeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawDeleteRequest::set_allocated_req(::kvrpcpb::KvRawDeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteResponse.header)
}

// .kvrpcpb.KvRawDeleteResponse resp = 2;
inline bool DsKvRawDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawDeleteResponse& DsKvRawDeleteResponse::resp() const {
  const ::kvrpcpb::KvRawDeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawDeleteResponse*>(
      &::kvrpcpb::_KvRawDeleteResponse_default_instance_);
}
inline ::kvrpcpb::KvRawDeleteResponse* DsKvRawDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawDeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawDeleteResponse* DsKvRawDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteResponse.resp)
  
  ::kvrpcpb::KvRawDeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawDeleteResponse::set_allocated_resp(::kvrpcpb::KvRawDeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteResponse.resp)
}

// -------------------------------------------------------------------

// KvRawDeleteRequest

// bytes key = 1;
inline void KvRawDeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawDeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawDeleteRequest.key)
  return key_.GetNoArena();
}
inline void KvRawDeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawDeleteRequest.key)
}
#if LANG_CXX11
inline void KvRawDeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawDeleteRequest.key)
}
#endif
inline void KvRawDeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawDeleteRequest.key)
}
inline void KvRawDeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawDeleteRequest.key)
}
inline ::std::string* KvRawDeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawDeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawDeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawDeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawDeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawDeleteRequest.key)
}

// -------------------------------------------------------------------

// KvRawDeleteResponse

// int32 code = 1;
inline void KvRawDeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawDeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawDeleteResponse.code)
  return code_;
}
inline void KvRawDeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawDeleteResponse.code)
}

// -------------------------------------------------------------------

// KvPairRawExecute

// .kvrpcpb.ExecuteType do = 1;
inline void KvPairRawExecute::clear_do_() {
  do__ = 0;
}
inline ::kvrpcpb::ExecuteType KvPairRawExecute::do_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPairRawExecute.do)
  return static_cast< ::kvrpcpb::ExecuteType >(do__);
}
inline void KvPairRawExecute::set_do_(::kvrpcpb::ExecuteType value) {
  
  do__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPairRawExecute.do)
}

// .kvrpcpb.KvPair kv_pair = 2;
inline bool KvPairRawExecute::has_kv_pair() const {
  return this != internal_default_instance() && kv_pair_ != NULL;
}
inline void KvPairRawExecute::clear_kv_pair() {
  if (GetArenaNoVirtual() == NULL && kv_pair_ != NULL) delete kv_pair_;
  kv_pair_ = NULL;
}
inline const ::kvrpcpb::KvPair& KvPairRawExecute::kv_pair() const {
  const ::kvrpcpb::KvPair* p = kv_pair_;
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPairRawExecute.kv_pair)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvPair*>(
      &::kvrpcpb::_KvPair_default_instance_);
}
inline ::kvrpcpb::KvPair* KvPairRawExecute::mutable_kv_pair() {
  
  if (kv_pair_ == NULL) {
    kv_pair_ = new ::kvrpcpb::KvPair;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPairRawExecute.kv_pair)
  return kv_pair_;
}
inline ::kvrpcpb::KvPair* KvPairRawExecute::release_kv_pair() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPairRawExecute.kv_pair)
  
  ::kvrpcpb::KvPair* temp = kv_pair_;
  kv_pair_ = NULL;
  return temp;
}
inline void KvPairRawExecute::set_allocated_kv_pair(::kvrpcpb::KvPair* kv_pair) {
  delete kv_pair_;
  kv_pair_ = kv_pair;
  if (kv_pair) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPairRawExecute.kv_pair)
}

// -------------------------------------------------------------------

// DsKvRawExecuteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawExecuteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawExecuteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawExecuteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawExecuteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawExecuteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawExecuteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteRequest.header)
}

// .kvrpcpb.KvRawExecuteRequest req = 2;
inline bool DsKvRawExecuteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawExecuteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawExecuteRequest& DsKvRawExecuteRequest::req() const {
  const ::kvrpcpb::KvRawExecuteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawExecuteRequest*>(
      &::kvrpcpb::_KvRawExecuteRequest_default_instance_);
}
inline ::kvrpcpb::KvRawExecuteRequest* DsKvRawExecuteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawExecuteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawExecuteRequest* DsKvRawExecuteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteRequest.req)
  
  ::kvrpcpb::KvRawExecuteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawExecuteRequest::set_allocated_req(::kvrpcpb::KvRawExecuteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawExecuteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawExecuteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawExecuteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawExecuteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawExecuteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawExecuteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawExecuteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteResponse.header)
}

// .kvrpcpb.KvRawExecuteResponse resp = 2;
inline bool DsKvRawExecuteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawExecuteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawExecuteResponse& DsKvRawExecuteResponse::resp() const {
  const ::kvrpcpb::KvRawExecuteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawExecuteResponse*>(
      &::kvrpcpb::_KvRawExecuteResponse_default_instance_);
}
inline ::kvrpcpb::KvRawExecuteResponse* DsKvRawExecuteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawExecuteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawExecuteResponse* DsKvRawExecuteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteResponse.resp)
  
  ::kvrpcpb::KvRawExecuteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawExecuteResponse::set_allocated_resp(::kvrpcpb::KvRawExecuteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteResponse.resp)
}

// -------------------------------------------------------------------

// KvRawExecuteRequest

// repeated .kvrpcpb.KvPairRawExecute execs = 1;
inline int KvRawExecuteRequest::execs_size() const {
  return execs_.size();
}
inline void KvRawExecuteRequest::clear_execs() {
  execs_.Clear();
}
inline const ::kvrpcpb::KvPairRawExecute& KvRawExecuteRequest::execs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_.Get(index);
}
inline ::kvrpcpb::KvPairRawExecute* KvRawExecuteRequest::mutable_execs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_.Mutable(index);
}
inline ::kvrpcpb::KvPairRawExecute* KvRawExecuteRequest::add_execs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >*
KvRawExecuteRequest::mutable_execs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvRawExecuteRequest.execs)
  return &execs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >&
KvRawExecuteRequest::execs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_;
}

// -------------------------------------------------------------------

// KvRawExecuteResponse

// int32 code = 1;
inline void KvRawExecuteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawExecuteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawExecuteResponse.code)
  return code_;
}
inline void KvRawExecuteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawExecuteResponse.code)
}

// -------------------------------------------------------------------

// Scope

// bytes start = 1;
inline void Scope::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scope::start() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Scope.start)
  return start_.GetNoArena();
}
inline void Scope::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Scope.start)
}
#if LANG_CXX11
inline void Scope::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Scope.start)
}
#endif
inline void Scope::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Scope.start)
}
inline void Scope::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Scope.start)
}
inline ::std::string* Scope::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Scope.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scope::release_start() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Scope.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scope::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Scope.start)
}

// bytes limit = 2;
inline void Scope::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scope::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Scope.limit)
  return limit_.GetNoArena();
}
inline void Scope::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Scope.limit)
}
#if LANG_CXX11
inline void Scope::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Scope.limit)
}
#endif
inline void Scope::set_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Scope.limit)
}
inline void Scope::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Scope.limit)
}
inline ::std::string* Scope::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Scope.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scope::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Scope.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scope::set_allocated_limit(::std::string* limit) {
  if (limit != NULL) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Scope.limit)
}

// -------------------------------------------------------------------

// SelectField

// .kvrpcpb.SelectField.Type typ = 1;
inline void SelectField::clear_typ() {
  typ_ = 0;
}
inline ::kvrpcpb::SelectField_Type SelectField::typ() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectField.typ)
  return static_cast< ::kvrpcpb::SelectField_Type >(typ_);
}
inline void SelectField::set_typ(::kvrpcpb::SelectField_Type value) {
  
  typ_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectField.typ)
}

// string aggre_func = 2;
inline void SelectField::clear_aggre_func() {
  aggre_func_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectField::aggre_func() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectField.aggre_func)
  return aggre_func_.GetNoArena();
}
inline void SelectField::set_aggre_func(const ::std::string& value) {
  
  aggre_func_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectField.aggre_func)
}
#if LANG_CXX11
inline void SelectField::set_aggre_func(::std::string&& value) {
  
  aggre_func_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.SelectField.aggre_func)
}
#endif
inline void SelectField::set_aggre_func(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  aggre_func_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.SelectField.aggre_func)
}
inline void SelectField::set_aggre_func(const char* value, size_t size) {
  
  aggre_func_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.SelectField.aggre_func)
}
inline ::std::string* SelectField::mutable_aggre_func() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectField.aggre_func)
  return aggre_func_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectField::release_aggre_func() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectField.aggre_func)
  
  return aggre_func_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectField::set_allocated_aggre_func(::std::string* aggre_func) {
  if (aggre_func != NULL) {
    
  } else {
    
  }
  aggre_func_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), aggre_func);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectField.aggre_func)
}

// .metapb.Column column = 3;
inline bool SelectField::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void SelectField::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& SelectField::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectField.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* SelectField::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectField.column)
  return column_;
}
inline ::metapb::Column* SelectField::release_column() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectField.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void SelectField::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectField.column)
}

// -------------------------------------------------------------------

// Match

// .metapb.Column column = 1;
inline bool Match::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void Match::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& Match::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:kvrpcpb.Match.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* Match::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Match.column)
  return column_;
}
inline ::metapb::Column* Match::release_column() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Match.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void Match::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Match.column)
}

// bytes threshold = 2;
inline void Match::clear_threshold() {
  threshold_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Match::threshold() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Match.threshold)
  return threshold_.GetNoArena();
}
inline void Match::set_threshold(const ::std::string& value) {
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Match.threshold)
}
#if LANG_CXX11
inline void Match::set_threshold(::std::string&& value) {
  
  threshold_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Match.threshold)
}
#endif
inline void Match::set_threshold(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Match.threshold)
}
inline void Match::set_threshold(const void* value, size_t size) {
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Match.threshold)
}
inline ::std::string* Match::mutable_threshold() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Match.threshold)
  return threshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Match::release_threshold() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Match.threshold)
  
  return threshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Match::set_allocated_threshold(::std::string* threshold) {
  if (threshold != NULL) {
    
  } else {
    
  }
  threshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), threshold);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Match.threshold)
}

// .kvrpcpb.MatchType match_type = 3;
inline void Match::clear_match_type() {
  match_type_ = 0;
}
inline ::kvrpcpb::MatchType Match::match_type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Match.match_type)
  return static_cast< ::kvrpcpb::MatchType >(match_type_);
}
inline void Match::set_match_type(::kvrpcpb::MatchType value) {
  
  match_type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Match.match_type)
}

// -------------------------------------------------------------------

// Limit

// uint64 offset = 1;
inline void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Limit.offset)
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Limit.offset)
}

// uint64 count = 2;
inline void Limit::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Limit::count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Limit.count)
  return count_;
}
inline void Limit::set_count(::google::protobuf::uint64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Limit.count)
}

// -------------------------------------------------------------------

// DsSelectRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsSelectRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsSelectRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsSelectRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsSelectRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsSelectRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsSelectRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectRequest.header)
}

// .kvrpcpb.SelectRequest req = 2;
inline bool DsSelectRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsSelectRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::SelectRequest& DsSelectRequest::req() const {
  const ::kvrpcpb::SelectRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::SelectRequest*>(
      &::kvrpcpb::_SelectRequest_default_instance_);
}
inline ::kvrpcpb::SelectRequest* DsSelectRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::SelectRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectRequest.req)
  return req_;
}
inline ::kvrpcpb::SelectRequest* DsSelectRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectRequest.req)
  
  ::kvrpcpb::SelectRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsSelectRequest::set_allocated_req(::kvrpcpb::SelectRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectRequest.req)
}

// -------------------------------------------------------------------

// SelectRequest

// bytes key = 1;
inline void SelectRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.key)
  return key_.GetNoArena();
}
inline void SelectRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectRequest.key)
}
#if LANG_CXX11
inline void SelectRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.SelectRequest.key)
}
#endif
inline void SelectRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.SelectRequest.key)
}
inline void SelectRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.SelectRequest.key)
}
inline ::std::string* SelectRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool SelectRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void SelectRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& SelectRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* SelectRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* SelectRequest::release_scope() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.scope)
}

// repeated .kvrpcpb.SelectField field_list = 3;
inline int SelectRequest::field_list_size() const {
  return field_list_.size();
}
inline void SelectRequest::clear_field_list() {
  field_list_.Clear();
}
inline const ::kvrpcpb::SelectField& SelectRequest::field_list(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.field_list)
  return field_list_.Get(index);
}
inline ::kvrpcpb::SelectField* SelectRequest::mutable_field_list(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.field_list)
  return field_list_.Mutable(index);
}
inline ::kvrpcpb::SelectField* SelectRequest::add_field_list() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectRequest.field_list)
  return field_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >*
SelectRequest::mutable_field_list() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectRequest.field_list)
  return &field_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >&
SelectRequest::field_list() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectRequest.field_list)
  return field_list_;
}

// repeated .kvrpcpb.Match where_filters = 4;
inline int SelectRequest::where_filters_size() const {
  return where_filters_.size();
}
inline void SelectRequest::clear_where_filters() {
  where_filters_.Clear();
}
inline const ::kvrpcpb::Match& SelectRequest::where_filters(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.where_filters)
  return where_filters_.Get(index);
}
inline ::kvrpcpb::Match* SelectRequest::mutable_where_filters(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.where_filters)
  return where_filters_.Mutable(index);
}
inline ::kvrpcpb::Match* SelectRequest::add_where_filters() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectRequest.where_filters)
  return where_filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
SelectRequest::mutable_where_filters() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectRequest.where_filters)
  return &where_filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
SelectRequest::where_filters() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectRequest.where_filters)
  return where_filters_;
}

// repeated .metapb.Column group_bys = 5;
inline int SelectRequest::group_bys_size() const {
  return group_bys_.size();
}
inline void SelectRequest::clear_group_bys() {
  group_bys_.Clear();
}
inline const ::metapb::Column& SelectRequest::group_bys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.group_bys)
  return group_bys_.Get(index);
}
inline ::metapb::Column* SelectRequest::mutable_group_bys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.group_bys)
  return group_bys_.Mutable(index);
}
inline ::metapb::Column* SelectRequest::add_group_bys() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectRequest.group_bys)
  return group_bys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
SelectRequest::mutable_group_bys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectRequest.group_bys)
  return &group_bys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
SelectRequest::group_bys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectRequest.group_bys)
  return group_bys_;
}

// .kvrpcpb.Limit limit = 6;
inline bool SelectRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void SelectRequest::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) delete limit_;
  limit_ = NULL;
}
inline const ::kvrpcpb::Limit& SelectRequest::limit() const {
  const ::kvrpcpb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Limit*>(
      &::kvrpcpb::_Limit_default_instance_);
}
inline ::kvrpcpb::Limit* SelectRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    limit_ = new ::kvrpcpb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.limit)
  return limit_;
}
inline ::kvrpcpb::Limit* SelectRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.limit)
  
  ::kvrpcpb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_limit(::kvrpcpb::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.limit)
}

// .timestamp.Timestamp timestamp = 7;
inline bool SelectRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void SelectRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& SelectRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* SelectRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* SelectRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.timestamp)
}

// -------------------------------------------------------------------

// Row

// bytes key = 1;
inline void Row::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Row::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Row.key)
  return key_.GetNoArena();
}
inline void Row::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Row.key)
}
#if LANG_CXX11
inline void Row::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Row.key)
}
#endif
inline void Row::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Row.key)
}
inline void Row::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Row.key)
}
inline ::std::string* Row::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Row.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Row::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Row.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Row::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Row.key)
}

// bytes fields = 2;
inline void Row::clear_fields() {
  fields_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Row::fields() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Row.fields)
  return fields_.GetNoArena();
}
inline void Row::set_fields(const ::std::string& value) {
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Row.fields)
}
#if LANG_CXX11
inline void Row::set_fields(::std::string&& value) {
  
  fields_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Row.fields)
}
#endif
inline void Row::set_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Row.fields)
}
inline void Row::set_fields(const void* value, size_t size) {
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Row.fields)
}
inline ::std::string* Row::mutable_fields() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Row.fields)
  return fields_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Row::release_fields() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Row.fields)
  
  return fields_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Row::set_allocated_fields(::std::string* fields) {
  if (fields != NULL) {
    
  } else {
    
  }
  fields_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fields);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Row.fields)
}

// repeated int64 aggred_counts = 3;
inline int Row::aggred_counts_size() const {
  return aggred_counts_.size();
}
inline void Row::clear_aggred_counts() {
  aggred_counts_.Clear();
}
inline ::google::protobuf::int64 Row::aggred_counts(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Row.aggred_counts)
  return aggred_counts_.Get(index);
}
inline void Row::set_aggred_counts(int index, ::google::protobuf::int64 value) {
  aggred_counts_.Set(index, value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Row.aggred_counts)
}
inline void Row::add_aggred_counts(::google::protobuf::int64 value) {
  aggred_counts_.Add(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.Row.aggred_counts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Row::aggred_counts() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.Row.aggred_counts)
  return aggred_counts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Row::mutable_aggred_counts() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.Row.aggred_counts)
  return &aggred_counts_;
}

// -------------------------------------------------------------------

// DsSelectResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsSelectResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsSelectResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsSelectResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsSelectResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsSelectResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsSelectResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectResponse.header)
}

// .kvrpcpb.SelectResponse resp = 2;
inline bool DsSelectResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsSelectResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::SelectResponse& DsSelectResponse::resp() const {
  const ::kvrpcpb::SelectResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::SelectResponse*>(
      &::kvrpcpb::_SelectResponse_default_instance_);
}
inline ::kvrpcpb::SelectResponse* DsSelectResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::SelectResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectResponse.resp)
  return resp_;
}
inline ::kvrpcpb::SelectResponse* DsSelectResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectResponse.resp)
  
  ::kvrpcpb::SelectResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsSelectResponse::set_allocated_resp(::kvrpcpb::SelectResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectResponse.resp)
}

// -------------------------------------------------------------------

// SelectResponse

// int32 code = 1;
inline void SelectResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 SelectResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectResponse.code)
  return code_;
}
inline void SelectResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectResponse.code)
}

// repeated .kvrpcpb.Row rows = 2;
inline int SelectResponse::rows_size() const {
  return rows_.size();
}
inline void SelectResponse::clear_rows() {
  rows_.Clear();
}
inline const ::kvrpcpb::Row& SelectResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectResponse.rows)
  return rows_.Get(index);
}
inline ::kvrpcpb::Row* SelectResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectResponse.rows)
  return rows_.Mutable(index);
}
inline ::kvrpcpb::Row* SelectResponse::add_rows() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectResponse.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >*
SelectResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectResponse.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >&
SelectResponse::rows() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectResponse.rows)
  return rows_;
}

// uint64 offset = 3;
inline void SelectResponse::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SelectResponse::offset() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectResponse.offset)
  return offset_;
}
inline void SelectResponse::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectResponse.offset)
}

// -------------------------------------------------------------------

// KeyValue

// bytes Key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyValue.Key)
  return key_.GetNoArena();
}
inline void KeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyValue.Key)
}
#if LANG_CXX11
inline void KeyValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyValue.Key)
}
#endif
inline void KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyValue.Key)
}
inline void KeyValue::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyValue.Key)
}
inline ::std::string* KeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyValue.Key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyValue.Key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyValue.Key)
}

// bytes Value = 2;
inline void KeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyValue.Value)
  return value_.GetNoArena();
}
inline void KeyValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyValue.Value)
}
#if LANG_CXX11
inline void KeyValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyValue.Value)
}
#endif
inline void KeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyValue.Value)
}
inline void KeyValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyValue.Value)
}
inline ::std::string* KeyValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyValue.Value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyValue.Value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyValue.Value)
}

// int64 ExpireAt = 3;
inline void KeyValue::clear_expireat() {
  expireat_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KeyValue::expireat() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyValue.ExpireAt)
  return expireat_;
}
inline void KeyValue::set_expireat(::google::protobuf::int64 value) {
  
  expireat_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyValue.ExpireAt)
}

// -------------------------------------------------------------------

// DsInsertRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsInsertRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsInsertRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsInsertRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsInsertRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsInsertRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsInsertRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertRequest.header)
}

// .kvrpcpb.InsertRequest req = 2;
inline bool DsInsertRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsInsertRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::InsertRequest& DsInsertRequest::req() const {
  const ::kvrpcpb::InsertRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::InsertRequest*>(
      &::kvrpcpb::_InsertRequest_default_instance_);
}
inline ::kvrpcpb::InsertRequest* DsInsertRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::InsertRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertRequest.req)
  return req_;
}
inline ::kvrpcpb::InsertRequest* DsInsertRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertRequest.req)
  
  ::kvrpcpb::InsertRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsInsertRequest::set_allocated_req(::kvrpcpb::InsertRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertRequest.req)
}

// -------------------------------------------------------------------

// DsInsertResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsInsertResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsInsertResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsInsertResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsInsertResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsInsertResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsInsertResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertResponse.header)
}

// .kvrpcpb.InsertResponse resp = 2;
inline bool DsInsertResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsInsertResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::InsertResponse& DsInsertResponse::resp() const {
  const ::kvrpcpb::InsertResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::InsertResponse*>(
      &::kvrpcpb::_InsertResponse_default_instance_);
}
inline ::kvrpcpb::InsertResponse* DsInsertResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::InsertResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertResponse.resp)
  return resp_;
}
inline ::kvrpcpb::InsertResponse* DsInsertResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertResponse.resp)
  
  ::kvrpcpb::InsertResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsInsertResponse::set_allocated_resp(::kvrpcpb::InsertResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertResponse.resp)
}

// -------------------------------------------------------------------

// InsertRequest

// repeated .kvrpcpb.KeyValue rows = 1;
inline int InsertRequest::rows_size() const {
  return rows_.size();
}
inline void InsertRequest::clear_rows() {
  rows_.Clear();
}
inline const ::kvrpcpb::KeyValue& InsertRequest::rows(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertRequest.rows)
  return rows_.Get(index);
}
inline ::kvrpcpb::KeyValue* InsertRequest::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.InsertRequest.rows)
  return rows_.Mutable(index);
}
inline ::kvrpcpb::KeyValue* InsertRequest::add_rows() {
  // @@protoc_insertion_point(field_add:kvrpcpb.InsertRequest.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >*
InsertRequest::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.InsertRequest.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >&
InsertRequest::rows() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.InsertRequest.rows)
  return rows_;
}

// bool check_duplicate = 2;
inline void InsertRequest::clear_check_duplicate() {
  check_duplicate_ = false;
}
inline bool InsertRequest::check_duplicate() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertRequest.check_duplicate)
  return check_duplicate_;
}
inline void InsertRequest::set_check_duplicate(bool value) {
  
  check_duplicate_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertRequest.check_duplicate)
}

// .timestamp.Timestamp timestamp = 3;
inline bool InsertRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void InsertRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& InsertRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* InsertRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.InsertRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* InsertRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.InsertRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void InsertRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.InsertRequest.timestamp)
}

// -------------------------------------------------------------------

// InsertResponse

// int32 code = 1;
inline void InsertResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 InsertResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertResponse.code)
  return code_;
}
inline void InsertResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertResponse.code)
}

// uint64 affected_keys = 2;
inline void InsertResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InsertResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertResponse.affected_keys)
  return affected_keys_;
}
inline void InsertResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertResponse.affected_keys)
}

// bytes duplicate_key = 3;
inline void InsertResponse::clear_duplicate_key() {
  duplicate_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InsertResponse::duplicate_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertResponse.duplicate_key)
  return duplicate_key_.GetNoArena();
}
inline void InsertResponse::set_duplicate_key(const ::std::string& value) {
  
  duplicate_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertResponse.duplicate_key)
}
#if LANG_CXX11
inline void InsertResponse::set_duplicate_key(::std::string&& value) {
  
  duplicate_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.InsertResponse.duplicate_key)
}
#endif
inline void InsertResponse::set_duplicate_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  duplicate_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.InsertResponse.duplicate_key)
}
inline void InsertResponse::set_duplicate_key(const void* value, size_t size) {
  
  duplicate_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.InsertResponse.duplicate_key)
}
inline ::std::string* InsertResponse::mutable_duplicate_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.InsertResponse.duplicate_key)
  return duplicate_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InsertResponse::release_duplicate_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.InsertResponse.duplicate_key)
  
  return duplicate_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InsertResponse::set_allocated_duplicate_key(::std::string* duplicate_key) {
  if (duplicate_key != NULL) {
    
  } else {
    
  }
  duplicate_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duplicate_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.InsertResponse.duplicate_key)
}

// -------------------------------------------------------------------

// BatchInsertRequest

// repeated .kvrpcpb.InsertRequest reqs = 1;
inline int BatchInsertRequest::reqs_size() const {
  return reqs_.size();
}
inline void BatchInsertRequest::clear_reqs() {
  reqs_.Clear();
}
inline const ::kvrpcpb::InsertRequest& BatchInsertRequest::reqs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_.Get(index);
}
inline ::kvrpcpb::InsertRequest* BatchInsertRequest::mutable_reqs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_.Mutable(index);
}
inline ::kvrpcpb::InsertRequest* BatchInsertRequest::add_reqs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >*
BatchInsertRequest::mutable_reqs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchInsertRequest.reqs)
  return &reqs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >&
BatchInsertRequest::reqs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_;
}

// -------------------------------------------------------------------

// BatchInsertResponse

// repeated .kvrpcpb.InsertResponse resps = 2;
inline int BatchInsertResponse::resps_size() const {
  return resps_.size();
}
inline void BatchInsertResponse::clear_resps() {
  resps_.Clear();
}
inline const ::kvrpcpb::InsertResponse& BatchInsertResponse::resps(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchInsertResponse.resps)
  return resps_.Get(index);
}
inline ::kvrpcpb::InsertResponse* BatchInsertResponse::mutable_resps(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchInsertResponse.resps)
  return resps_.Mutable(index);
}
inline ::kvrpcpb::InsertResponse* BatchInsertResponse::add_resps() {
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchInsertResponse.resps)
  return resps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >*
BatchInsertResponse::mutable_resps() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchInsertResponse.resps)
  return &resps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >&
BatchInsertResponse::resps() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchInsertResponse.resps)
  return resps_;
}

// -------------------------------------------------------------------

// DsDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteRequest.header)
}

// .kvrpcpb.DeleteRequest req = 2;
inline bool DsDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::DeleteRequest& DsDeleteRequest::req() const {
  const ::kvrpcpb::DeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::DeleteRequest*>(
      &::kvrpcpb::_DeleteRequest_default_instance_);
}
inline ::kvrpcpb::DeleteRequest* DsDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::DeleteRequest* DsDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteRequest.req)
  
  ::kvrpcpb::DeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsDeleteRequest::set_allocated_req(::kvrpcpb::DeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteResponse.header)
}

// .kvrpcpb.DeleteResponse resp = 2;
inline bool DsDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::DeleteResponse& DsDeleteResponse::resp() const {
  const ::kvrpcpb::DeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::DeleteResponse*>(
      &::kvrpcpb::_DeleteResponse_default_instance_);
}
inline ::kvrpcpb::DeleteResponse* DsDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::DeleteResponse* DsDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteResponse.resp)
  
  ::kvrpcpb::DeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsDeleteResponse::set_allocated_resp(::kvrpcpb::DeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteResponse.resp)
}

// -------------------------------------------------------------------

// DeleteRequest

// bytes key = 1;
inline void DeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.key)
  return key_.GetNoArena();
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRequest.key)
}
#if LANG_CXX11
inline void DeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.DeleteRequest.key)
}
#endif
inline void DeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.DeleteRequest.key)
}
inline ::std::string* DeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool DeleteRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void DeleteRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& DeleteRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* DeleteRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* DeleteRequest::release_scope() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void DeleteRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRequest.scope)
}

// repeated .kvrpcpb.Match where_filters = 3;
inline int DeleteRequest::where_filters_size() const {
  return where_filters_.size();
}
inline void DeleteRequest::clear_where_filters() {
  where_filters_.Clear();
}
inline const ::kvrpcpb::Match& DeleteRequest::where_filters(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_.Get(index);
}
inline ::kvrpcpb::Match* DeleteRequest::mutable_where_filters(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_.Mutable(index);
}
inline ::kvrpcpb::Match* DeleteRequest::add_where_filters() {
  // @@protoc_insertion_point(field_add:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
DeleteRequest::mutable_where_filters() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.DeleteRequest.where_filters)
  return &where_filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
DeleteRequest::where_filters() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_;
}

// repeated uint64 indexs = 4;
inline int DeleteRequest::indexs_size() const {
  return indexs_.size();
}
inline void DeleteRequest::clear_indexs() {
  indexs_.Clear();
}
inline ::google::protobuf::uint64 DeleteRequest::indexs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.indexs)
  return indexs_.Get(index);
}
inline void DeleteRequest::set_indexs(int index, ::google::protobuf::uint64 value) {
  indexs_.Set(index, value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRequest.indexs)
}
inline void DeleteRequest::add_indexs(::google::protobuf::uint64 value) {
  indexs_.Add(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.DeleteRequest.indexs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DeleteRequest::indexs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.DeleteRequest.indexs)
  return indexs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DeleteRequest::mutable_indexs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.DeleteRequest.indexs)
  return &indexs_;
}

// .timestamp.Timestamp timestamp = 10;
inline bool DeleteRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void DeleteRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& DeleteRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* DeleteRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* DeleteRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void DeleteRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRequest.timestamp)
}

// -------------------------------------------------------------------

// DeleteResponse

// int32 code = 1;
inline void DeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 DeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteResponse.code)
  return code_;
}
inline void DeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteResponse.code)
}

// uint64 affected_keys = 2;
inline void DeleteResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DeleteResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteResponse.affected_keys)
  return affected_keys_;
}
inline void DeleteResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteResponse.affected_keys)
}

// -------------------------------------------------------------------

// Field

// uint64 column_id = 1;
inline void Field::clear_column_id() {
  column_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Field::column_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Field.column_id)
  return column_id_;
}
inline void Field::set_column_id(::google::protobuf::uint64 value) {
  
  column_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Field.column_id)
}

// bytes value = 2;
inline void Field::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Field.value)
  return value_.GetNoArena();
}
inline void Field::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Field.value)
}
#if LANG_CXX11
inline void Field::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Field.value)
}
#endif
inline void Field::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Field.value)
}
inline void Field::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Field.value)
}
inline ::std::string* Field::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Field.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Field.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Field.value)
}

// -------------------------------------------------------------------

// RedisKeyValue

// bytes key = 1;
inline void RedisKeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RedisKeyValue::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RedisKeyValue.key)
  return key_.GetNoArena();
}
inline void RedisKeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RedisKeyValue.key)
}
#if LANG_CXX11
inline void RedisKeyValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RedisKeyValue.key)
}
#endif
inline void RedisKeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RedisKeyValue.key)
}
inline void RedisKeyValue::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RedisKeyValue.key)
}
inline ::std::string* RedisKeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RedisKeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisKeyValue::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RedisKeyValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisKeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RedisKeyValue.key)
}

// bytes value = 2;
inline void RedisKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RedisKeyValue::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RedisKeyValue.value)
  return value_.GetNoArena();
}
inline void RedisKeyValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RedisKeyValue.value)
}
#if LANG_CXX11
inline void RedisKeyValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RedisKeyValue.value)
}
#endif
inline void RedisKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RedisKeyValue.value)
}
inline void RedisKeyValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RedisKeyValue.value)
}
inline ::std::string* RedisKeyValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RedisKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RedisKeyValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisKeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RedisKeyValue.value)
}

// -------------------------------------------------------------------

// RedisDo

// bytes key = 1;
inline void RedisDo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RedisDo::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RedisDo.key)
  return key_.GetNoArena();
}
inline void RedisDo::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RedisDo.key)
}
#if LANG_CXX11
inline void RedisDo::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RedisDo.key)
}
#endif
inline void RedisDo::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RedisDo.key)
}
inline void RedisDo::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RedisDo.key)
}
inline ::std::string* RedisDo::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RedisDo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisDo::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RedisDo.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisDo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RedisDo.key)
}

// bytes value = 2;
inline void RedisDo::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RedisDo::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RedisDo.value)
  return value_.GetNoArena();
}
inline void RedisDo::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RedisDo.value)
}
#if LANG_CXX11
inline void RedisDo::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RedisDo.value)
}
#endif
inline void RedisDo::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RedisDo.value)
}
inline void RedisDo::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RedisDo.value)
}
inline ::std::string* RedisDo::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RedisDo.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisDo::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RedisDo.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisDo::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RedisDo.value)
}

// .kvrpcpb.Operation op = 3;
inline void RedisDo::clear_op() {
  op_ = 0;
}
inline ::kvrpcpb::Operation RedisDo::op() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RedisDo.op)
  return static_cast< ::kvrpcpb::Operation >(op_);
}
inline void RedisDo::set_op(::kvrpcpb::Operation value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RedisDo.op)
}

// .kvrpcpb.ExistCase case = 4;
inline void RedisDo::clear_case_() {
  case__ = 0;
}
inline ::kvrpcpb::ExistCase RedisDo::case_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RedisDo.case)
  return static_cast< ::kvrpcpb::ExistCase >(case__);
}
inline void RedisDo::set_case_(::kvrpcpb::ExistCase value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RedisDo.case)
}

// -------------------------------------------------------------------

// KvSetRequest

// .kvrpcpb.RedisKeyValue kv = 1;
inline bool KvSetRequest::has_kv() const {
  return this != internal_default_instance() && kv_ != NULL;
}
inline void KvSetRequest::clear_kv() {
  if (GetArenaNoVirtual() == NULL && kv_ != NULL) delete kv_;
  kv_ = NULL;
}
inline const ::kvrpcpb::RedisKeyValue& KvSetRequest::kv() const {
  const ::kvrpcpb::RedisKeyValue* p = kv_;
  // @@protoc_insertion_point(field_get:kvrpcpb.KvSetRequest.kv)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RedisKeyValue*>(
      &::kvrpcpb::_RedisKeyValue_default_instance_);
}
inline ::kvrpcpb::RedisKeyValue* KvSetRequest::mutable_kv() {
  
  if (kv_ == NULL) {
    kv_ = new ::kvrpcpb::RedisKeyValue;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvSetRequest.kv)
  return kv_;
}
inline ::kvrpcpb::RedisKeyValue* KvSetRequest::release_kv() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvSetRequest.kv)
  
  ::kvrpcpb::RedisKeyValue* temp = kv_;
  kv_ = NULL;
  return temp;
}
inline void KvSetRequest::set_allocated_kv(::kvrpcpb::RedisKeyValue* kv) {
  delete kv_;
  kv_ = kv;
  if (kv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvSetRequest.kv)
}

// .kvrpcpb.ExistCase case = 2;
inline void KvSetRequest::clear_case_() {
  case__ = 0;
}
inline ::kvrpcpb::ExistCase KvSetRequest::case_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvSetRequest.case)
  return static_cast< ::kvrpcpb::ExistCase >(case__);
}
inline void KvSetRequest::set_case_(::kvrpcpb::ExistCase value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvSetRequest.case)
}

// -------------------------------------------------------------------

// KvSetResponse

// int32 code = 1;
inline void KvSetResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvSetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvSetResponse.code)
  return code_;
}
inline void KvSetResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvSetResponse.code)
}

// uint64 affected_keys = 2;
inline void KvSetResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KvSetResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvSetResponse.affected_keys)
  return affected_keys_;
}
inline void KvSetResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvSetResponse.affected_keys)
}

// -------------------------------------------------------------------

// DsKvSetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvSetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvSetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvSetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvSetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvSetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvSetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvSetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvSetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvSetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvSetRequest.header)
}

// .kvrpcpb.KvSetRequest req = 2;
inline bool DsKvSetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvSetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvSetRequest& DsKvSetRequest::req() const {
  const ::kvrpcpb::KvSetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvSetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvSetRequest*>(
      &::kvrpcpb::_KvSetRequest_default_instance_);
}
inline ::kvrpcpb::KvSetRequest* DsKvSetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvSetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvSetRequest.req)
  return req_;
}
inline ::kvrpcpb::KvSetRequest* DsKvSetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvSetRequest.req)
  
  ::kvrpcpb::KvSetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvSetRequest::set_allocated_req(::kvrpcpb::KvSetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvSetRequest.req)
}

// -------------------------------------------------------------------

// DsKvSetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvSetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvSetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvSetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvSetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvSetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvSetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvSetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvSetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvSetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvSetResponse.header)
}

// .kvrpcpb.KvSetResponse resp = 2;
inline bool DsKvSetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvSetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvSetResponse& DsKvSetResponse::resp() const {
  const ::kvrpcpb::KvSetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvSetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvSetResponse*>(
      &::kvrpcpb::_KvSetResponse_default_instance_);
}
inline ::kvrpcpb::KvSetResponse* DsKvSetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvSetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvSetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvSetResponse* DsKvSetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvSetResponse.resp)
  
  ::kvrpcpb::KvSetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvSetResponse::set_allocated_resp(::kvrpcpb::KvSetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvSetResponse.resp)
}

// -------------------------------------------------------------------

// KvGetRequest

// bytes key = 1;
inline void KvGetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvGetRequest.key)
  return key_.GetNoArena();
}
inline void KvGetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvGetRequest.key)
}
#if LANG_CXX11
inline void KvGetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvGetRequest.key)
}
#endif
inline void KvGetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvGetRequest.key)
}
inline void KvGetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvGetRequest.key)
}
inline ::std::string* KvGetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvGetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvGetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvGetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvGetRequest.key)
}

// -------------------------------------------------------------------

// KvGetResponse

// int32 code = 1;
inline void KvGetResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvGetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvGetResponse.code)
  return code_;
}
inline void KvGetResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvGetResponse.code)
}

// bytes value = 2;
inline void KvGetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvGetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvGetResponse.value)
  return value_.GetNoArena();
}
inline void KvGetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvGetResponse.value)
}
#if LANG_CXX11
inline void KvGetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvGetResponse.value)
}
#endif
inline void KvGetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvGetResponse.value)
}
inline void KvGetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvGetResponse.value)
}
inline ::std::string* KvGetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvGetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvGetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvGetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvGetResponse.value)
}

// -------------------------------------------------------------------

// DsKvGetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvGetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvGetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvGetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvGetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvGetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvGetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvGetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvGetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvGetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvGetRequest.header)
}

// .kvrpcpb.KvGetRequest req = 2;
inline bool DsKvGetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvGetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvGetRequest& DsKvGetRequest::req() const {
  const ::kvrpcpb::KvGetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvGetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvGetRequest*>(
      &::kvrpcpb::_KvGetRequest_default_instance_);
}
inline ::kvrpcpb::KvGetRequest* DsKvGetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvGetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvGetRequest.req)
  return req_;
}
inline ::kvrpcpb::KvGetRequest* DsKvGetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvGetRequest.req)
  
  ::kvrpcpb::KvGetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvGetRequest::set_allocated_req(::kvrpcpb::KvGetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvGetRequest.req)
}

// -------------------------------------------------------------------

// DsKvGetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvGetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvGetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvGetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvGetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvGetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvGetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvGetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvGetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvGetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvGetResponse.header)
}

// .kvrpcpb.KvGetResponse resp = 2;
inline bool DsKvGetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvGetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvGetResponse& DsKvGetResponse::resp() const {
  const ::kvrpcpb::KvGetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvGetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvGetResponse*>(
      &::kvrpcpb::_KvGetResponse_default_instance_);
}
inline ::kvrpcpb::KvGetResponse* DsKvGetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvGetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvGetResponse* DsKvGetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvGetResponse.resp)
  
  ::kvrpcpb::KvGetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvGetResponse::set_allocated_resp(::kvrpcpb::KvGetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvGetResponse.resp)
}

// -------------------------------------------------------------------

// KvBatchSetRequest

// repeated .kvrpcpb.RedisKeyValue kvs = 1;
inline int KvBatchSetRequest::kvs_size() const {
  return kvs_.size();
}
inline void KvBatchSetRequest::clear_kvs() {
  kvs_.Clear();
}
inline const ::kvrpcpb::RedisKeyValue& KvBatchSetRequest::kvs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchSetRequest.kvs)
  return kvs_.Get(index);
}
inline ::kvrpcpb::RedisKeyValue* KvBatchSetRequest::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvBatchSetRequest.kvs)
  return kvs_.Mutable(index);
}
inline ::kvrpcpb::RedisKeyValue* KvBatchSetRequest::add_kvs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.KvBatchSetRequest.kvs)
  return kvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >*
KvBatchSetRequest::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvBatchSetRequest.kvs)
  return &kvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >&
KvBatchSetRequest::kvs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvBatchSetRequest.kvs)
  return kvs_;
}

// .kvrpcpb.ExistCase case = 2;
inline void KvBatchSetRequest::clear_case_() {
  case__ = 0;
}
inline ::kvrpcpb::ExistCase KvBatchSetRequest::case_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchSetRequest.case)
  return static_cast< ::kvrpcpb::ExistCase >(case__);
}
inline void KvBatchSetRequest::set_case_(::kvrpcpb::ExistCase value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchSetRequest.case)
}

// -------------------------------------------------------------------

// KvBatchSetResponse

// int32 code = 1;
inline void KvBatchSetResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvBatchSetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchSetResponse.code)
  return code_;
}
inline void KvBatchSetResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchSetResponse.code)
}

// uint64 affected_keys = 2;
inline void KvBatchSetResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KvBatchSetResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchSetResponse.affected_keys)
  return affected_keys_;
}
inline void KvBatchSetResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchSetResponse.affected_keys)
}

// -------------------------------------------------------------------

// DsKvBatchSetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvBatchSetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvBatchSetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvBatchSetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchSetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvBatchSetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchSetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvBatchSetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchSetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvBatchSetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchSetRequest.header)
}

// .kvrpcpb.KvBatchSetRequest req = 2;
inline bool DsKvBatchSetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvBatchSetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvBatchSetRequest& DsKvBatchSetRequest::req() const {
  const ::kvrpcpb::KvBatchSetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchSetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvBatchSetRequest*>(
      &::kvrpcpb::_KvBatchSetRequest_default_instance_);
}
inline ::kvrpcpb::KvBatchSetRequest* DsKvBatchSetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvBatchSetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchSetRequest.req)
  return req_;
}
inline ::kvrpcpb::KvBatchSetRequest* DsKvBatchSetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchSetRequest.req)
  
  ::kvrpcpb::KvBatchSetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvBatchSetRequest::set_allocated_req(::kvrpcpb::KvBatchSetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchSetRequest.req)
}

// -------------------------------------------------------------------

// DsKvBatchSetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvBatchSetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvBatchSetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvBatchSetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchSetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvBatchSetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchSetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvBatchSetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchSetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvBatchSetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchSetResponse.header)
}

// .kvrpcpb.KvBatchSetResponse resp = 2;
inline bool DsKvBatchSetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvBatchSetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvBatchSetResponse& DsKvBatchSetResponse::resp() const {
  const ::kvrpcpb::KvBatchSetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchSetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvBatchSetResponse*>(
      &::kvrpcpb::_KvBatchSetResponse_default_instance_);
}
inline ::kvrpcpb::KvBatchSetResponse* DsKvBatchSetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvBatchSetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchSetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvBatchSetResponse* DsKvBatchSetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchSetResponse.resp)
  
  ::kvrpcpb::KvBatchSetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvBatchSetResponse::set_allocated_resp(::kvrpcpb::KvBatchSetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchSetResponse.resp)
}

// -------------------------------------------------------------------

// KvBatchGetRequest

// int32 code = 1;
inline void KvBatchGetRequest::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvBatchGetRequest::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchGetRequest.code)
  return code_;
}
inline void KvBatchGetRequest::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchGetRequest.code)
}

// repeated bytes keys = 2;
inline int KvBatchGetRequest::keys_size() const {
  return keys_.size();
}
inline void KvBatchGetRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& KvBatchGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchGetRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* KvBatchGetRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvBatchGetRequest.keys)
  return keys_.Mutable(index);
}
inline void KvBatchGetRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchGetRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KvBatchGetRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchGetRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KvBatchGetRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvBatchGetRequest.keys)
}
inline void KvBatchGetRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvBatchGetRequest.keys)
}
inline ::std::string* KvBatchGetRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.KvBatchGetRequest.keys)
  return keys_.Add();
}
inline void KvBatchGetRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.KvBatchGetRequest.keys)
}
#if LANG_CXX11
inline void KvBatchGetRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.KvBatchGetRequest.keys)
}
#endif
inline void KvBatchGetRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.KvBatchGetRequest.keys)
}
inline void KvBatchGetRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.KvBatchGetRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KvBatchGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvBatchGetRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KvBatchGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvBatchGetRequest.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// KvBatchGetResponse

// int32 code = 1;
inline void KvBatchGetResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvBatchGetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchGetResponse.code)
  return code_;
}
inline void KvBatchGetResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchGetResponse.code)
}

// repeated .kvrpcpb.RedisKeyValue kvs = 2;
inline int KvBatchGetResponse::kvs_size() const {
  return kvs_.size();
}
inline void KvBatchGetResponse::clear_kvs() {
  kvs_.Clear();
}
inline const ::kvrpcpb::RedisKeyValue& KvBatchGetResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchGetResponse.kvs)
  return kvs_.Get(index);
}
inline ::kvrpcpb::RedisKeyValue* KvBatchGetResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvBatchGetResponse.kvs)
  return kvs_.Mutable(index);
}
inline ::kvrpcpb::RedisKeyValue* KvBatchGetResponse::add_kvs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.KvBatchGetResponse.kvs)
  return kvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >*
KvBatchGetResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvBatchGetResponse.kvs)
  return &kvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >&
KvBatchGetResponse::kvs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvBatchGetResponse.kvs)
  return kvs_;
}

// -------------------------------------------------------------------

// DsKvBatchGetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvBatchGetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvBatchGetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvBatchGetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchGetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvBatchGetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchGetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvBatchGetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchGetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvBatchGetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchGetRequest.header)
}

// .kvrpcpb.KvBatchGetRequest req = 2;
inline bool DsKvBatchGetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvBatchGetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvBatchGetRequest& DsKvBatchGetRequest::req() const {
  const ::kvrpcpb::KvBatchGetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchGetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvBatchGetRequest*>(
      &::kvrpcpb::_KvBatchGetRequest_default_instance_);
}
inline ::kvrpcpb::KvBatchGetRequest* DsKvBatchGetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvBatchGetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchGetRequest.req)
  return req_;
}
inline ::kvrpcpb::KvBatchGetRequest* DsKvBatchGetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchGetRequest.req)
  
  ::kvrpcpb::KvBatchGetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvBatchGetRequest::set_allocated_req(::kvrpcpb::KvBatchGetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchGetRequest.req)
}

// -------------------------------------------------------------------

// DsKvBatchGetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvBatchGetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvBatchGetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvBatchGetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchGetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvBatchGetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchGetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvBatchGetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchGetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvBatchGetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchGetResponse.header)
}

// .kvrpcpb.KvBatchGetResponse resp = 2;
inline bool DsKvBatchGetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvBatchGetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvBatchGetResponse& DsKvBatchGetResponse::resp() const {
  const ::kvrpcpb::KvBatchGetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchGetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvBatchGetResponse*>(
      &::kvrpcpb::_KvBatchGetResponse_default_instance_);
}
inline ::kvrpcpb::KvBatchGetResponse* DsKvBatchGetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvBatchGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchGetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvBatchGetResponse* DsKvBatchGetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchGetResponse.resp)
  
  ::kvrpcpb::KvBatchGetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvBatchGetResponse::set_allocated_resp(::kvrpcpb::KvBatchGetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchGetResponse.resp)
}

// -------------------------------------------------------------------

// KvScanRequest

// bytes start = 1;
inline void KvScanRequest::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvScanRequest::start() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanRequest.start)
  return start_.GetNoArena();
}
inline void KvScanRequest::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanRequest.start)
}
#if LANG_CXX11
inline void KvScanRequest::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvScanRequest.start)
}
#endif
inline void KvScanRequest::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvScanRequest.start)
}
inline void KvScanRequest::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvScanRequest.start)
}
inline ::std::string* KvScanRequest::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvScanRequest.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvScanRequest::release_start() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvScanRequest.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvScanRequest::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvScanRequest.start)
}

// bytes limit = 2;
inline void KvScanRequest::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvScanRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanRequest.limit)
  return limit_.GetNoArena();
}
inline void KvScanRequest::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanRequest.limit)
}
#if LANG_CXX11
inline void KvScanRequest::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvScanRequest.limit)
}
#endif
inline void KvScanRequest::set_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvScanRequest.limit)
}
inline void KvScanRequest::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvScanRequest.limit)
}
inline ::std::string* KvScanRequest::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvScanRequest.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvScanRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvScanRequest.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvScanRequest::set_allocated_limit(::std::string* limit) {
  if (limit != NULL) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvScanRequest.limit)
}

// bool count_only = 3;
inline void KvScanRequest::clear_count_only() {
  count_only_ = false;
}
inline bool KvScanRequest::count_only() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanRequest.count_only)
  return count_only_;
}
inline void KvScanRequest::set_count_only(bool value) {
  
  count_only_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanRequest.count_only)
}

// bool key_only = 4;
inline void KvScanRequest::clear_key_only() {
  key_only_ = false;
}
inline bool KvScanRequest::key_only() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanRequest.key_only)
  return key_only_;
}
inline void KvScanRequest::set_key_only(bool value) {
  
  key_only_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanRequest.key_only)
}

// int64 max_count = 5;
inline void KvScanRequest::clear_max_count() {
  max_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KvScanRequest::max_count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanRequest.max_count)
  return max_count_;
}
inline void KvScanRequest::set_max_count(::google::protobuf::int64 value) {
  
  max_count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanRequest.max_count)
}

// -------------------------------------------------------------------

// KvScanResponse

// int32 code = 1;
inline void KvScanResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvScanResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanResponse.code)
  return code_;
}
inline void KvScanResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanResponse.code)
}

// int64 count = 2;
inline void KvScanResponse::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KvScanResponse::count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanResponse.count)
  return count_;
}
inline void KvScanResponse::set_count(::google::protobuf::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanResponse.count)
}

// repeated .kvrpcpb.RedisKeyValue kvs = 3;
inline int KvScanResponse::kvs_size() const {
  return kvs_.size();
}
inline void KvScanResponse::clear_kvs() {
  kvs_.Clear();
}
inline const ::kvrpcpb::RedisKeyValue& KvScanResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanResponse.kvs)
  return kvs_.Get(index);
}
inline ::kvrpcpb::RedisKeyValue* KvScanResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvScanResponse.kvs)
  return kvs_.Mutable(index);
}
inline ::kvrpcpb::RedisKeyValue* KvScanResponse::add_kvs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.KvScanResponse.kvs)
  return kvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >*
KvScanResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvScanResponse.kvs)
  return &kvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::RedisKeyValue >&
KvScanResponse::kvs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvScanResponse.kvs)
  return kvs_;
}

// bytes last_key = 4;
inline void KvScanResponse::clear_last_key() {
  last_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvScanResponse::last_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvScanResponse.last_key)
  return last_key_.GetNoArena();
}
inline void KvScanResponse::set_last_key(const ::std::string& value) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvScanResponse.last_key)
}
#if LANG_CXX11
inline void KvScanResponse::set_last_key(::std::string&& value) {
  
  last_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvScanResponse.last_key)
}
#endif
inline void KvScanResponse::set_last_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvScanResponse.last_key)
}
inline void KvScanResponse::set_last_key(const void* value, size_t size) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvScanResponse.last_key)
}
inline ::std::string* KvScanResponse::mutable_last_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvScanResponse.last_key)
  return last_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvScanResponse::release_last_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvScanResponse.last_key)
  
  return last_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvScanResponse::set_allocated_last_key(::std::string* last_key) {
  if (last_key != NULL) {
    
  } else {
    
  }
  last_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvScanResponse.last_key)
}

// -------------------------------------------------------------------

// DsKvScanRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvScanRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvScanRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvScanRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvScanRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvScanRequest.header)
}

// .kvrpcpb.KvScanRequest req = 2;
inline bool DsKvScanRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvScanRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvScanRequest& DsKvScanRequest::req() const {
  const ::kvrpcpb::KvScanRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvScanRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvScanRequest*>(
      &::kvrpcpb::_KvScanRequest_default_instance_);
}
inline ::kvrpcpb::KvScanRequest* DsKvScanRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvScanRequest.req)
  return req_;
}
inline ::kvrpcpb::KvScanRequest* DsKvScanRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvScanRequest.req)
  
  ::kvrpcpb::KvScanRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvScanRequest::set_allocated_req(::kvrpcpb::KvScanRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvScanRequest.req)
}

// -------------------------------------------------------------------

// DsKvScanResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvScanResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvScanResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvScanResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvScanResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvScanResponse.header)
}

// .kvrpcpb.KvScanResponse resp = 2;
inline bool DsKvScanResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvScanResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvScanResponse& DsKvScanResponse::resp() const {
  const ::kvrpcpb::KvScanResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvScanResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvScanResponse*>(
      &::kvrpcpb::_KvScanResponse_default_instance_);
}
inline ::kvrpcpb::KvScanResponse* DsKvScanResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvScanResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvScanResponse* DsKvScanResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvScanResponse.resp)
  
  ::kvrpcpb::KvScanResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvScanResponse::set_allocated_resp(::kvrpcpb::KvScanResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvScanResponse.resp)
}

// -------------------------------------------------------------------

// KvDeleteRequest

// bytes key = 1;
inline void KvDeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvDeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvDeleteRequest.key)
  return key_.GetNoArena();
}
inline void KvDeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvDeleteRequest.key)
}
#if LANG_CXX11
inline void KvDeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvDeleteRequest.key)
}
#endif
inline void KvDeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvDeleteRequest.key)
}
inline void KvDeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvDeleteRequest.key)
}
inline ::std::string* KvDeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvDeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvDeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvDeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvDeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvDeleteRequest.key)
}

// .kvrpcpb.ExistCase case = 2;
inline void KvDeleteRequest::clear_case_() {
  case__ = 0;
}
inline ::kvrpcpb::ExistCase KvDeleteRequest::case_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvDeleteRequest.case)
  return static_cast< ::kvrpcpb::ExistCase >(case__);
}
inline void KvDeleteRequest::set_case_(::kvrpcpb::ExistCase value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvDeleteRequest.case)
}

// -------------------------------------------------------------------

// KvDeleteResponse

// int32 code = 1;
inline void KvDeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvDeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvDeleteResponse.code)
  return code_;
}
inline void KvDeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvDeleteResponse.code)
}

// uint64 affected_keys = 2;
inline void KvDeleteResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KvDeleteResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvDeleteResponse.affected_keys)
  return affected_keys_;
}
inline void KvDeleteResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvDeleteResponse.affected_keys)
}

// -------------------------------------------------------------------

// DsKvDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvDeleteRequest.header)
}

// .kvrpcpb.KvDeleteRequest req = 2;
inline bool DsKvDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvDeleteRequest& DsKvDeleteRequest::req() const {
  const ::kvrpcpb::KvDeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvDeleteRequest*>(
      &::kvrpcpb::_KvDeleteRequest_default_instance_);
}
inline ::kvrpcpb::KvDeleteRequest* DsKvDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvDeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvDeleteRequest* DsKvDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvDeleteRequest.req)
  
  ::kvrpcpb::KvDeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvDeleteRequest::set_allocated_req(::kvrpcpb::KvDeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsKvDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvDeleteResponse.header)
}

// .kvrpcpb.KvDeleteResponse resp = 2;
inline bool DsKvDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvDeleteResponse& DsKvDeleteResponse::resp() const {
  const ::kvrpcpb::KvDeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvDeleteResponse*>(
      &::kvrpcpb::_KvDeleteResponse_default_instance_);
}
inline ::kvrpcpb::KvDeleteResponse* DsKvDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvDeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvDeleteResponse* DsKvDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvDeleteResponse.resp)
  
  ::kvrpcpb::KvDeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvDeleteResponse::set_allocated_resp(::kvrpcpb::KvDeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvDeleteResponse.resp)
}

// -------------------------------------------------------------------

// KvBatchDeleteRequest

// repeated bytes keys = 1;
inline int KvBatchDeleteRequest::keys_size() const {
  return keys_.size();
}
inline void KvBatchDeleteRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& KvBatchDeleteRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchDeleteRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* KvBatchDeleteRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvBatchDeleteRequest.keys)
  return keys_.Mutable(index);
}
inline void KvBatchDeleteRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchDeleteRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KvBatchDeleteRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchDeleteRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KvBatchDeleteRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvBatchDeleteRequest.keys)
}
inline void KvBatchDeleteRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvBatchDeleteRequest.keys)
}
inline ::std::string* KvBatchDeleteRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.KvBatchDeleteRequest.keys)
  return keys_.Add();
}
inline void KvBatchDeleteRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.KvBatchDeleteRequest.keys)
}
#if LANG_CXX11
inline void KvBatchDeleteRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.KvBatchDeleteRequest.keys)
}
#endif
inline void KvBatchDeleteRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.KvBatchDeleteRequest.keys)
}
inline void KvBatchDeleteRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.KvBatchDeleteRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KvBatchDeleteRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvBatchDeleteRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KvBatchDeleteRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvBatchDeleteRequest.keys)
  return &keys_;
}

// .kvrpcpb.ExistCase case = 2;
inline void KvBatchDeleteRequest::clear_case_() {
  case__ = 0;
}
inline ::kvrpcpb::ExistCase KvBatchDeleteRequest::case_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchDeleteRequest.case)
  return static_cast< ::kvrpcpb::ExistCase >(case__);
}
inline void KvBatchDeleteRequest::set_case_(::kvrpcpb::ExistCase value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchDeleteRequest.case)
}

// -------------------------------------------------------------------

// KvBatchDeleteResponse

// int32 code = 1;
inline void KvBatchDeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvBatchDeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchDeleteResponse.code)
  return code_;
}
inline void KvBatchDeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchDeleteResponse.code)
}

// uint64 affected_keys = 2;
inline void KvBatchDeleteResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KvBatchDeleteResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvBatchDeleteResponse.affected_keys)
  return affected_keys_;
}
inline void KvBatchDeleteResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvBatchDeleteResponse.affected_keys)
}

// -------------------------------------------------------------------

// DsKvBatchDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvBatchDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvBatchDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvBatchDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvBatchDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvBatchDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvBatchDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchDeleteRequest.header)
}

// .kvrpcpb.KvBatchDeleteRequest req = 2;
inline bool DsKvBatchDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvBatchDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvBatchDeleteRequest& DsKvBatchDeleteRequest::req() const {
  const ::kvrpcpb::KvBatchDeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvBatchDeleteRequest*>(
      &::kvrpcpb::_KvBatchDeleteRequest_default_instance_);
}
inline ::kvrpcpb::KvBatchDeleteRequest* DsKvBatchDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvBatchDeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvBatchDeleteRequest* DsKvBatchDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchDeleteRequest.req)
  
  ::kvrpcpb::KvBatchDeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvBatchDeleteRequest::set_allocated_req(::kvrpcpb::KvBatchDeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsKvBatchDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvBatchDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvBatchDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvBatchDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvBatchDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvBatchDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvBatchDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchDeleteResponse.header)
}

// .kvrpcpb.KvBatchDeleteResponse resp = 2;
inline bool DsKvBatchDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvBatchDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvBatchDeleteResponse& DsKvBatchDeleteResponse::resp() const {
  const ::kvrpcpb::KvBatchDeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvBatchDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvBatchDeleteResponse*>(
      &::kvrpcpb::_KvBatchDeleteResponse_default_instance_);
}
inline ::kvrpcpb::KvBatchDeleteResponse* DsKvBatchDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvBatchDeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvBatchDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvBatchDeleteResponse* DsKvBatchDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvBatchDeleteResponse.resp)
  
  ::kvrpcpb::KvBatchDeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvBatchDeleteResponse::set_allocated_resp(::kvrpcpb::KvBatchDeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvBatchDeleteResponse.resp)
}

// -------------------------------------------------------------------

// KvRangeDeleteRequest

// bytes start = 1;
inline void KvRangeDeleteRequest::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRangeDeleteRequest::start() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteRequest.start)
  return start_.GetNoArena();
}
inline void KvRangeDeleteRequest::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteRequest.start)
}
#if LANG_CXX11
inline void KvRangeDeleteRequest::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRangeDeleteRequest.start)
}
#endif
inline void KvRangeDeleteRequest::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRangeDeleteRequest.start)
}
inline void KvRangeDeleteRequest::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRangeDeleteRequest.start)
}
inline ::std::string* KvRangeDeleteRequest::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRangeDeleteRequest.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRangeDeleteRequest::release_start() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRangeDeleteRequest.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRangeDeleteRequest::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRangeDeleteRequest.start)
}

// bytes limit = 2;
inline void KvRangeDeleteRequest::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRangeDeleteRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteRequest.limit)
  return limit_.GetNoArena();
}
inline void KvRangeDeleteRequest::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteRequest.limit)
}
#if LANG_CXX11
inline void KvRangeDeleteRequest::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRangeDeleteRequest.limit)
}
#endif
inline void KvRangeDeleteRequest::set_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRangeDeleteRequest.limit)
}
inline void KvRangeDeleteRequest::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRangeDeleteRequest.limit)
}
inline ::std::string* KvRangeDeleteRequest::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRangeDeleteRequest.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRangeDeleteRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRangeDeleteRequest.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRangeDeleteRequest::set_allocated_limit(::std::string* limit) {
  if (limit != NULL) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRangeDeleteRequest.limit)
}

// int64 max_count = 3;
inline void KvRangeDeleteRequest::clear_max_count() {
  max_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KvRangeDeleteRequest::max_count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteRequest.max_count)
  return max_count_;
}
inline void KvRangeDeleteRequest::set_max_count(::google::protobuf::int64 value) {
  
  max_count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteRequest.max_count)
}

// .kvrpcpb.ExistCase case = 4;
inline void KvRangeDeleteRequest::clear_case_() {
  case__ = 0;
}
inline ::kvrpcpb::ExistCase KvRangeDeleteRequest::case_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteRequest.case)
  return static_cast< ::kvrpcpb::ExistCase >(case__);
}
inline void KvRangeDeleteRequest::set_case_(::kvrpcpb::ExistCase value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteRequest.case)
}

// -------------------------------------------------------------------

// KvRangeDeleteResponse

// int32 code = 1;
inline void KvRangeDeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRangeDeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteResponse.code)
  return code_;
}
inline void KvRangeDeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteResponse.code)
}

// uint64 affected_keys = 2;
inline void KvRangeDeleteResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KvRangeDeleteResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteResponse.affected_keys)
  return affected_keys_;
}
inline void KvRangeDeleteResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteResponse.affected_keys)
}

// bytes last_key = 3;
inline void KvRangeDeleteResponse::clear_last_key() {
  last_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRangeDeleteResponse::last_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRangeDeleteResponse.last_key)
  return last_key_.GetNoArena();
}
inline void KvRangeDeleteResponse::set_last_key(const ::std::string& value) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRangeDeleteResponse.last_key)
}
#if LANG_CXX11
inline void KvRangeDeleteResponse::set_last_key(::std::string&& value) {
  
  last_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRangeDeleteResponse.last_key)
}
#endif
inline void KvRangeDeleteResponse::set_last_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRangeDeleteResponse.last_key)
}
inline void KvRangeDeleteResponse::set_last_key(const void* value, size_t size) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRangeDeleteResponse.last_key)
}
inline ::std::string* KvRangeDeleteResponse::mutable_last_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRangeDeleteResponse.last_key)
  return last_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRangeDeleteResponse::release_last_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRangeDeleteResponse.last_key)
  
  return last_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRangeDeleteResponse::set_allocated_last_key(::std::string* last_key) {
  if (last_key != NULL) {
    
  } else {
    
  }
  last_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRangeDeleteResponse.last_key)
}

// -------------------------------------------------------------------

// DsKvRangeDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRangeDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRangeDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRangeDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRangeDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRangeDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRangeDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRangeDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRangeDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRangeDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRangeDeleteRequest.header)
}

// .kvrpcpb.KvRangeDeleteRequest req = 2;
inline bool DsKvRangeDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRangeDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRangeDeleteRequest& DsKvRangeDeleteRequest::req() const {
  const ::kvrpcpb::KvRangeDeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRangeDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRangeDeleteRequest*>(
      &::kvrpcpb::_KvRangeDeleteRequest_default_instance_);
}
inline ::kvrpcpb::KvRangeDeleteRequest* DsKvRangeDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRangeDeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRangeDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRangeDeleteRequest* DsKvRangeDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRangeDeleteRequest.req)
  
  ::kvrpcpb::KvRangeDeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRangeDeleteRequest::set_allocated_req(::kvrpcpb::KvRangeDeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRangeDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsKvRangeDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRangeDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRangeDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRangeDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRangeDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRangeDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRangeDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRangeDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRangeDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRangeDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRangeDeleteResponse.header)
}

// .kvrpcpb.KvRangeDeleteResponse resp = 2;
inline bool DsKvRangeDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRangeDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRangeDeleteResponse& DsKvRangeDeleteResponse::resp() const {
  const ::kvrpcpb::KvRangeDeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRangeDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRangeDeleteResponse*>(
      &::kvrpcpb::_KvRangeDeleteResponse_default_instance_);
}
inline ::kvrpcpb::KvRangeDeleteResponse* DsKvRangeDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRangeDeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRangeDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRangeDeleteResponse* DsKvRangeDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRangeDeleteResponse.resp)
  
  ::kvrpcpb::KvRangeDeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRangeDeleteResponse::set_allocated_resp(::kvrpcpb::KvRangeDeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRangeDeleteResponse.resp)
}

// -------------------------------------------------------------------

// LockValue

// bytes value = 2;
inline void LockValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockValue::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.value)
  return value_.GetNoArena();
}
inline void LockValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.value)
}
#if LANG_CXX11
inline void LockValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockValue.value)
}
#endif
inline void LockValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockValue.value)
}
inline void LockValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockValue.value)
}
inline ::std::string* LockValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockValue::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockValue.value)
}

// string id = 3;
inline void LockValue::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockValue::id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.id)
  return id_.GetNoArena();
}
inline void LockValue::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.id)
}
#if LANG_CXX11
inline void LockValue::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockValue.id)
}
#endif
inline void LockValue::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockValue.id)
}
inline void LockValue::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockValue.id)
}
inline ::std::string* LockValue::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockValue.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockValue::release_id() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockValue.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockValue::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockValue.id)
}

// int64 delete_time = 4;
inline void LockValue::clear_delete_time() {
  delete_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockValue::delete_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.delete_time)
  return delete_time_;
}
inline void LockValue::set_delete_time(::google::protobuf::int64 value) {
  
  delete_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.delete_time)
}

// int64 update_time = 5;
inline void LockValue::clear_update_time() {
  update_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockValue::update_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.update_time)
  return update_time_;
}
inline void LockValue::set_update_time(::google::protobuf::int64 value) {
  
  update_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.update_time)
}

// bool delete_flag = 6;
inline void LockValue::clear_delete_flag() {
  delete_flag_ = false;
}
inline bool LockValue::delete_flag() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.delete_flag)
  return delete_flag_;
}
inline void LockValue::set_delete_flag(bool value) {
  
  delete_flag_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.delete_flag)
}

// -------------------------------------------------------------------

// LockRequest

// bytes key = 1;
inline void LockRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockRequest.key)
  return key_.GetNoArena();
}
inline void LockRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockRequest.key)
}
#if LANG_CXX11
inline void LockRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockRequest.key)
}
#endif
inline void LockRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockRequest.key)
}
inline void LockRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockRequest.key)
}
inline ::std::string* LockRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockRequest.key)
}

// .kvrpcpb.LockValue value = 2;
inline bool LockRequest::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void LockRequest::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::kvrpcpb::LockValue& LockRequest::value() const {
  const ::kvrpcpb::LockValue* p = value_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockRequest.value)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockValue*>(
      &::kvrpcpb::_LockValue_default_instance_);
}
inline ::kvrpcpb::LockValue* LockRequest::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::kvrpcpb::LockValue;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockRequest.value)
  return value_;
}
inline ::kvrpcpb::LockValue* LockRequest::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockRequest.value)
  
  ::kvrpcpb::LockValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void LockRequest::set_allocated_value(::kvrpcpb::LockValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockRequest.value)
}

// .timestamp.Timestamp timestamp = 10;
inline bool LockRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void LockRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& LockRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* LockRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* LockRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void LockRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockRequest.timestamp)
}

// string by = 11;
inline void LockRequest::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockRequest::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockRequest.by)
  return by_.GetNoArena();
}
inline void LockRequest::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockRequest.by)
}
#if LANG_CXX11
inline void LockRequest::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockRequest.by)
}
#endif
inline void LockRequest::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockRequest.by)
}
inline void LockRequest::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockRequest.by)
}
inline ::std::string* LockRequest::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockRequest.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockRequest::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockRequest.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockRequest::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockRequest.by)
}

// -------------------------------------------------------------------

// DsLockRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockRequest.header)
}

// .kvrpcpb.LockRequest req = 2;
inline bool DsLockRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockRequest& DsLockRequest::req() const {
  const ::kvrpcpb::LockRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockRequest*>(
      &::kvrpcpb::_LockRequest_default_instance_);
}
inline ::kvrpcpb::LockRequest* DsLockRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockRequest.req)
  return req_;
}
inline ::kvrpcpb::LockRequest* DsLockRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockRequest.req)
  
  ::kvrpcpb::LockRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockRequest::set_allocated_req(::kvrpcpb::LockRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockRequest.req)
}

// -------------------------------------------------------------------

// LockResponse

// int64 code = 1;
inline void LockResponse::clear_code() {
  code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.code)
  return code_;
}
inline void LockResponse::set_code(::google::protobuf::int64 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.code)
}

// string error = 2;
inline void LockResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.error)
  return error_.GetNoArena();
}
inline void LockResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.error)
}
#if LANG_CXX11
inline void LockResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockResponse.error)
}
#endif
inline void LockResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockResponse.error)
}
inline void LockResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockResponse.error)
}
inline ::std::string* LockResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockResponse.error)
}

// bytes value = 3;
inline void LockResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.value)
  return value_.GetNoArena();
}
inline void LockResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.value)
}
#if LANG_CXX11
inline void LockResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockResponse.value)
}
#endif
inline void LockResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockResponse.value)
}
inline void LockResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockResponse.value)
}
inline ::std::string* LockResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockResponse.value)
}

// int64 update_time = 4;
inline void LockResponse::clear_update_time() {
  update_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockResponse::update_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.update_time)
  return update_time_;
}
inline void LockResponse::set_update_time(::google::protobuf::int64 value) {
  
  update_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.update_time)
}

// -------------------------------------------------------------------

// LockInfo

// bytes key = 1;
inline void LockInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockInfo::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.key)
  return key_.GetNoArena();
}
inline void LockInfo::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.key)
}
#if LANG_CXX11
inline void LockInfo::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockInfo.key)
}
#endif
inline void LockInfo::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockInfo.key)
}
inline void LockInfo::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockInfo.key)
}
inline ::std::string* LockInfo::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockInfo::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockInfo.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockInfo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.key)
}

// .kvrpcpb.LockValue value = 2;
inline bool LockInfo::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void LockInfo::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::kvrpcpb::LockValue& LockInfo::value() const {
  const ::kvrpcpb::LockValue* p = value_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.value)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockValue*>(
      &::kvrpcpb::_LockValue_default_instance_);
}
inline ::kvrpcpb::LockValue* LockInfo::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::kvrpcpb::LockValue;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.value)
  return value_;
}
inline ::kvrpcpb::LockValue* LockInfo::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockInfo.value)
  
  ::kvrpcpb::LockValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void LockInfo::set_allocated_value(::kvrpcpb::LockValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.value)
}

// -------------------------------------------------------------------

// LockScanResponse

// repeated .kvrpcpb.LockInfo info = 1;
inline int LockScanResponse::info_size() const {
  return info_.size();
}
inline void LockScanResponse::clear_info() {
  info_.Clear();
}
inline const ::kvrpcpb::LockInfo& LockScanResponse::info(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanResponse.info)
  return info_.Get(index);
}
inline ::kvrpcpb::LockInfo* LockScanResponse::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanResponse.info)
  return info_.Mutable(index);
}
inline ::kvrpcpb::LockInfo* LockScanResponse::add_info() {
  // @@protoc_insertion_point(field_add:kvrpcpb.LockScanResponse.info)
  return info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
LockScanResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.LockScanResponse.info)
  return &info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
LockScanResponse::info() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.LockScanResponse.info)
  return info_;
}

// bytes last_key = 2;
inline void LockScanResponse::clear_last_key() {
  last_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockScanResponse::last_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanResponse.last_key)
  return last_key_.GetNoArena();
}
inline void LockScanResponse::set_last_key(const ::std::string& value) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanResponse.last_key)
}
#if LANG_CXX11
inline void LockScanResponse::set_last_key(::std::string&& value) {
  
  last_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockScanResponse.last_key)
}
#endif
inline void LockScanResponse::set_last_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockScanResponse.last_key)
}
inline void LockScanResponse::set_last_key(const void* value, size_t size) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockScanResponse.last_key)
}
inline ::std::string* LockScanResponse::mutable_last_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanResponse.last_key)
  return last_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockScanResponse::release_last_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockScanResponse.last_key)
  
  return last_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockScanResponse::set_allocated_last_key(::std::string* last_key) {
  if (last_key != NULL) {
    
  } else {
    
  }
  last_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockScanResponse.last_key)
}

// -------------------------------------------------------------------

// DsLockResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsLockResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsLockResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsLockResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsLockResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockResponse.resp)
}

// -------------------------------------------------------------------

// LockUpdateRequest

// bytes key = 1;
inline void LockUpdateRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.key)
  return key_.GetNoArena();
}
inline void LockUpdateRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.key)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.key)
}
#endif
inline void LockUpdateRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.key)
}
inline void LockUpdateRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.key)
}
inline ::std::string* LockUpdateRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.key)
}

// string id = 3;
inline void LockUpdateRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.id)
  return id_.GetNoArena();
}
inline void LockUpdateRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.id)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.id)
}
#endif
inline void LockUpdateRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.id)
}
inline void LockUpdateRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.id)
}
inline ::std::string* LockUpdateRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_id() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.id)
}

// int64 update_time = 5;
inline void LockUpdateRequest::clear_update_time() {
  update_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockUpdateRequest::update_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.update_time)
  return update_time_;
}
inline void LockUpdateRequest::set_update_time(::google::protobuf::int64 value) {
  
  update_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.update_time)
}

// bytes update_value = 6;
inline void LockUpdateRequest::clear_update_value() {
  update_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::update_value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.update_value)
  return update_value_.GetNoArena();
}
inline void LockUpdateRequest::set_update_value(const ::std::string& value) {
  
  update_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.update_value)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_update_value(::std::string&& value) {
  
  update_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.update_value)
}
#endif
inline void LockUpdateRequest::set_update_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  update_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.update_value)
}
inline void LockUpdateRequest::set_update_value(const void* value, size_t size) {
  
  update_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.update_value)
}
inline ::std::string* LockUpdateRequest::mutable_update_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.update_value)
  return update_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_update_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.update_value)
  
  return update_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_update_value(::std::string* update_value) {
  if (update_value != NULL) {
    
  } else {
    
  }
  update_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.update_value)
}

// .timestamp.Timestamp timestamp = 10;
inline bool LockUpdateRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void LockUpdateRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& LockUpdateRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* LockUpdateRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* LockUpdateRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void LockUpdateRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.timestamp)
}

// -------------------------------------------------------------------

// DsLockUpdateRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockUpdateRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockUpdateRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockUpdateRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockUpdateRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockUpdateRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockUpdateRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateRequest.header)
}

// .kvrpcpb.LockUpdateRequest req = 2;
inline bool DsLockUpdateRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockUpdateRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockUpdateRequest& DsLockUpdateRequest::req() const {
  const ::kvrpcpb::LockUpdateRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockUpdateRequest*>(
      &::kvrpcpb::_LockUpdateRequest_default_instance_);
}
inline ::kvrpcpb::LockUpdateRequest* DsLockUpdateRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockUpdateRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateRequest.req)
  return req_;
}
inline ::kvrpcpb::LockUpdateRequest* DsLockUpdateRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateRequest.req)
  
  ::kvrpcpb::LockUpdateRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockUpdateRequest::set_allocated_req(::kvrpcpb::LockUpdateRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateRequest.req)
}

// -------------------------------------------------------------------

// DsLockUpdateResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockUpdateResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockUpdateResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockUpdateResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockUpdateResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockUpdateResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockUpdateResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsLockUpdateResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockUpdateResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsLockUpdateResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsLockUpdateResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsLockUpdateResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockUpdateResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateResponse.resp)
}

// -------------------------------------------------------------------

// UnlockRequest

// bytes key = 1;
inline void UnlockRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.key)
  return key_.GetNoArena();
}
inline void UnlockRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockRequest.key)
}
#if LANG_CXX11
inline void UnlockRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockRequest.key)
}
#endif
inline void UnlockRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockRequest.key)
}
inline void UnlockRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockRequest.key)
}
inline ::std::string* UnlockRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.key)
}

// string id = 3;
inline void UnlockRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockRequest::id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.id)
  return id_.GetNoArena();
}
inline void UnlockRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockRequest.id)
}
#if LANG_CXX11
inline void UnlockRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockRequest.id)
}
#endif
inline void UnlockRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockRequest.id)
}
inline void UnlockRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockRequest.id)
}
inline ::std::string* UnlockRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_id() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.id)
}

// .timestamp.Timestamp timestamp = 10;
inline bool UnlockRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void UnlockRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& UnlockRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* UnlockRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* UnlockRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void UnlockRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.timestamp)
}

// string by = 11;
inline void UnlockRequest::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockRequest::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.by)
  return by_.GetNoArena();
}
inline void UnlockRequest::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockRequest.by)
}
#if LANG_CXX11
inline void UnlockRequest::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockRequest.by)
}
#endif
inline void UnlockRequest::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockRequest.by)
}
inline void UnlockRequest::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockRequest.by)
}
inline ::std::string* UnlockRequest::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.by)
}

// -------------------------------------------------------------------

// DsUnlockRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsUnlockRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsUnlockRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsUnlockRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsUnlockRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockRequest.header)
}

// .kvrpcpb.UnlockRequest req = 2;
inline bool DsUnlockRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsUnlockRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::UnlockRequest& DsUnlockRequest::req() const {
  const ::kvrpcpb::UnlockRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::UnlockRequest*>(
      &::kvrpcpb::_UnlockRequest_default_instance_);
}
inline ::kvrpcpb::UnlockRequest* DsUnlockRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::UnlockRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockRequest.req)
  return req_;
}
inline ::kvrpcpb::UnlockRequest* DsUnlockRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockRequest.req)
  
  ::kvrpcpb::UnlockRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsUnlockRequest::set_allocated_req(::kvrpcpb::UnlockRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockRequest.req)
}

// -------------------------------------------------------------------

// DsUnlockResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsUnlockResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsUnlockResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsUnlockResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsUnlockResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsUnlockResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsUnlockResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsUnlockResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsUnlockResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsUnlockResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsUnlockResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockResponse.resp)
}

// -------------------------------------------------------------------

// UnlockForceRequest

// bytes key = 1;
inline void UnlockForceRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockForceRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockForceRequest.key)
  return key_.GetNoArena();
}
inline void UnlockForceRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockForceRequest.key)
}
#if LANG_CXX11
inline void UnlockForceRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockForceRequest.key)
}
#endif
inline void UnlockForceRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockForceRequest.key)
}
inline void UnlockForceRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockForceRequest.key)
}
inline ::std::string* UnlockForceRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockForceRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockForceRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockForceRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockForceRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockForceRequest.key)
}

// .timestamp.Timestamp timestamp = 10;
inline bool UnlockForceRequest::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void UnlockForceRequest::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::timestamp::Timestamp& UnlockForceRequest::timestamp() const {
  const ::timestamp::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockForceRequest.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::timestamp::Timestamp*>(
      &::timestamp::_Timestamp_default_instance_);
}
inline ::timestamp::Timestamp* UnlockForceRequest::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::timestamp::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockForceRequest.timestamp)
  return timestamp_;
}
inline ::timestamp::Timestamp* UnlockForceRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockForceRequest.timestamp)
  
  ::timestamp::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void UnlockForceRequest::set_allocated_timestamp(::timestamp::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockForceRequest.timestamp)
}

// string by = 11;
inline void UnlockForceRequest::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockForceRequest::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockForceRequest.by)
  return by_.GetNoArena();
}
inline void UnlockForceRequest::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockForceRequest.by)
}
#if LANG_CXX11
inline void UnlockForceRequest::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockForceRequest.by)
}
#endif
inline void UnlockForceRequest::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockForceRequest.by)
}
inline void UnlockForceRequest::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockForceRequest.by)
}
inline ::std::string* UnlockForceRequest::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockForceRequest.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockForceRequest::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockForceRequest.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockForceRequest::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockForceRequest.by)
}

// -------------------------------------------------------------------

// DsUnlockForceRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsUnlockForceRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockForceRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsUnlockForceRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsUnlockForceRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsUnlockForceRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockForceRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceRequest.header)
}

// .kvrpcpb.UnlockForceRequest req = 2;
inline bool DsUnlockForceRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsUnlockForceRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::UnlockForceRequest& DsUnlockForceRequest::req() const {
  const ::kvrpcpb::UnlockForceRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::UnlockForceRequest*>(
      &::kvrpcpb::_UnlockForceRequest_default_instance_);
}
inline ::kvrpcpb::UnlockForceRequest* DsUnlockForceRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::UnlockForceRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceRequest.req)
  return req_;
}
inline ::kvrpcpb::UnlockForceRequest* DsUnlockForceRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceRequest.req)
  
  ::kvrpcpb::UnlockForceRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsUnlockForceRequest::set_allocated_req(::kvrpcpb::UnlockForceRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceRequest.req)
}

// -------------------------------------------------------------------

// DsUnlockForceResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsUnlockForceResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockForceResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsUnlockForceResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsUnlockForceResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsUnlockForceResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockForceResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsUnlockForceResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsUnlockForceResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsUnlockForceResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsUnlockForceResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsUnlockForceResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsUnlockForceResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceResponse.resp)
}

// -------------------------------------------------------------------

// LockScanRequest

// bytes start = 1;
inline void LockScanRequest::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockScanRequest::start() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanRequest.start)
  return start_.GetNoArena();
}
inline void LockScanRequest::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanRequest.start)
}
#if LANG_CXX11
inline void LockScanRequest::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockScanRequest.start)
}
#endif
inline void LockScanRequest::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockScanRequest.start)
}
inline void LockScanRequest::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockScanRequest.start)
}
inline ::std::string* LockScanRequest::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanRequest.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockScanRequest::release_start() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockScanRequest.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockScanRequest::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockScanRequest.start)
}

// bytes limit = 2;
inline void LockScanRequest::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockScanRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanRequest.limit)
  return limit_.GetNoArena();
}
inline void LockScanRequest::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanRequest.limit)
}
#if LANG_CXX11
inline void LockScanRequest::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockScanRequest.limit)
}
#endif
inline void LockScanRequest::set_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockScanRequest.limit)
}
inline void LockScanRequest::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockScanRequest.limit)
}
inline ::std::string* LockScanRequest::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanRequest.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockScanRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockScanRequest.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockScanRequest::set_allocated_limit(::std::string* limit) {
  if (limit != NULL) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockScanRequest.limit)
}

// uint32 count = 3;
inline void LockScanRequest::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 LockScanRequest::count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanRequest.count)
  return count_;
}
inline void LockScanRequest::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanRequest.count)
}

// -------------------------------------------------------------------

// DsLockScanRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockScanRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockScanRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanRequest.header)
}

// .kvrpcpb.LockScanRequest req = 2;
inline bool DsLockScanRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockScanRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockScanRequest& DsLockScanRequest::req() const {
  const ::kvrpcpb::LockScanRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockScanRequest*>(
      &::kvrpcpb::_LockScanRequest_default_instance_);
}
inline ::kvrpcpb::LockScanRequest* DsLockScanRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanRequest.req)
  return req_;
}
inline ::kvrpcpb::LockScanRequest* DsLockScanRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanRequest.req)
  
  ::kvrpcpb::LockScanRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockScanRequest::set_allocated_req(::kvrpcpb::LockScanRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanRequest.req)
}

// -------------------------------------------------------------------

// DsLockScanResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockScanResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockScanResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanResponse.header)
}

// .kvrpcpb.LockScanResponse resp = 2;
inline bool DsLockScanResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockScanResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockScanResponse& DsLockScanResponse::resp() const {
  const ::kvrpcpb::LockScanResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockScanResponse*>(
      &::kvrpcpb::_LockScanResponse_default_instance_);
}
inline ::kvrpcpb::LockScanResponse* DsLockScanResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockScanResponse* DsLockScanResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanResponse.resp)
  
  ::kvrpcpb::LockScanResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockScanResponse::set_allocated_resp(::kvrpcpb::LockScanResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanResponse.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace kvrpcpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kvrpcpb::SelectField_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::SelectField_Type>() {
  return ::kvrpcpb::SelectField_Type_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::ExecuteType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::ExecuteType>() {
  return ::kvrpcpb::ExecuteType_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::MatchType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::MatchType>() {
  return ::kvrpcpb::MatchType_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::ExistCase> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::ExistCase>() {
  return ::kvrpcpb::ExistCase_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::Operation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::Operation>() {
  return ::kvrpcpb::Operation_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kvrpcpb_2eproto__INCLUDED
