// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvrpcpb.proto

#ifndef PROTOBUF_kvrpcpb_2eproto__INCLUDED
#define PROTOBUF_kvrpcpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "exprpb.pb.h"
#include "errorpb.pb.h"
// @@protoc_insertion_point(includes)
namespace kvrpcpb {
class BatchInsertRequest;
class BatchInsertRequestDefaultTypeInternal;
extern BatchInsertRequestDefaultTypeInternal _BatchInsertRequest_default_instance_;
class BatchInsertResponse;
class BatchInsertResponseDefaultTypeInternal;
extern BatchInsertResponseDefaultTypeInternal _BatchInsertResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class DsDeleteRequest;
class DsDeleteRequestDefaultTypeInternal;
extern DsDeleteRequestDefaultTypeInternal _DsDeleteRequest_default_instance_;
class DsDeleteResponse;
class DsDeleteResponseDefaultTypeInternal;
extern DsDeleteResponseDefaultTypeInternal _DsDeleteResponse_default_instance_;
class DsIndexScanRequest;
class DsIndexScanRequestDefaultTypeInternal;
extern DsIndexScanRequestDefaultTypeInternal _DsIndexScanRequest_default_instance_;
class DsIndexScanResponse;
class DsIndexScanResponseDefaultTypeInternal;
extern DsIndexScanResponseDefaultTypeInternal _DsIndexScanResponse_default_instance_;
class DsInsertRequest;
class DsInsertRequestDefaultTypeInternal;
extern DsInsertRequestDefaultTypeInternal _DsInsertRequest_default_instance_;
class DsInsertResponse;
class DsInsertResponseDefaultTypeInternal;
extern DsInsertResponseDefaultTypeInternal _DsInsertResponse_default_instance_;
class DsKvRawDeleteRequest;
class DsKvRawDeleteRequestDefaultTypeInternal;
extern DsKvRawDeleteRequestDefaultTypeInternal _DsKvRawDeleteRequest_default_instance_;
class DsKvRawDeleteResponse;
class DsKvRawDeleteResponseDefaultTypeInternal;
extern DsKvRawDeleteResponseDefaultTypeInternal _DsKvRawDeleteResponse_default_instance_;
class DsKvRawExecuteRequest;
class DsKvRawExecuteRequestDefaultTypeInternal;
extern DsKvRawExecuteRequestDefaultTypeInternal _DsKvRawExecuteRequest_default_instance_;
class DsKvRawExecuteResponse;
class DsKvRawExecuteResponseDefaultTypeInternal;
extern DsKvRawExecuteResponseDefaultTypeInternal _DsKvRawExecuteResponse_default_instance_;
class DsKvRawGetRequest;
class DsKvRawGetRequestDefaultTypeInternal;
extern DsKvRawGetRequestDefaultTypeInternal _DsKvRawGetRequest_default_instance_;
class DsKvRawGetResponse;
class DsKvRawGetResponseDefaultTypeInternal;
extern DsKvRawGetResponseDefaultTypeInternal _DsKvRawGetResponse_default_instance_;
class DsKvRawPutRequest;
class DsKvRawPutRequestDefaultTypeInternal;
extern DsKvRawPutRequestDefaultTypeInternal _DsKvRawPutRequest_default_instance_;
class DsKvRawPutResponse;
class DsKvRawPutResponseDefaultTypeInternal;
extern DsKvRawPutResponseDefaultTypeInternal _DsKvRawPutResponse_default_instance_;
class DsLockGetRequest;
class DsLockGetRequestDefaultTypeInternal;
extern DsLockGetRequestDefaultTypeInternal _DsLockGetRequest_default_instance_;
class DsLockGetResponse;
class DsLockGetResponseDefaultTypeInternal;
extern DsLockGetResponseDefaultTypeInternal _DsLockGetResponse_default_instance_;
class DsLockRequest;
class DsLockRequestDefaultTypeInternal;
extern DsLockRequestDefaultTypeInternal _DsLockRequest_default_instance_;
class DsLockResponse;
class DsLockResponseDefaultTypeInternal;
extern DsLockResponseDefaultTypeInternal _DsLockResponse_default_instance_;
class DsLockScanRequest;
class DsLockScanRequestDefaultTypeInternal;
extern DsLockScanRequestDefaultTypeInternal _DsLockScanRequest_default_instance_;
class DsLockScanResponse;
class DsLockScanResponseDefaultTypeInternal;
extern DsLockScanResponseDefaultTypeInternal _DsLockScanResponse_default_instance_;
class DsLockUpdateRequest;
class DsLockUpdateRequestDefaultTypeInternal;
extern DsLockUpdateRequestDefaultTypeInternal _DsLockUpdateRequest_default_instance_;
class DsLockUpdateResponse;
class DsLockUpdateResponseDefaultTypeInternal;
extern DsLockUpdateResponseDefaultTypeInternal _DsLockUpdateResponse_default_instance_;
class DsSelectRequest;
class DsSelectRequestDefaultTypeInternal;
extern DsSelectRequestDefaultTypeInternal _DsSelectRequest_default_instance_;
class DsSelectResponse;
class DsSelectResponseDefaultTypeInternal;
extern DsSelectResponseDefaultTypeInternal _DsSelectResponse_default_instance_;
class DsUnlockForceRequest;
class DsUnlockForceRequestDefaultTypeInternal;
extern DsUnlockForceRequestDefaultTypeInternal _DsUnlockForceRequest_default_instance_;
class DsUnlockForceResponse;
class DsUnlockForceResponseDefaultTypeInternal;
extern DsUnlockForceResponseDefaultTypeInternal _DsUnlockForceResponse_default_instance_;
class DsUnlockRequest;
class DsUnlockRequestDefaultTypeInternal;
extern DsUnlockRequestDefaultTypeInternal _DsUnlockRequest_default_instance_;
class DsUnlockResponse;
class DsUnlockResponseDefaultTypeInternal;
extern DsUnlockResponseDefaultTypeInternal _DsUnlockResponse_default_instance_;
class DsUpdateRequest;
class DsUpdateRequestDefaultTypeInternal;
extern DsUpdateRequestDefaultTypeInternal _DsUpdateRequest_default_instance_;
class DsUpdateResponse;
class DsUpdateResponseDefaultTypeInternal;
extern DsUpdateResponseDefaultTypeInternal _DsUpdateResponse_default_instance_;
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class IndexScanRequest;
class IndexScanRequestDefaultTypeInternal;
extern IndexScanRequestDefaultTypeInternal _IndexScanRequest_default_instance_;
class IndexScanResponse;
class IndexScanResponseDefaultTypeInternal;
extern IndexScanResponseDefaultTypeInternal _IndexScanResponse_default_instance_;
class InsertRequest;
class InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertResponse;
class InsertResponseDefaultTypeInternal;
extern InsertResponseDefaultTypeInternal _InsertResponse_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class KvPair;
class KvPairDefaultTypeInternal;
extern KvPairDefaultTypeInternal _KvPair_default_instance_;
class KvPairRawExecute;
class KvPairRawExecuteDefaultTypeInternal;
extern KvPairRawExecuteDefaultTypeInternal _KvPairRawExecute_default_instance_;
class KvRawDeleteRequest;
class KvRawDeleteRequestDefaultTypeInternal;
extern KvRawDeleteRequestDefaultTypeInternal _KvRawDeleteRequest_default_instance_;
class KvRawDeleteResponse;
class KvRawDeleteResponseDefaultTypeInternal;
extern KvRawDeleteResponseDefaultTypeInternal _KvRawDeleteResponse_default_instance_;
class KvRawExecuteRequest;
class KvRawExecuteRequestDefaultTypeInternal;
extern KvRawExecuteRequestDefaultTypeInternal _KvRawExecuteRequest_default_instance_;
class KvRawExecuteResponse;
class KvRawExecuteResponseDefaultTypeInternal;
extern KvRawExecuteResponseDefaultTypeInternal _KvRawExecuteResponse_default_instance_;
class KvRawGetRequest;
class KvRawGetRequestDefaultTypeInternal;
extern KvRawGetRequestDefaultTypeInternal _KvRawGetRequest_default_instance_;
class KvRawGetResponse;
class KvRawGetResponseDefaultTypeInternal;
extern KvRawGetResponseDefaultTypeInternal _KvRawGetResponse_default_instance_;
class KvRawPutRequest;
class KvRawPutRequestDefaultTypeInternal;
extern KvRawPutRequestDefaultTypeInternal _KvRawPutRequest_default_instance_;
class KvRawPutResponse;
class KvRawPutResponseDefaultTypeInternal;
extern KvRawPutResponseDefaultTypeInternal _KvRawPutResponse_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class LockGetRequest;
class LockGetRequestDefaultTypeInternal;
extern LockGetRequestDefaultTypeInternal _LockGetRequest_default_instance_;
class LockGetResponse;
class LockGetResponseDefaultTypeInternal;
extern LockGetResponseDefaultTypeInternal _LockGetResponse_default_instance_;
class LockInfo;
class LockInfoDefaultTypeInternal;
extern LockInfoDefaultTypeInternal _LockInfo_default_instance_;
class LockRequest;
class LockRequestDefaultTypeInternal;
extern LockRequestDefaultTypeInternal _LockRequest_default_instance_;
class LockResponse;
class LockResponseDefaultTypeInternal;
extern LockResponseDefaultTypeInternal _LockResponse_default_instance_;
class LockScanRequest;
class LockScanRequestDefaultTypeInternal;
extern LockScanRequestDefaultTypeInternal _LockScanRequest_default_instance_;
class LockScanResponse;
class LockScanResponseDefaultTypeInternal;
extern LockScanResponseDefaultTypeInternal _LockScanResponse_default_instance_;
class LockUpdateRequest;
class LockUpdateRequestDefaultTypeInternal;
extern LockUpdateRequestDefaultTypeInternal _LockUpdateRequest_default_instance_;
class LockValue;
class LockValueDefaultTypeInternal;
extern LockValueDefaultTypeInternal _LockValue_default_instance_;
class Match;
class MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class Row;
class RowDefaultTypeInternal;
extern RowDefaultTypeInternal _Row_default_instance_;
class Scope;
class ScopeDefaultTypeInternal;
extern ScopeDefaultTypeInternal _Scope_default_instance_;
class SelectField;
class SelectFieldDefaultTypeInternal;
extern SelectFieldDefaultTypeInternal _SelectField_default_instance_;
class SelectRequest;
class SelectRequestDefaultTypeInternal;
extern SelectRequestDefaultTypeInternal _SelectRequest_default_instance_;
class SelectResponse;
class SelectResponseDefaultTypeInternal;
extern SelectResponseDefaultTypeInternal _SelectResponse_default_instance_;
class UnlockForceRequest;
class UnlockForceRequestDefaultTypeInternal;
extern UnlockForceRequestDefaultTypeInternal _UnlockForceRequest_default_instance_;
class UnlockRequest;
class UnlockRequestDefaultTypeInternal;
extern UnlockRequestDefaultTypeInternal _UnlockRequest_default_instance_;
class UpdateRequest;
class UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
class UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
}  // namespace kvrpcpb

namespace kvrpcpb {

namespace protobuf_kvrpcpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_kvrpcpb_2eproto

enum SelectField_Type {
  SelectField_Type_Column = 0,
  SelectField_Type_AggreFunction = 1,
  SelectField_Type_SelectField_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SelectField_Type_SelectField_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SelectField_Type_IsValid(int value);
const SelectField_Type SelectField_Type_Type_MIN = SelectField_Type_Column;
const SelectField_Type SelectField_Type_Type_MAX = SelectField_Type_AggreFunction;
const int SelectField_Type_Type_ARRAYSIZE = SelectField_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectField_Type_descriptor();
inline const ::std::string& SelectField_Type_Name(SelectField_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectField_Type_descriptor(), value);
}
inline bool SelectField_Type_Parse(
    const ::std::string& name, SelectField_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectField_Type>(
    SelectField_Type_descriptor(), name, value);
}
enum ExecuteType {
  ExecInvalid = 0,
  ExecPut = 1,
  ExecDelete = 2,
  ExecuteType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExecuteType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExecuteType_IsValid(int value);
const ExecuteType ExecuteType_MIN = ExecInvalid;
const ExecuteType ExecuteType_MAX = ExecDelete;
const int ExecuteType_ARRAYSIZE = ExecuteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteType_descriptor();
inline const ::std::string& ExecuteType_Name(ExecuteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteType_descriptor(), value);
}
inline bool ExecuteType_Parse(
    const ::std::string& name, ExecuteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteType>(
    ExecuteType_descriptor(), name, value);
}
enum MatchType {
  Invalid = 0,
  Equal = 1,
  NotEqual = 2,
  Less = 3,
  LessOrEqual = 4,
  Larger = 5,
  LargerOrEqual = 6,
  MatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MatchType_IsValid(int value);
const MatchType MatchType_MIN = Invalid;
const MatchType MatchType_MAX = LargerOrEqual;
const int MatchType_ARRAYSIZE = MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatchType_descriptor();
inline const ::std::string& MatchType_Name(MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatchType_descriptor(), value);
}
inline bool MatchType_Parse(
    const ::std::string& name, MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchType>(
    MatchType_descriptor(), name, value);
}
enum FieldType {
  Assign = 0,
  Plus = 1,
  Minus = 2,
  Mult = 3,
  Div = 4,
  FieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FieldType_IsValid(int value);
const FieldType FieldType_MIN = Assign;
const FieldType FieldType_MAX = Div;
const int FieldType_ARRAYSIZE = FieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FieldType_descriptor();
inline const ::std::string& FieldType_Name(FieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FieldType_descriptor(), value);
}
inline bool FieldType_Parse(
    const ::std::string& name, FieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FieldType>(
    FieldType_descriptor(), name, value);
}
// ===================================================================

class KvPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvPair) */ {
 public:
  KvPair();
  virtual ~KvPair();

  KvPair(const KvPair& from);

  inline KvPair& operator=(const KvPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvPair(KvPair&& from) noexcept
    : KvPair() {
    *this = ::std::move(from);
  }

  inline KvPair& operator=(KvPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPair& default_instance();

  static inline const KvPair* internal_default_instance() {
    return reinterpret_cast<const KvPair*>(
               &_KvPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(KvPair* other);
  friend void swap(KvPair& a, KvPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvPair* New() const PROTOBUF_FINAL { return New(NULL); }

  KvPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvPair& from);
  void MergeFrom(const KvPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.RangeEpoch range_epoch = 5;
  bool has_range_epoch() const;
  void clear_range_epoch();
  static const int kRangeEpochFieldNumber = 5;
  const ::metapb::RangeEpoch& range_epoch() const;
  ::metapb::RangeEpoch* mutable_range_epoch();
  ::metapb::RangeEpoch* release_range_epoch();
  void set_allocated_range_epoch(::metapb::RangeEpoch* range_epoch);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // uint64 trace_id = 3;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 3;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // uint64 range_id = 4;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 4;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // uint64 read_index = 6;
  void clear_read_index();
  static const int kReadIndexFieldNumber = 6;
  ::google::protobuf::uint64 read_index() const;
  void set_read_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::RangeEpoch* range_epoch_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 range_id_;
  ::google::protobuf::uint64 read_index_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  const ::errorpb::Error& error() const;
  ::errorpb::Error* mutable_error();
  ::errorpb::Error* release_error();
  void set_allocated_error(::errorpb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // uint64 trace_id = 3;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 3;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // uint64 apply_index = 6;
  void clear_apply_index();
  static const int kApplyIndexFieldNumber = 6;
  ::google::protobuf::uint64 apply_index() const;
  void set_apply_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 apply_index_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawGetRequest) */ {
 public:
  DsKvRawGetRequest();
  virtual ~DsKvRawGetRequest();

  DsKvRawGetRequest(const DsKvRawGetRequest& from);

  inline DsKvRawGetRequest& operator=(const DsKvRawGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawGetRequest(DsKvRawGetRequest&& from) noexcept
    : DsKvRawGetRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawGetRequest& operator=(DsKvRawGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawGetRequest& default_instance();

  static inline const DsKvRawGetRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawGetRequest*>(
               &_DsKvRawGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DsKvRawGetRequest* other);
  friend void swap(DsKvRawGetRequest& a, DsKvRawGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawGetRequest& from);
  void MergeFrom(const DsKvRawGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawGetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawGetRequest& req() const;
  ::kvrpcpb::KvRawGetRequest* mutable_req();
  ::kvrpcpb::KvRawGetRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawGetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawGetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawGetResponse) */ {
 public:
  DsKvRawGetResponse();
  virtual ~DsKvRawGetResponse();

  DsKvRawGetResponse(const DsKvRawGetResponse& from);

  inline DsKvRawGetResponse& operator=(const DsKvRawGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawGetResponse(DsKvRawGetResponse&& from) noexcept
    : DsKvRawGetResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawGetResponse& operator=(DsKvRawGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawGetResponse& default_instance();

  static inline const DsKvRawGetResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawGetResponse*>(
               &_DsKvRawGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DsKvRawGetResponse* other);
  friend void swap(DsKvRawGetResponse& a, DsKvRawGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawGetResponse& from);
  void MergeFrom(const DsKvRawGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawGetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawGetResponse& resp() const;
  ::kvrpcpb::KvRawGetResponse* mutable_resp();
  ::kvrpcpb::KvRawGetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawGetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawGetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawGetRequest) */ {
 public:
  KvRawGetRequest();
  virtual ~KvRawGetRequest();

  KvRawGetRequest(const KvRawGetRequest& from);

  inline KvRawGetRequest& operator=(const KvRawGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawGetRequest(KvRawGetRequest&& from) noexcept
    : KvRawGetRequest() {
    *this = ::std::move(from);
  }

  inline KvRawGetRequest& operator=(KvRawGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawGetRequest& default_instance();

  static inline const KvRawGetRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawGetRequest*>(
               &_KvRawGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(KvRawGetRequest* other);
  friend void swap(KvRawGetRequest& a, KvRawGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawGetRequest& from);
  void MergeFrom(const KvRawGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawGetResponse) */ {
 public:
  KvRawGetResponse();
  virtual ~KvRawGetResponse();

  KvRawGetResponse(const KvRawGetResponse& from);

  inline KvRawGetResponse& operator=(const KvRawGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawGetResponse(KvRawGetResponse&& from) noexcept
    : KvRawGetResponse() {
    *this = ::std::move(from);
  }

  inline KvRawGetResponse& operator=(KvRawGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawGetResponse& default_instance();

  static inline const KvRawGetResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawGetResponse*>(
               &_KvRawGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(KvRawGetResponse* other);
  friend void swap(KvRawGetResponse& a, KvRawGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawGetResponse& from);
  void MergeFrom(const KvRawGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawPutRequest) */ {
 public:
  DsKvRawPutRequest();
  virtual ~DsKvRawPutRequest();

  DsKvRawPutRequest(const DsKvRawPutRequest& from);

  inline DsKvRawPutRequest& operator=(const DsKvRawPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawPutRequest(DsKvRawPutRequest&& from) noexcept
    : DsKvRawPutRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawPutRequest& operator=(DsKvRawPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawPutRequest& default_instance();

  static inline const DsKvRawPutRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawPutRequest*>(
               &_DsKvRawPutRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DsKvRawPutRequest* other);
  friend void swap(DsKvRawPutRequest& a, DsKvRawPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawPutRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawPutRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawPutRequest& from);
  void MergeFrom(const DsKvRawPutRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawPutRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawPutRequest& req() const;
  ::kvrpcpb::KvRawPutRequest* mutable_req();
  ::kvrpcpb::KvRawPutRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawPutRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawPutRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawPutResponse) */ {
 public:
  DsKvRawPutResponse();
  virtual ~DsKvRawPutResponse();

  DsKvRawPutResponse(const DsKvRawPutResponse& from);

  inline DsKvRawPutResponse& operator=(const DsKvRawPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawPutResponse(DsKvRawPutResponse&& from) noexcept
    : DsKvRawPutResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawPutResponse& operator=(DsKvRawPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawPutResponse& default_instance();

  static inline const DsKvRawPutResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawPutResponse*>(
               &_DsKvRawPutResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DsKvRawPutResponse* other);
  friend void swap(DsKvRawPutResponse& a, DsKvRawPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawPutResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawPutResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawPutResponse& from);
  void MergeFrom(const DsKvRawPutResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawPutResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawPutResponse& resp() const;
  ::kvrpcpb::KvRawPutResponse* mutable_resp();
  ::kvrpcpb::KvRawPutResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawPutResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawPutResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawPutRequest) */ {
 public:
  KvRawPutRequest();
  virtual ~KvRawPutRequest();

  KvRawPutRequest(const KvRawPutRequest& from);

  inline KvRawPutRequest& operator=(const KvRawPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawPutRequest(KvRawPutRequest&& from) noexcept
    : KvRawPutRequest() {
    *this = ::std::move(from);
  }

  inline KvRawPutRequest& operator=(KvRawPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawPutRequest& default_instance();

  static inline const KvRawPutRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawPutRequest*>(
               &_KvRawPutRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(KvRawPutRequest* other);
  friend void swap(KvRawPutRequest& a, KvRawPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawPutRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawPutRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawPutRequest& from);
  void MergeFrom(const KvRawPutRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawPutResponse) */ {
 public:
  KvRawPutResponse();
  virtual ~KvRawPutResponse();

  KvRawPutResponse(const KvRawPutResponse& from);

  inline KvRawPutResponse& operator=(const KvRawPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawPutResponse(KvRawPutResponse&& from) noexcept
    : KvRawPutResponse() {
    *this = ::std::move(from);
  }

  inline KvRawPutResponse& operator=(KvRawPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawPutResponse& default_instance();

  static inline const KvRawPutResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawPutResponse*>(
               &_KvRawPutResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(KvRawPutResponse* other);
  friend void swap(KvRawPutResponse& a, KvRawPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawPutResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawPutResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawPutResponse& from);
  void MergeFrom(const KvRawPutResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawDeleteRequest) */ {
 public:
  DsKvRawDeleteRequest();
  virtual ~DsKvRawDeleteRequest();

  DsKvRawDeleteRequest(const DsKvRawDeleteRequest& from);

  inline DsKvRawDeleteRequest& operator=(const DsKvRawDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawDeleteRequest(DsKvRawDeleteRequest&& from) noexcept
    : DsKvRawDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawDeleteRequest& operator=(DsKvRawDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawDeleteRequest& default_instance();

  static inline const DsKvRawDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawDeleteRequest*>(
               &_DsKvRawDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DsKvRawDeleteRequest* other);
  friend void swap(DsKvRawDeleteRequest& a, DsKvRawDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawDeleteRequest& from);
  void MergeFrom(const DsKvRawDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawDeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawDeleteRequest& req() const;
  ::kvrpcpb::KvRawDeleteRequest* mutable_req();
  ::kvrpcpb::KvRawDeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawDeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawDeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawDeleteResponse) */ {
 public:
  DsKvRawDeleteResponse();
  virtual ~DsKvRawDeleteResponse();

  DsKvRawDeleteResponse(const DsKvRawDeleteResponse& from);

  inline DsKvRawDeleteResponse& operator=(const DsKvRawDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawDeleteResponse(DsKvRawDeleteResponse&& from) noexcept
    : DsKvRawDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawDeleteResponse& operator=(DsKvRawDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawDeleteResponse& default_instance();

  static inline const DsKvRawDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawDeleteResponse*>(
               &_DsKvRawDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DsKvRawDeleteResponse* other);
  friend void swap(DsKvRawDeleteResponse& a, DsKvRawDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawDeleteResponse& from);
  void MergeFrom(const DsKvRawDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawDeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawDeleteResponse& resp() const;
  ::kvrpcpb::KvRawDeleteResponse* mutable_resp();
  ::kvrpcpb::KvRawDeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawDeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawDeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawDeleteRequest) */ {
 public:
  KvRawDeleteRequest();
  virtual ~KvRawDeleteRequest();

  KvRawDeleteRequest(const KvRawDeleteRequest& from);

  inline KvRawDeleteRequest& operator=(const KvRawDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawDeleteRequest(KvRawDeleteRequest&& from) noexcept
    : KvRawDeleteRequest() {
    *this = ::std::move(from);
  }

  inline KvRawDeleteRequest& operator=(KvRawDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawDeleteRequest& default_instance();

  static inline const KvRawDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawDeleteRequest*>(
               &_KvRawDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(KvRawDeleteRequest* other);
  friend void swap(KvRawDeleteRequest& a, KvRawDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawDeleteRequest& from);
  void MergeFrom(const KvRawDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawDeleteResponse) */ {
 public:
  KvRawDeleteResponse();
  virtual ~KvRawDeleteResponse();

  KvRawDeleteResponse(const KvRawDeleteResponse& from);

  inline KvRawDeleteResponse& operator=(const KvRawDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawDeleteResponse(KvRawDeleteResponse&& from) noexcept
    : KvRawDeleteResponse() {
    *this = ::std::move(from);
  }

  inline KvRawDeleteResponse& operator=(KvRawDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawDeleteResponse& default_instance();

  static inline const KvRawDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawDeleteResponse*>(
               &_KvRawDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(KvRawDeleteResponse* other);
  friend void swap(KvRawDeleteResponse& a, KvRawDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawDeleteResponse& from);
  void MergeFrom(const KvRawDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvPairRawExecute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvPairRawExecute) */ {
 public:
  KvPairRawExecute();
  virtual ~KvPairRawExecute();

  KvPairRawExecute(const KvPairRawExecute& from);

  inline KvPairRawExecute& operator=(const KvPairRawExecute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvPairRawExecute(KvPairRawExecute&& from) noexcept
    : KvPairRawExecute() {
    *this = ::std::move(from);
  }

  inline KvPairRawExecute& operator=(KvPairRawExecute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPairRawExecute& default_instance();

  static inline const KvPairRawExecute* internal_default_instance() {
    return reinterpret_cast<const KvPairRawExecute*>(
               &_KvPairRawExecute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(KvPairRawExecute* other);
  friend void swap(KvPairRawExecute& a, KvPairRawExecute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvPairRawExecute* New() const PROTOBUF_FINAL { return New(NULL); }

  KvPairRawExecute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvPairRawExecute& from);
  void MergeFrom(const KvPairRawExecute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvPairRawExecute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.KvPair kv_pair = 2;
  bool has_kv_pair() const;
  void clear_kv_pair();
  static const int kKvPairFieldNumber = 2;
  const ::kvrpcpb::KvPair& kv_pair() const;
  ::kvrpcpb::KvPair* mutable_kv_pair();
  ::kvrpcpb::KvPair* release_kv_pair();
  void set_allocated_kv_pair(::kvrpcpb::KvPair* kv_pair);

  // .kvrpcpb.ExecuteType do = 1;
  void clear_do_();
  static const int kDoFieldNumber = 1;
  ::kvrpcpb::ExecuteType do_() const;
  void set_do_(::kvrpcpb::ExecuteType value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvPairRawExecute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::KvPair* kv_pair_;
  int do__;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawExecuteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawExecuteRequest) */ {
 public:
  DsKvRawExecuteRequest();
  virtual ~DsKvRawExecuteRequest();

  DsKvRawExecuteRequest(const DsKvRawExecuteRequest& from);

  inline DsKvRawExecuteRequest& operator=(const DsKvRawExecuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawExecuteRequest(DsKvRawExecuteRequest&& from) noexcept
    : DsKvRawExecuteRequest() {
    *this = ::std::move(from);
  }

  inline DsKvRawExecuteRequest& operator=(DsKvRawExecuteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawExecuteRequest& default_instance();

  static inline const DsKvRawExecuteRequest* internal_default_instance() {
    return reinterpret_cast<const DsKvRawExecuteRequest*>(
               &_DsKvRawExecuteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(DsKvRawExecuteRequest* other);
  friend void swap(DsKvRawExecuteRequest& a, DsKvRawExecuteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawExecuteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawExecuteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawExecuteRequest& from);
  void MergeFrom(const DsKvRawExecuteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawExecuteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.KvRawExecuteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::KvRawExecuteRequest& req() const;
  ::kvrpcpb::KvRawExecuteRequest* mutable_req();
  ::kvrpcpb::KvRawExecuteRequest* release_req();
  void set_allocated_req(::kvrpcpb::KvRawExecuteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawExecuteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::KvRawExecuteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsKvRawExecuteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsKvRawExecuteResponse) */ {
 public:
  DsKvRawExecuteResponse();
  virtual ~DsKvRawExecuteResponse();

  DsKvRawExecuteResponse(const DsKvRawExecuteResponse& from);

  inline DsKvRawExecuteResponse& operator=(const DsKvRawExecuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsKvRawExecuteResponse(DsKvRawExecuteResponse&& from) noexcept
    : DsKvRawExecuteResponse() {
    *this = ::std::move(from);
  }

  inline DsKvRawExecuteResponse& operator=(DsKvRawExecuteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsKvRawExecuteResponse& default_instance();

  static inline const DsKvRawExecuteResponse* internal_default_instance() {
    return reinterpret_cast<const DsKvRawExecuteResponse*>(
               &_DsKvRawExecuteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DsKvRawExecuteResponse* other);
  friend void swap(DsKvRawExecuteResponse& a, DsKvRawExecuteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsKvRawExecuteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsKvRawExecuteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsKvRawExecuteResponse& from);
  void MergeFrom(const DsKvRawExecuteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsKvRawExecuteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.KvRawExecuteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::KvRawExecuteResponse& resp() const;
  ::kvrpcpb::KvRawExecuteResponse* mutable_resp();
  ::kvrpcpb::KvRawExecuteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::KvRawExecuteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsKvRawExecuteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::KvRawExecuteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawExecuteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawExecuteRequest) */ {
 public:
  KvRawExecuteRequest();
  virtual ~KvRawExecuteRequest();

  KvRawExecuteRequest(const KvRawExecuteRequest& from);

  inline KvRawExecuteRequest& operator=(const KvRawExecuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawExecuteRequest(KvRawExecuteRequest&& from) noexcept
    : KvRawExecuteRequest() {
    *this = ::std::move(from);
  }

  inline KvRawExecuteRequest& operator=(KvRawExecuteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawExecuteRequest& default_instance();

  static inline const KvRawExecuteRequest* internal_default_instance() {
    return reinterpret_cast<const KvRawExecuteRequest*>(
               &_KvRawExecuteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(KvRawExecuteRequest* other);
  friend void swap(KvRawExecuteRequest& a, KvRawExecuteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawExecuteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawExecuteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawExecuteRequest& from);
  void MergeFrom(const KvRawExecuteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawExecuteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPairRawExecute execs = 1;
  int execs_size() const;
  void clear_execs();
  static const int kExecsFieldNumber = 1;
  const ::kvrpcpb::KvPairRawExecute& execs(int index) const;
  ::kvrpcpb::KvPairRawExecute* mutable_execs(int index);
  ::kvrpcpb::KvPairRawExecute* add_execs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >*
      mutable_execs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >&
      execs() const;

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawExecuteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute > execs_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvRawExecuteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvRawExecuteResponse) */ {
 public:
  KvRawExecuteResponse();
  virtual ~KvRawExecuteResponse();

  KvRawExecuteResponse(const KvRawExecuteResponse& from);

  inline KvRawExecuteResponse& operator=(const KvRawExecuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvRawExecuteResponse(KvRawExecuteResponse&& from) noexcept
    : KvRawExecuteResponse() {
    *this = ::std::move(from);
  }

  inline KvRawExecuteResponse& operator=(KvRawExecuteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvRawExecuteResponse& default_instance();

  static inline const KvRawExecuteResponse* internal_default_instance() {
    return reinterpret_cast<const KvRawExecuteResponse*>(
               &_KvRawExecuteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(KvRawExecuteResponse* other);
  friend void swap(KvRawExecuteResponse& a, KvRawExecuteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvRawExecuteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  KvRawExecuteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KvRawExecuteResponse& from);
  void MergeFrom(const KvRawExecuteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KvRawExecuteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvRawExecuteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Scope) */ {
 public:
  Scope();
  virtual ~Scope();

  Scope(const Scope& from);

  inline Scope& operator=(const Scope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scope(Scope&& from) noexcept
    : Scope() {
    *this = ::std::move(from);
  }

  inline Scope& operator=(Scope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scope& default_instance();

  static inline const Scope* internal_default_instance() {
    return reinterpret_cast<const Scope*>(
               &_Scope_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Scope* other);
  friend void swap(Scope& a, Scope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scope* New() const PROTOBUF_FINAL { return New(NULL); }

  Scope* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Scope& from);
  void MergeFrom(const Scope& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Scope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Scope)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SelectField) */ {
 public:
  SelectField();
  virtual ~SelectField();

  SelectField(const SelectField& from);

  inline SelectField& operator=(const SelectField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectField(SelectField&& from) noexcept
    : SelectField() {
    *this = ::std::move(from);
  }

  inline SelectField& operator=(SelectField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectField& default_instance();

  static inline const SelectField* internal_default_instance() {
    return reinterpret_cast<const SelectField*>(
               &_SelectField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(SelectField* other);
  friend void swap(SelectField& a, SelectField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectField* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectField& from);
  void MergeFrom(const SelectField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SelectField_Type Type;
  static const Type Column =
    SelectField_Type_Column;
  static const Type AggreFunction =
    SelectField_Type_AggreFunction;
  static inline bool Type_IsValid(int value) {
    return SelectField_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SelectField_Type_Type_MIN;
  static const Type Type_MAX =
    SelectField_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SelectField_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SelectField_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SelectField_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SelectField_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string aggre_func = 2;
  void clear_aggre_func();
  static const int kAggreFuncFieldNumber = 2;
  const ::std::string& aggre_func() const;
  void set_aggre_func(const ::std::string& value);
  #if LANG_CXX11
  void set_aggre_func(::std::string&& value);
  #endif
  void set_aggre_func(const char* value);
  void set_aggre_func(const char* value, size_t size);
  ::std::string* mutable_aggre_func();
  ::std::string* release_aggre_func();
  void set_allocated_aggre_func(::std::string* aggre_func);

  // .metapb.Column column = 3;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 3;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // .kvrpcpb.SelectField.Type typ = 1;
  void clear_typ();
  static const int kTypFieldNumber = 1;
  ::kvrpcpb::SelectField_Type typ() const;
  void set_typ(::kvrpcpb::SelectField_Type value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SelectField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr aggre_func_;
  ::metapb::Column* column_;
  int typ_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Match : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Match) */ {
 public:
  Match();
  virtual ~Match();

  Match(const Match& from);

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(Match&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();

  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Match* other);
  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Match* New() const PROTOBUF_FINAL { return New(NULL); }

  Match* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Match* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  const ::std::string& threshold() const;
  void set_threshold(const ::std::string& value);
  #if LANG_CXX11
  void set_threshold(::std::string&& value);
  #endif
  void set_threshold(const char* value);
  void set_threshold(const void* value, size_t size);
  ::std::string* mutable_threshold();
  ::std::string* release_threshold();
  void set_allocated_threshold(::std::string* threshold);

  // .metapb.Column column = 1;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 1;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // .kvrpcpb.MatchType match_type = 3;
  void clear_match_type();
  static const int kMatchTypeFieldNumber = 3;
  ::kvrpcpb::MatchType match_type() const;
  void set_match_type(::kvrpcpb::MatchType value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Match)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr threshold_;
  ::metapb::Column* column_;
  int match_type_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Limit* other);
  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const PROTOBUF_FINAL { return New(NULL); }

  Limit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // uint64 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Limit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 count_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsSelectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsSelectRequest) */ {
 public:
  DsSelectRequest();
  virtual ~DsSelectRequest();

  DsSelectRequest(const DsSelectRequest& from);

  inline DsSelectRequest& operator=(const DsSelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsSelectRequest(DsSelectRequest&& from) noexcept
    : DsSelectRequest() {
    *this = ::std::move(from);
  }

  inline DsSelectRequest& operator=(DsSelectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsSelectRequest& default_instance();

  static inline const DsSelectRequest* internal_default_instance() {
    return reinterpret_cast<const DsSelectRequest*>(
               &_DsSelectRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(DsSelectRequest* other);
  friend void swap(DsSelectRequest& a, DsSelectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsSelectRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsSelectRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsSelectRequest& from);
  void MergeFrom(const DsSelectRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsSelectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.SelectRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::SelectRequest& req() const;
  ::kvrpcpb::SelectRequest* mutable_req();
  ::kvrpcpb::SelectRequest* release_req();
  void set_allocated_req(::kvrpcpb::SelectRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsSelectRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::SelectRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SelectRequest) */ {
 public:
  SelectRequest();
  virtual ~SelectRequest();

  SelectRequest(const SelectRequest& from);

  inline SelectRequest& operator=(const SelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectRequest(SelectRequest&& from) noexcept
    : SelectRequest() {
    *this = ::std::move(from);
  }

  inline SelectRequest& operator=(SelectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectRequest& default_instance();

  static inline const SelectRequest* internal_default_instance() {
    return reinterpret_cast<const SelectRequest*>(
               &_SelectRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(SelectRequest* other);
  friend void swap(SelectRequest& a, SelectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectRequest& from);
  void MergeFrom(const SelectRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.SelectField field_list = 3;
  int field_list_size() const;
  void clear_field_list();
  static const int kFieldListFieldNumber = 3;
  const ::kvrpcpb::SelectField& field_list(int index) const;
  ::kvrpcpb::SelectField* mutable_field_list(int index);
  ::kvrpcpb::SelectField* add_field_list();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >*
      mutable_field_list();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >&
      field_list() const;

  // repeated .kvrpcpb.Match where_filters = 4;
  int where_filters_size() const;
  void clear_where_filters();
  static const int kWhereFiltersFieldNumber = 4;
  const ::kvrpcpb::Match& where_filters(int index) const;
  ::kvrpcpb::Match* mutable_where_filters(int index);
  ::kvrpcpb::Match* add_where_filters();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
      mutable_where_filters();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
      where_filters() const;

  // repeated .metapb.Column group_bys = 5;
  int group_bys_size() const;
  void clear_group_bys();
  static const int kGroupBysFieldNumber = 5;
  const ::metapb::Column& group_bys(int index) const;
  ::metapb::Column* mutable_group_bys(int index);
  ::metapb::Column* add_group_bys();
  ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
      mutable_group_bys();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
      group_bys() const;

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // .kvrpcpb.Limit limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  const ::kvrpcpb::Limit& limit() const;
  ::kvrpcpb::Limit* mutable_limit();
  ::kvrpcpb::Limit* release_limit();
  void set_allocated_limit(::kvrpcpb::Limit* limit);

  // .exprpb.Expr where_expr = 10;
  bool has_where_expr() const;
  void clear_where_expr();
  static const int kWhereExprFieldNumber = 10;
  const ::exprpb::Expr& where_expr() const;
  ::exprpb::Expr* mutable_where_expr();
  ::exprpb::Expr* release_where_expr();
  void set_allocated_where_expr(::exprpb::Expr* where_expr);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SelectRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField > field_list_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match > where_filters_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Column > group_bys_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  ::kvrpcpb::Limit* limit_;
  ::exprpb::Expr* where_expr_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Row : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Row) */ {
 public:
  Row();
  virtual ~Row();

  Row(const Row& from);

  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Row(Row&& from) noexcept
    : Row() {
    *this = ::std::move(from);
  }

  inline Row& operator=(Row&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Row& default_instance();

  static inline const Row* internal_default_instance() {
    return reinterpret_cast<const Row*>(
               &_Row_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Row* other);
  friend void swap(Row& a, Row& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Row* New() const PROTOBUF_FINAL { return New(NULL); }

  Row* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Row& from);
  void MergeFrom(const Row& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Row* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 aggred_counts = 3;
  int aggred_counts_size() const;
  void clear_aggred_counts();
  static const int kAggredCountsFieldNumber = 3;
  ::google::protobuf::int64 aggred_counts(int index) const;
  void set_aggred_counts(int index, ::google::protobuf::int64 value);
  void add_aggred_counts(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      aggred_counts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_aggred_counts();

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes fields = 2;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::std::string& fields() const;
  void set_fields(const ::std::string& value);
  #if LANG_CXX11
  void set_fields(::std::string&& value);
  #endif
  void set_fields(const char* value);
  void set_fields(const void* value, size_t size);
  ::std::string* mutable_fields();
  ::std::string* release_fields();
  void set_allocated_fields(::std::string* fields);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Row)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > aggred_counts_;
  mutable int _aggred_counts_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr fields_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsSelectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsSelectResponse) */ {
 public:
  DsSelectResponse();
  virtual ~DsSelectResponse();

  DsSelectResponse(const DsSelectResponse& from);

  inline DsSelectResponse& operator=(const DsSelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsSelectResponse(DsSelectResponse&& from) noexcept
    : DsSelectResponse() {
    *this = ::std::move(from);
  }

  inline DsSelectResponse& operator=(DsSelectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsSelectResponse& default_instance();

  static inline const DsSelectResponse* internal_default_instance() {
    return reinterpret_cast<const DsSelectResponse*>(
               &_DsSelectResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(DsSelectResponse* other);
  friend void swap(DsSelectResponse& a, DsSelectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsSelectResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsSelectResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsSelectResponse& from);
  void MergeFrom(const DsSelectResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsSelectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.SelectResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::SelectResponse& resp() const;
  ::kvrpcpb::SelectResponse* mutable_resp();
  ::kvrpcpb::SelectResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::SelectResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsSelectResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::SelectResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SelectResponse) */ {
 public:
  SelectResponse();
  virtual ~SelectResponse();

  SelectResponse(const SelectResponse& from);

  inline SelectResponse& operator=(const SelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectResponse(SelectResponse&& from) noexcept
    : SelectResponse() {
    *this = ::std::move(from);
  }

  inline SelectResponse& operator=(SelectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectResponse& default_instance();

  static inline const SelectResponse* internal_default_instance() {
    return reinterpret_cast<const SelectResponse*>(
               &_SelectResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(SelectResponse* other);
  friend void swap(SelectResponse& a, SelectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectResponse& from);
  void MergeFrom(const SelectResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Row rows = 2;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  const ::kvrpcpb::Row& rows(int index) const;
  ::kvrpcpb::Row* mutable_rows(int index);
  ::kvrpcpb::Row* add_rows();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >&
      rows() const;

  // uint64 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SelectResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row > rows_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(KeyValue* other);
  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes Value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // uint64 TTL = 3;
  void clear_ttl();
  static const int kTTLFieldNumber = 3;
  ::google::protobuf::uint64 ttl() const;
  void set_ttl(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint64 ttl_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsInsertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsInsertRequest) */ {
 public:
  DsInsertRequest();
  virtual ~DsInsertRequest();

  DsInsertRequest(const DsInsertRequest& from);

  inline DsInsertRequest& operator=(const DsInsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsInsertRequest(DsInsertRequest&& from) noexcept
    : DsInsertRequest() {
    *this = ::std::move(from);
  }

  inline DsInsertRequest& operator=(DsInsertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsInsertRequest& default_instance();

  static inline const DsInsertRequest* internal_default_instance() {
    return reinterpret_cast<const DsInsertRequest*>(
               &_DsInsertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(DsInsertRequest* other);
  friend void swap(DsInsertRequest& a, DsInsertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsInsertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsInsertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsInsertRequest& from);
  void MergeFrom(const DsInsertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsInsertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.InsertRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::InsertRequest& req() const;
  ::kvrpcpb::InsertRequest* mutable_req();
  ::kvrpcpb::InsertRequest* release_req();
  void set_allocated_req(::kvrpcpb::InsertRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsInsertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::InsertRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsInsertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsInsertResponse) */ {
 public:
  DsInsertResponse();
  virtual ~DsInsertResponse();

  DsInsertResponse(const DsInsertResponse& from);

  inline DsInsertResponse& operator=(const DsInsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsInsertResponse(DsInsertResponse&& from) noexcept
    : DsInsertResponse() {
    *this = ::std::move(from);
  }

  inline DsInsertResponse& operator=(DsInsertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsInsertResponse& default_instance();

  static inline const DsInsertResponse* internal_default_instance() {
    return reinterpret_cast<const DsInsertResponse*>(
               &_DsInsertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(DsInsertResponse* other);
  friend void swap(DsInsertResponse& a, DsInsertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsInsertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsInsertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsInsertResponse& from);
  void MergeFrom(const DsInsertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsInsertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.InsertResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::InsertResponse& resp() const;
  ::kvrpcpb::InsertResponse* mutable_resp();
  ::kvrpcpb::InsertResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::InsertResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsInsertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::InsertResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.InsertRequest) */ {
 public:
  InsertRequest();
  virtual ~InsertRequest();

  InsertRequest(const InsertRequest& from);

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertRequest& default_instance();

  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(InsertRequest* other);
  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  InsertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InsertRequest& from);
  void MergeFrom(const InsertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InsertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KeyValue rows = 1;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  const ::kvrpcpb::KeyValue& rows(int index) const;
  ::kvrpcpb::KeyValue* mutable_rows(int index);
  ::kvrpcpb::KeyValue* add_rows();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >&
      rows() const;

  // bool check_duplicate = 2;
  void clear_check_duplicate();
  static const int kCheckDuplicateFieldNumber = 2;
  bool check_duplicate() const;
  void set_check_duplicate(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.InsertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue > rows_;
  bool check_duplicate_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.InsertResponse) */ {
 public:
  InsertResponse();
  virtual ~InsertResponse();

  InsertResponse(const InsertResponse& from);

  inline InsertResponse& operator=(const InsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertResponse(InsertResponse&& from) noexcept
    : InsertResponse() {
    *this = ::std::move(from);
  }

  inline InsertResponse& operator=(InsertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertResponse& default_instance();

  static inline const InsertResponse* internal_default_instance() {
    return reinterpret_cast<const InsertResponse*>(
               &_InsertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(InsertResponse* other);
  friend void swap(InsertResponse& a, InsertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  InsertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InsertResponse& from);
  void MergeFrom(const InsertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InsertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes duplicate_key = 3;
  void clear_duplicate_key();
  static const int kDuplicateKeyFieldNumber = 3;
  const ::std::string& duplicate_key() const;
  void set_duplicate_key(const ::std::string& value);
  #if LANG_CXX11
  void set_duplicate_key(::std::string&& value);
  #endif
  void set_duplicate_key(const char* value);
  void set_duplicate_key(const void* value, size_t size);
  ::std::string* mutable_duplicate_key();
  ::std::string* release_duplicate_key();
  void set_allocated_duplicate_key(::std::string* duplicate_key);

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.InsertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr duplicate_key_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchInsertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchInsertRequest) */ {
 public:
  BatchInsertRequest();
  virtual ~BatchInsertRequest();

  BatchInsertRequest(const BatchInsertRequest& from);

  inline BatchInsertRequest& operator=(const BatchInsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchInsertRequest(BatchInsertRequest&& from) noexcept
    : BatchInsertRequest() {
    *this = ::std::move(from);
  }

  inline BatchInsertRequest& operator=(BatchInsertRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchInsertRequest& default_instance();

  static inline const BatchInsertRequest* internal_default_instance() {
    return reinterpret_cast<const BatchInsertRequest*>(
               &_BatchInsertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(BatchInsertRequest* other);
  friend void swap(BatchInsertRequest& a, BatchInsertRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchInsertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchInsertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchInsertRequest& from);
  void MergeFrom(const BatchInsertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchInsertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.InsertRequest reqs = 1;
  int reqs_size() const;
  void clear_reqs();
  static const int kReqsFieldNumber = 1;
  const ::kvrpcpb::InsertRequest& reqs(int index) const;
  ::kvrpcpb::InsertRequest* mutable_reqs(int index);
  ::kvrpcpb::InsertRequest* add_reqs();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >*
      mutable_reqs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >&
      reqs() const;

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchInsertRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest > reqs_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchInsertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchInsertResponse) */ {
 public:
  BatchInsertResponse();
  virtual ~BatchInsertResponse();

  BatchInsertResponse(const BatchInsertResponse& from);

  inline BatchInsertResponse& operator=(const BatchInsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchInsertResponse(BatchInsertResponse&& from) noexcept
    : BatchInsertResponse() {
    *this = ::std::move(from);
  }

  inline BatchInsertResponse& operator=(BatchInsertResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchInsertResponse& default_instance();

  static inline const BatchInsertResponse* internal_default_instance() {
    return reinterpret_cast<const BatchInsertResponse*>(
               &_BatchInsertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(BatchInsertResponse* other);
  friend void swap(BatchInsertResponse& a, BatchInsertResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchInsertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchInsertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchInsertResponse& from);
  void MergeFrom(const BatchInsertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchInsertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.InsertResponse resps = 2;
  int resps_size() const;
  void clear_resps();
  static const int kRespsFieldNumber = 2;
  const ::kvrpcpb::InsertResponse& resps(int index) const;
  ::kvrpcpb::InsertResponse* mutable_resps(int index);
  ::kvrpcpb::InsertResponse* add_resps();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >*
      mutable_resps();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >&
      resps() const;

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchInsertResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse > resps_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsDeleteRequest) */ {
 public:
  DsDeleteRequest();
  virtual ~DsDeleteRequest();

  DsDeleteRequest(const DsDeleteRequest& from);

  inline DsDeleteRequest& operator=(const DsDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsDeleteRequest(DsDeleteRequest&& from) noexcept
    : DsDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DsDeleteRequest& operator=(DsDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsDeleteRequest& default_instance();

  static inline const DsDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DsDeleteRequest*>(
               &_DsDeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(DsDeleteRequest* other);
  friend void swap(DsDeleteRequest& a, DsDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsDeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsDeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsDeleteRequest& from);
  void MergeFrom(const DsDeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.DeleteRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::DeleteRequest& req() const;
  ::kvrpcpb::DeleteRequest* mutable_req();
  ::kvrpcpb::DeleteRequest* release_req();
  void set_allocated_req(::kvrpcpb::DeleteRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::DeleteRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsDeleteResponse) */ {
 public:
  DsDeleteResponse();
  virtual ~DsDeleteResponse();

  DsDeleteResponse(const DsDeleteResponse& from);

  inline DsDeleteResponse& operator=(const DsDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsDeleteResponse(DsDeleteResponse&& from) noexcept
    : DsDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DsDeleteResponse& operator=(DsDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsDeleteResponse& default_instance();

  static inline const DsDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DsDeleteResponse*>(
               &_DsDeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(DsDeleteResponse* other);
  friend void swap(DsDeleteResponse& a, DsDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsDeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsDeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsDeleteResponse& from);
  void MergeFrom(const DsDeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.DeleteResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::DeleteResponse& resp() const;
  ::kvrpcpb::DeleteResponse* mutable_resp();
  ::kvrpcpb::DeleteResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::DeleteResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::DeleteResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Match where_filters = 3;
  int where_filters_size() const;
  void clear_where_filters();
  static const int kWhereFiltersFieldNumber = 3;
  const ::kvrpcpb::Match& where_filters(int index) const;
  ::kvrpcpb::Match* mutable_where_filters(int index);
  ::kvrpcpb::Match* add_where_filters();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
      mutable_where_filters();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
      where_filters() const;

  // repeated uint64 indexs = 4;
  int indexs_size() const;
  void clear_indexs();
  static const int kIndexsFieldNumber = 4;
  ::google::protobuf::uint64 indexs(int index) const;
  void set_indexs(int index, ::google::protobuf::uint64 value);
  void add_indexs(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      indexs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_indexs();

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match > where_filters_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > indexs_;
  mutable int _indexs_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();

  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Field* other);
  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const PROTOBUF_FINAL { return New(NULL); }

  Field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .metapb.Column column = 1;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 1;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // .kvrpcpb.FieldType field_type = 3;
  void clear_field_type();
  static const int kFieldTypeFieldNumber = 3;
  ::kvrpcpb::FieldType field_type() const;
  void set_field_type(::kvrpcpb::FieldType value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::metapb::Column* column_;
  int field_type_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.UpdateRequest) */ {
 public:
  UpdateRequest();
  virtual ~UpdateRequest();

  UpdateRequest(const UpdateRequest& from);

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRequest& default_instance();

  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(UpdateRequest* other);
  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateRequest& from);
  void MergeFrom(const UpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Field fields = 3;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 3;
  const ::kvrpcpb::Field& fields(int index) const;
  ::kvrpcpb::Field* mutable_fields(int index);
  ::kvrpcpb::Field* add_fields();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Field >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Field >&
      fields() const;

  // repeated .kvrpcpb.Match where_filters = 4;
  int where_filters_size() const;
  void clear_where_filters();
  static const int kWhereFiltersFieldNumber = 4;
  const ::kvrpcpb::Match& where_filters(int index) const;
  ::kvrpcpb::Match* mutable_where_filters(int index);
  ::kvrpcpb::Match* add_where_filters();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
      mutable_where_filters();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
      where_filters() const;

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // .kvrpcpb.Limit limit = 5;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 5;
  const ::kvrpcpb::Limit& limit() const;
  ::kvrpcpb::Limit* mutable_limit();
  ::kvrpcpb::Limit* release_limit();
  void set_allocated_limit(::kvrpcpb::Limit* limit);

  // @@protoc_insertion_point(class_scope:kvrpcpb.UpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Field > fields_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match > where_filters_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  ::kvrpcpb::Limit* limit_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUpdateRequest) */ {
 public:
  DsUpdateRequest();
  virtual ~DsUpdateRequest();

  DsUpdateRequest(const DsUpdateRequest& from);

  inline DsUpdateRequest& operator=(const DsUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUpdateRequest(DsUpdateRequest&& from) noexcept
    : DsUpdateRequest() {
    *this = ::std::move(from);
  }

  inline DsUpdateRequest& operator=(DsUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUpdateRequest& default_instance();

  static inline const DsUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const DsUpdateRequest*>(
               &_DsUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(DsUpdateRequest* other);
  friend void swap(DsUpdateRequest& a, DsUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUpdateRequest& from);
  void MergeFrom(const DsUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.UpdateRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::UpdateRequest& req() const;
  ::kvrpcpb::UpdateRequest* mutable_req();
  ::kvrpcpb::UpdateRequest* release_req();
  void set_allocated_req(::kvrpcpb::UpdateRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::UpdateRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.UpdateResponse) */ {
 public:
  UpdateResponse();
  virtual ~UpdateResponse();

  UpdateResponse(const UpdateResponse& from);

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateResponse& default_instance();

  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(UpdateResponse* other);
  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateResponse& from);
  void MergeFrom(const UpdateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 affected_keys = 2;
  void clear_affected_keys();
  static const int kAffectedKeysFieldNumber = 2;
  ::google::protobuf::uint64 affected_keys() const;
  void set_affected_keys(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.UpdateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 affected_keys_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUpdateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUpdateResponse) */ {
 public:
  DsUpdateResponse();
  virtual ~DsUpdateResponse();

  DsUpdateResponse(const DsUpdateResponse& from);

  inline DsUpdateResponse& operator=(const DsUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUpdateResponse(DsUpdateResponse&& from) noexcept
    : DsUpdateResponse() {
    *this = ::std::move(from);
  }

  inline DsUpdateResponse& operator=(DsUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUpdateResponse& default_instance();

  static inline const DsUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const DsUpdateResponse*>(
               &_DsUpdateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(DsUpdateResponse* other);
  friend void swap(DsUpdateResponse& a, DsUpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUpdateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUpdateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUpdateResponse& from);
  void MergeFrom(const DsUpdateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.UpdateResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::UpdateResponse& resp() const;
  ::kvrpcpb::UpdateResponse* mutable_resp();
  ::kvrpcpb::UpdateResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::UpdateResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUpdateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::UpdateResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.IndexScanRequest) */ {
 public:
  IndexScanRequest();
  virtual ~IndexScanRequest();

  IndexScanRequest(const IndexScanRequest& from);

  inline IndexScanRequest& operator=(const IndexScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexScanRequest(IndexScanRequest&& from) noexcept
    : IndexScanRequest() {
    *this = ::std::move(from);
  }

  inline IndexScanRequest& operator=(IndexScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexScanRequest& default_instance();

  static inline const IndexScanRequest* internal_default_instance() {
    return reinterpret_cast<const IndexScanRequest*>(
               &_IndexScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(IndexScanRequest* other);
  friend void swap(IndexScanRequest& a, IndexScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IndexScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IndexScanRequest& from);
  void MergeFrom(const IndexScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IndexScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // .kvrpcpb.Limit limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  const ::kvrpcpb::Limit& limit() const;
  ::kvrpcpb::Limit* mutable_limit();
  ::kvrpcpb::Limit* release_limit();
  void set_allocated_limit(::kvrpcpb::Limit* limit);

  // @@protoc_insertion_point(class_scope:kvrpcpb.IndexScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  ::kvrpcpb::Limit* limit_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsIndexScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsIndexScanRequest) */ {
 public:
  DsIndexScanRequest();
  virtual ~DsIndexScanRequest();

  DsIndexScanRequest(const DsIndexScanRequest& from);

  inline DsIndexScanRequest& operator=(const DsIndexScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsIndexScanRequest(DsIndexScanRequest&& from) noexcept
    : DsIndexScanRequest() {
    *this = ::std::move(from);
  }

  inline DsIndexScanRequest& operator=(DsIndexScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsIndexScanRequest& default_instance();

  static inline const DsIndexScanRequest* internal_default_instance() {
    return reinterpret_cast<const DsIndexScanRequest*>(
               &_DsIndexScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(DsIndexScanRequest* other);
  friend void swap(DsIndexScanRequest& a, DsIndexScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsIndexScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsIndexScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsIndexScanRequest& from);
  void MergeFrom(const DsIndexScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsIndexScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.IndexScanRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::IndexScanRequest& req() const;
  ::kvrpcpb::IndexScanRequest* mutable_req();
  ::kvrpcpb::IndexScanRequest* release_req();
  void set_allocated_req(::kvrpcpb::IndexScanRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsIndexScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::IndexScanRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.IndexScanResponse) */ {
 public:
  IndexScanResponse();
  virtual ~IndexScanResponse();

  IndexScanResponse(const IndexScanResponse& from);

  inline IndexScanResponse& operator=(const IndexScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexScanResponse(IndexScanResponse&& from) noexcept
    : IndexScanResponse() {
    *this = ::std::move(from);
  }

  inline IndexScanResponse& operator=(IndexScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexScanResponse& default_instance();

  static inline const IndexScanResponse* internal_default_instance() {
    return reinterpret_cast<const IndexScanResponse*>(
               &_IndexScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(IndexScanResponse* other);
  friend void swap(IndexScanResponse& a, IndexScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IndexScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IndexScanResponse& from);
  void MergeFrom(const IndexScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IndexScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes pk_values = 1;
  int pk_values_size() const;
  void clear_pk_values();
  static const int kPkValuesFieldNumber = 1;
  const ::std::string& pk_values(int index) const;
  ::std::string* mutable_pk_values(int index);
  void set_pk_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_pk_values(int index, ::std::string&& value);
  #endif
  void set_pk_values(int index, const char* value);
  void set_pk_values(int index, const void* value, size_t size);
  ::std::string* add_pk_values();
  void add_pk_values(const ::std::string& value);
  #if LANG_CXX11
  void add_pk_values(::std::string&& value);
  #endif
  void add_pk_values(const char* value);
  void add_pk_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& pk_values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pk_values();

  // @@protoc_insertion_point(class_scope:kvrpcpb.IndexScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pk_values_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsIndexScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsIndexScanResponse) */ {
 public:
  DsIndexScanResponse();
  virtual ~DsIndexScanResponse();

  DsIndexScanResponse(const DsIndexScanResponse& from);

  inline DsIndexScanResponse& operator=(const DsIndexScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsIndexScanResponse(DsIndexScanResponse&& from) noexcept
    : DsIndexScanResponse() {
    *this = ::std::move(from);
  }

  inline DsIndexScanResponse& operator=(DsIndexScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsIndexScanResponse& default_instance();

  static inline const DsIndexScanResponse* internal_default_instance() {
    return reinterpret_cast<const DsIndexScanResponse*>(
               &_DsIndexScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(DsIndexScanResponse* other);
  friend void swap(DsIndexScanResponse& a, DsIndexScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsIndexScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsIndexScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsIndexScanResponse& from);
  void MergeFrom(const DsIndexScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsIndexScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.IndexScanResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::IndexScanResponse& resp() const;
  ::kvrpcpb::IndexScanResponse* mutable_resp();
  ::kvrpcpb::IndexScanResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::IndexScanResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsIndexScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::IndexScanResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockValue) */ {
 public:
  LockValue();
  virtual ~LockValue();

  LockValue(const LockValue& from);

  inline LockValue& operator=(const LockValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockValue(LockValue&& from) noexcept
    : LockValue() {
    *this = ::std::move(from);
  }

  inline LockValue& operator=(LockValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockValue& default_instance();

  static inline const LockValue* internal_default_instance() {
    return reinterpret_cast<const LockValue*>(
               &_LockValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(LockValue* other);
  friend void swap(LockValue& a, LockValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockValue* New() const PROTOBUF_FINAL { return New(NULL); }

  LockValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockValue& from);
  void MergeFrom(const LockValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string by = 7;
  void clear_by();
  static const int kByFieldNumber = 7;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // int64 delete_time = 4;
  void clear_delete_time();
  static const int kDeleteTimeFieldNumber = 4;
  ::google::protobuf::int64 delete_time() const;
  void set_delete_time(::google::protobuf::int64 value);

  // int64 update_time = 5;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 5;
  ::google::protobuf::int64 update_time() const;
  void set_update_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  ::google::protobuf::int64 delete_time_;
  ::google::protobuf::int64 update_time_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockRequest) */ {
 public:
  LockRequest();
  virtual ~LockRequest();

  LockRequest(const LockRequest& from);

  inline LockRequest& operator=(const LockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockRequest(LockRequest&& from) noexcept
    : LockRequest() {
    *this = ::std::move(from);
  }

  inline LockRequest& operator=(LockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockRequest& default_instance();

  static inline const LockRequest* internal_default_instance() {
    return reinterpret_cast<const LockRequest*>(
               &_LockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(LockRequest* other);
  friend void swap(LockRequest& a, LockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockRequest& from);
  void MergeFrom(const LockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.LockValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::kvrpcpb::LockValue& value() const;
  ::kvrpcpb::LockValue* mutable_value();
  ::kvrpcpb::LockValue* release_value();
  void set_allocated_value(::kvrpcpb::LockValue* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::LockValue* value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockRequest) */ {
 public:
  DsLockRequest();
  virtual ~DsLockRequest();

  DsLockRequest(const DsLockRequest& from);

  inline DsLockRequest& operator=(const DsLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockRequest(DsLockRequest&& from) noexcept
    : DsLockRequest() {
    *this = ::std::move(from);
  }

  inline DsLockRequest& operator=(DsLockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockRequest& default_instance();

  static inline const DsLockRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockRequest*>(
               &_DsLockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(DsLockRequest* other);
  friend void swap(DsLockRequest& a, DsLockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockRequest& from);
  void MergeFrom(const DsLockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockRequest& req() const;
  ::kvrpcpb::LockRequest* mutable_req();
  ::kvrpcpb::LockRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockResponse) */ {
 public:
  LockResponse();
  virtual ~LockResponse();

  LockResponse(const LockResponse& from);

  inline LockResponse& operator=(const LockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockResponse(LockResponse&& from) noexcept
    : LockResponse() {
    *this = ::std::move(from);
  }

  inline LockResponse& operator=(LockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockResponse& default_instance();

  static inline const LockResponse* internal_default_instance() {
    return reinterpret_cast<const LockResponse*>(
               &_LockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(LockResponse* other);
  friend void swap(LockResponse& a, LockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockResponse& from);
  void MergeFrom(const LockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int64 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int64 code() const;
  void set_code(::google::protobuf::int64 value);

  // int64 update_time = 4;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  ::google::protobuf::int64 update_time() const;
  void set_update_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int64 code_;
  ::google::protobuf::int64 update_time_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockInfo) */ {
 public:
  LockInfo();
  virtual ~LockInfo();

  LockInfo(const LockInfo& from);

  inline LockInfo& operator=(const LockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockInfo(LockInfo&& from) noexcept
    : LockInfo() {
    *this = ::std::move(from);
  }

  inline LockInfo& operator=(LockInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInfo& default_instance();

  static inline const LockInfo* internal_default_instance() {
    return reinterpret_cast<const LockInfo*>(
               &_LockInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(LockInfo* other);
  friend void swap(LockInfo& a, LockInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LockInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockInfo& from);
  void MergeFrom(const LockInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.LockValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::kvrpcpb::LockValue& value() const;
  ::kvrpcpb::LockValue* mutable_value();
  ::kvrpcpb::LockValue* release_value();
  void set_allocated_value(::kvrpcpb::LockValue* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::LockValue* value_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockScanResponse) */ {
 public:
  LockScanResponse();
  virtual ~LockScanResponse();

  LockScanResponse(const LockScanResponse& from);

  inline LockScanResponse& operator=(const LockScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockScanResponse(LockScanResponse&& from) noexcept
    : LockScanResponse() {
    *this = ::std::move(from);
  }

  inline LockScanResponse& operator=(LockScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockScanResponse& default_instance();

  static inline const LockScanResponse* internal_default_instance() {
    return reinterpret_cast<const LockScanResponse*>(
               &_LockScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(LockScanResponse* other);
  friend void swap(LockScanResponse& a, LockScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockScanResponse& from);
  void MergeFrom(const LockScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.LockInfo info = 1;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::kvrpcpb::LockInfo& info(int index) const;
  ::kvrpcpb::LockInfo* mutable_info(int index);
  ::kvrpcpb::LockInfo* add_info();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
      mutable_info();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
      info() const;

  // bytes last_key = 2;
  void clear_last_key();
  static const int kLastKeyFieldNumber = 2;
  const ::std::string& last_key() const;
  void set_last_key(const ::std::string& value);
  #if LANG_CXX11
  void set_last_key(::std::string&& value);
  #endif
  void set_last_key(const char* value);
  void set_last_key(const void* value, size_t size);
  ::std::string* mutable_last_key();
  ::std::string* release_last_key();
  void set_allocated_last_key(::std::string* last_key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo > info_;
  ::google::protobuf::internal::ArenaStringPtr last_key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockResponse) */ {
 public:
  DsLockResponse();
  virtual ~DsLockResponse();

  DsLockResponse(const DsLockResponse& from);

  inline DsLockResponse& operator=(const DsLockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockResponse(DsLockResponse&& from) noexcept
    : DsLockResponse() {
    *this = ::std::move(from);
  }

  inline DsLockResponse& operator=(DsLockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockResponse& default_instance();

  static inline const DsLockResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockResponse*>(
               &_DsLockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(DsLockResponse* other);
  friend void swap(DsLockResponse& a, DsLockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockResponse& from);
  void MergeFrom(const DsLockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockUpdateRequest) */ {
 public:
  LockUpdateRequest();
  virtual ~LockUpdateRequest();

  LockUpdateRequest(const LockUpdateRequest& from);

  inline LockUpdateRequest& operator=(const LockUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockUpdateRequest(LockUpdateRequest&& from) noexcept
    : LockUpdateRequest() {
    *this = ::std::move(from);
  }

  inline LockUpdateRequest& operator=(LockUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockUpdateRequest& default_instance();

  static inline const LockUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const LockUpdateRequest*>(
               &_LockUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(LockUpdateRequest* other);
  friend void swap(LockUpdateRequest& a, LockUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockUpdateRequest& from);
  void MergeFrom(const LockUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bytes update_value = 6;
  void clear_update_value();
  static const int kUpdateValueFieldNumber = 6;
  const ::std::string& update_value() const;
  void set_update_value(const ::std::string& value);
  #if LANG_CXX11
  void set_update_value(::std::string&& value);
  #endif
  void set_update_value(const char* value);
  void set_update_value(const void* value, size_t size);
  ::std::string* mutable_update_value();
  ::std::string* release_update_value();
  void set_allocated_update_value(::std::string* update_value);

  // string by = 11;
  void clear_by();
  static const int kByFieldNumber = 11;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // int64 delete_time = 5;
  void clear_delete_time();
  static const int kDeleteTimeFieldNumber = 5;
  ::google::protobuf::int64 delete_time() const;
  void set_delete_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr update_value_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  ::google::protobuf::int64 delete_time_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockUpdateRequest) */ {
 public:
  DsLockUpdateRequest();
  virtual ~DsLockUpdateRequest();

  DsLockUpdateRequest(const DsLockUpdateRequest& from);

  inline DsLockUpdateRequest& operator=(const DsLockUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockUpdateRequest(DsLockUpdateRequest&& from) noexcept
    : DsLockUpdateRequest() {
    *this = ::std::move(from);
  }

  inline DsLockUpdateRequest& operator=(DsLockUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockUpdateRequest& default_instance();

  static inline const DsLockUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockUpdateRequest*>(
               &_DsLockUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(DsLockUpdateRequest* other);
  friend void swap(DsLockUpdateRequest& a, DsLockUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockUpdateRequest& from);
  void MergeFrom(const DsLockUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockUpdateRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockUpdateRequest& req() const;
  ::kvrpcpb::LockUpdateRequest* mutable_req();
  ::kvrpcpb::LockUpdateRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockUpdateRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockUpdateRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockUpdateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockUpdateResponse) */ {
 public:
  DsLockUpdateResponse();
  virtual ~DsLockUpdateResponse();

  DsLockUpdateResponse(const DsLockUpdateResponse& from);

  inline DsLockUpdateResponse& operator=(const DsLockUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockUpdateResponse(DsLockUpdateResponse&& from) noexcept
    : DsLockUpdateResponse() {
    *this = ::std::move(from);
  }

  inline DsLockUpdateResponse& operator=(DsLockUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockUpdateResponse& default_instance();

  static inline const DsLockUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockUpdateResponse*>(
               &_DsLockUpdateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(DsLockUpdateResponse* other);
  friend void swap(DsLockUpdateResponse& a, DsLockUpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockUpdateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockUpdateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockUpdateResponse& from);
  void MergeFrom(const DsLockUpdateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockUpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockUpdateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.UnlockRequest) */ {
 public:
  UnlockRequest();
  virtual ~UnlockRequest();

  UnlockRequest(const UnlockRequest& from);

  inline UnlockRequest& operator=(const UnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockRequest(UnlockRequest&& from) noexcept
    : UnlockRequest() {
    *this = ::std::move(from);
  }

  inline UnlockRequest& operator=(UnlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockRequest& default_instance();

  static inline const UnlockRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockRequest*>(
               &_UnlockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(UnlockRequest* other);
  friend void swap(UnlockRequest& a, UnlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockRequest& from);
  void MergeFrom(const UnlockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string by = 11;
  void clear_by();
  static const int kByFieldNumber = 11;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // @@protoc_insertion_point(class_scope:kvrpcpb.UnlockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockRequest) */ {
 public:
  DsUnlockRequest();
  virtual ~DsUnlockRequest();

  DsUnlockRequest(const DsUnlockRequest& from);

  inline DsUnlockRequest& operator=(const DsUnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockRequest(DsUnlockRequest&& from) noexcept
    : DsUnlockRequest() {
    *this = ::std::move(from);
  }

  inline DsUnlockRequest& operator=(DsUnlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockRequest& default_instance();

  static inline const DsUnlockRequest* internal_default_instance() {
    return reinterpret_cast<const DsUnlockRequest*>(
               &_DsUnlockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(DsUnlockRequest* other);
  friend void swap(DsUnlockRequest& a, DsUnlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockRequest& from);
  void MergeFrom(const DsUnlockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.UnlockRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::UnlockRequest& req() const;
  ::kvrpcpb::UnlockRequest* mutable_req();
  ::kvrpcpb::UnlockRequest* release_req();
  void set_allocated_req(::kvrpcpb::UnlockRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::UnlockRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockResponse) */ {
 public:
  DsUnlockResponse();
  virtual ~DsUnlockResponse();

  DsUnlockResponse(const DsUnlockResponse& from);

  inline DsUnlockResponse& operator=(const DsUnlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockResponse(DsUnlockResponse&& from) noexcept
    : DsUnlockResponse() {
    *this = ::std::move(from);
  }

  inline DsUnlockResponse& operator=(DsUnlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockResponse& default_instance();

  static inline const DsUnlockResponse* internal_default_instance() {
    return reinterpret_cast<const DsUnlockResponse*>(
               &_DsUnlockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(DsUnlockResponse* other);
  friend void swap(DsUnlockResponse& a, DsUnlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockResponse& from);
  void MergeFrom(const DsUnlockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnlockForceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.UnlockForceRequest) */ {
 public:
  UnlockForceRequest();
  virtual ~UnlockForceRequest();

  UnlockForceRequest(const UnlockForceRequest& from);

  inline UnlockForceRequest& operator=(const UnlockForceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockForceRequest(UnlockForceRequest&& from) noexcept
    : UnlockForceRequest() {
    *this = ::std::move(from);
  }

  inline UnlockForceRequest& operator=(UnlockForceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockForceRequest& default_instance();

  static inline const UnlockForceRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockForceRequest*>(
               &_UnlockForceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(UnlockForceRequest* other);
  friend void swap(UnlockForceRequest& a, UnlockForceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockForceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockForceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockForceRequest& from);
  void MergeFrom(const UnlockForceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockForceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string by = 11;
  void clear_by();
  static const int kByFieldNumber = 11;
  const ::std::string& by() const;
  void set_by(const ::std::string& value);
  #if LANG_CXX11
  void set_by(::std::string&& value);
  #endif
  void set_by(const char* value);
  void set_by(const char* value, size_t size);
  ::std::string* mutable_by();
  ::std::string* release_by();
  void set_allocated_by(::std::string* by);

  // @@protoc_insertion_point(class_scope:kvrpcpb.UnlockForceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr by_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockForceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockForceRequest) */ {
 public:
  DsUnlockForceRequest();
  virtual ~DsUnlockForceRequest();

  DsUnlockForceRequest(const DsUnlockForceRequest& from);

  inline DsUnlockForceRequest& operator=(const DsUnlockForceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockForceRequest(DsUnlockForceRequest&& from) noexcept
    : DsUnlockForceRequest() {
    *this = ::std::move(from);
  }

  inline DsUnlockForceRequest& operator=(DsUnlockForceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockForceRequest& default_instance();

  static inline const DsUnlockForceRequest* internal_default_instance() {
    return reinterpret_cast<const DsUnlockForceRequest*>(
               &_DsUnlockForceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(DsUnlockForceRequest* other);
  friend void swap(DsUnlockForceRequest& a, DsUnlockForceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockForceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockForceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockForceRequest& from);
  void MergeFrom(const DsUnlockForceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockForceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.UnlockForceRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::UnlockForceRequest& req() const;
  ::kvrpcpb::UnlockForceRequest* mutable_req();
  ::kvrpcpb::UnlockForceRequest* release_req();
  void set_allocated_req(::kvrpcpb::UnlockForceRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockForceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::UnlockForceRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsUnlockForceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsUnlockForceResponse) */ {
 public:
  DsUnlockForceResponse();
  virtual ~DsUnlockForceResponse();

  DsUnlockForceResponse(const DsUnlockForceResponse& from);

  inline DsUnlockForceResponse& operator=(const DsUnlockForceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsUnlockForceResponse(DsUnlockForceResponse&& from) noexcept
    : DsUnlockForceResponse() {
    *this = ::std::move(from);
  }

  inline DsUnlockForceResponse& operator=(DsUnlockForceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsUnlockForceResponse& default_instance();

  static inline const DsUnlockForceResponse* internal_default_instance() {
    return reinterpret_cast<const DsUnlockForceResponse*>(
               &_DsUnlockForceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(DsUnlockForceResponse* other);
  friend void swap(DsUnlockForceResponse& a, DsUnlockForceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsUnlockForceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsUnlockForceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsUnlockForceResponse& from);
  void MergeFrom(const DsUnlockForceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsUnlockForceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockResponse& resp() const;
  ::kvrpcpb::LockResponse* mutable_resp();
  ::kvrpcpb::LockResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsUnlockForceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockScanRequest) */ {
 public:
  LockScanRequest();
  virtual ~LockScanRequest();

  LockScanRequest(const LockScanRequest& from);

  inline LockScanRequest& operator=(const LockScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockScanRequest(LockScanRequest&& from) noexcept
    : LockScanRequest() {
    *this = ::std::move(from);
  }

  inline LockScanRequest& operator=(LockScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockScanRequest& default_instance();

  static inline const LockScanRequest* internal_default_instance() {
    return reinterpret_cast<const LockScanRequest*>(
               &_LockScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(LockScanRequest* other);
  friend void swap(LockScanRequest& a, LockScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockScanRequest& from);
  void MergeFrom(const LockScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // uint32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  ::google::protobuf::uint32 count_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockScanRequest) */ {
 public:
  DsLockScanRequest();
  virtual ~DsLockScanRequest();

  DsLockScanRequest(const DsLockScanRequest& from);

  inline DsLockScanRequest& operator=(const DsLockScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockScanRequest(DsLockScanRequest&& from) noexcept
    : DsLockScanRequest() {
    *this = ::std::move(from);
  }

  inline DsLockScanRequest& operator=(DsLockScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockScanRequest& default_instance();

  static inline const DsLockScanRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockScanRequest*>(
               &_DsLockScanRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(DsLockScanRequest* other);
  friend void swap(DsLockScanRequest& a, DsLockScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockScanRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockScanRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockScanRequest& from);
  void MergeFrom(const DsLockScanRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockScanRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockScanRequest& req() const;
  ::kvrpcpb::LockScanRequest* mutable_req();
  ::kvrpcpb::LockScanRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockScanRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockScanRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockScanResponse) */ {
 public:
  DsLockScanResponse();
  virtual ~DsLockScanResponse();

  DsLockScanResponse(const DsLockScanResponse& from);

  inline DsLockScanResponse& operator=(const DsLockScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockScanResponse(DsLockScanResponse&& from) noexcept
    : DsLockScanResponse() {
    *this = ::std::move(from);
  }

  inline DsLockScanResponse& operator=(DsLockScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockScanResponse& default_instance();

  static inline const DsLockScanResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockScanResponse*>(
               &_DsLockScanResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(DsLockScanResponse* other);
  friend void swap(DsLockScanResponse& a, DsLockScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockScanResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockScanResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockScanResponse& from);
  void MergeFrom(const DsLockScanResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockScanResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockScanResponse& resp() const;
  ::kvrpcpb::LockScanResponse* mutable_resp();
  ::kvrpcpb::LockScanResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockScanResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockScanResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockGetRequest) */ {
 public:
  LockGetRequest();
  virtual ~LockGetRequest();

  LockGetRequest(const LockGetRequest& from);

  inline LockGetRequest& operator=(const LockGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockGetRequest(LockGetRequest&& from) noexcept
    : LockGetRequest() {
    *this = ::std::move(from);
  }

  inline LockGetRequest& operator=(LockGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockGetRequest& default_instance();

  static inline const LockGetRequest* internal_default_instance() {
    return reinterpret_cast<const LockGetRequest*>(
               &_LockGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(LockGetRequest* other);
  friend void swap(LockGetRequest& a, LockGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockGetRequest& from);
  void MergeFrom(const LockGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockGetResponse) */ {
 public:
  LockGetResponse();
  virtual ~LockGetResponse();

  LockGetResponse(const LockGetResponse& from);

  inline LockGetResponse& operator=(const LockGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockGetResponse(LockGetResponse&& from) noexcept
    : LockGetResponse() {
    *this = ::std::move(from);
  }

  inline LockGetResponse& operator=(LockGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockGetResponse& default_instance();

  static inline const LockGetResponse* internal_default_instance() {
    return reinterpret_cast<const LockGetResponse*>(
               &_LockGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void Swap(LockGetResponse* other);
  friend void swap(LockGetResponse& a, LockGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockGetResponse& from);
  void MergeFrom(const LockGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .kvrpcpb.LockValue value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::kvrpcpb::LockValue& value() const;
  ::kvrpcpb::LockValue* mutable_value();
  ::kvrpcpb::LockValue* release_value();
  void set_allocated_value(::kvrpcpb::LockValue* value);

  // int64 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int64 code() const;
  void set_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::kvrpcpb::LockValue* value_;
  ::google::protobuf::int64 code_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockGetRequest) */ {
 public:
  DsLockGetRequest();
  virtual ~DsLockGetRequest();

  DsLockGetRequest(const DsLockGetRequest& from);

  inline DsLockGetRequest& operator=(const DsLockGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockGetRequest(DsLockGetRequest&& from) noexcept
    : DsLockGetRequest() {
    *this = ::std::move(from);
  }

  inline DsLockGetRequest& operator=(DsLockGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockGetRequest& default_instance();

  static inline const DsLockGetRequest* internal_default_instance() {
    return reinterpret_cast<const DsLockGetRequest*>(
               &_DsLockGetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(DsLockGetRequest* other);
  friend void swap(DsLockGetRequest& a, DsLockGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockGetRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockGetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockGetRequest& from);
  void MergeFrom(const DsLockGetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .kvrpcpb.LockGetRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::kvrpcpb::LockGetRequest& req() const;
  ::kvrpcpb::LockGetRequest* mutable_req();
  ::kvrpcpb::LockGetRequest* release_req();
  void set_allocated_req(::kvrpcpb::LockGetRequest* req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::kvrpcpb::LockGetRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsLockGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DsLockGetResponse) */ {
 public:
  DsLockGetResponse();
  virtual ~DsLockGetResponse();

  DsLockGetResponse(const DsLockGetResponse& from);

  inline DsLockGetResponse& operator=(const DsLockGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsLockGetResponse(DsLockGetResponse&& from) noexcept
    : DsLockGetResponse() {
    *this = ::std::move(from);
  }

  inline DsLockGetResponse& operator=(DsLockGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsLockGetResponse& default_instance();

  static inline const DsLockGetResponse* internal_default_instance() {
    return reinterpret_cast<const DsLockGetResponse*>(
               &_DsLockGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(DsLockGetResponse* other);
  friend void swap(DsLockGetResponse& a, DsLockGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsLockGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsLockGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsLockGetResponse& from);
  void MergeFrom(const DsLockGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsLockGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .kvrpcpb.LockGetResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::kvrpcpb::LockGetResponse& resp() const;
  ::kvrpcpb::LockGetResponse* mutable_resp();
  ::kvrpcpb::LockGetResponse* release_resp();
  void set_allocated_resp(::kvrpcpb::LockGetResponse* resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DsLockGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::kvrpcpb::LockGetResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_kvrpcpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KvPair

// bytes key = 1;
inline void KvPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvPair::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.key)
  return key_.GetNoArena();
}
inline void KvPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.key)
}
#if LANG_CXX11
inline void KvPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvPair.key)
}
#endif
inline void KvPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.key)
}
inline void KvPair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.key)
}
inline ::std::string* KvPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.key)
}

// bytes value = 2;
inline void KvPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvPair::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.value)
  return value_.GetNoArena();
}
inline void KvPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.value)
}
#if LANG_CXX11
inline void KvPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvPair.value)
}
#endif
inline void KvPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.value)
}
inline void KvPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.value)
}
inline ::std::string* KvPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.value)
}

// -------------------------------------------------------------------

// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.cluster_id)
}

// uint64 trace_id = 3;
inline void RequestHeader::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::trace_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.trace_id)
  return trace_id_;
}
inline void RequestHeader::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.trace_id)
}

// uint64 range_id = 4;
inline void RequestHeader::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::range_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.range_id)
  return range_id_;
}
inline void RequestHeader::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.range_id)
}

// .metapb.RangeEpoch range_epoch = 5;
inline bool RequestHeader::has_range_epoch() const {
  return this != internal_default_instance() && range_epoch_ != NULL;
}
inline void RequestHeader::clear_range_epoch() {
  if (GetArenaNoVirtual() == NULL && range_epoch_ != NULL) delete range_epoch_;
  range_epoch_ = NULL;
}
inline const ::metapb::RangeEpoch& RequestHeader::range_epoch() const {
  const ::metapb::RangeEpoch* p = range_epoch_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.range_epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::RangeEpoch*>(
      &::metapb::_RangeEpoch_default_instance_);
}
inline ::metapb::RangeEpoch* RequestHeader::mutable_range_epoch() {
  
  if (range_epoch_ == NULL) {
    range_epoch_ = new ::metapb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RequestHeader.range_epoch)
  return range_epoch_;
}
inline ::metapb::RangeEpoch* RequestHeader::release_range_epoch() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RequestHeader.range_epoch)
  
  ::metapb::RangeEpoch* temp = range_epoch_;
  range_epoch_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_range_epoch(::metapb::RangeEpoch* range_epoch) {
  delete range_epoch_;
  range_epoch_ = range_epoch;
  if (range_epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RequestHeader.range_epoch)
}

// uint64 read_index = 6;
inline void RequestHeader::clear_read_index() {
  read_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::read_index() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RequestHeader.read_index)
  return read_index_;
}
inline void RequestHeader::set_read_index(::google::protobuf::uint64 value) {
  
  read_index_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RequestHeader.read_index)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResponseHeader.cluster_id)
}

// uint64 trace_id = 3;
inline void ResponseHeader::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::trace_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.trace_id)
  return trace_id_;
}
inline void ResponseHeader::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResponseHeader.trace_id)
}

// .errorpb.Error error = 5;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::errorpb::Error& ResponseHeader::error() const {
  const ::errorpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::errorpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResponseHeader.error)
  return error_;
}
inline ::errorpb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResponseHeader.error)
  
  ::errorpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_error(::errorpb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResponseHeader.error)
}

// uint64 apply_index = 6;
inline void ResponseHeader::clear_apply_index() {
  apply_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::apply_index() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResponseHeader.apply_index)
  return apply_index_;
}
inline void ResponseHeader::set_apply_index(::google::protobuf::uint64 value) {
  
  apply_index_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResponseHeader.apply_index)
}

// -------------------------------------------------------------------

// DsKvRawGetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawGetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawGetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawGetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawGetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawGetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawGetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetRequest.header)
}

// .kvrpcpb.KvRawGetRequest req = 2;
inline bool DsKvRawGetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawGetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawGetRequest& DsKvRawGetRequest::req() const {
  const ::kvrpcpb::KvRawGetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawGetRequest*>(
      &::kvrpcpb::_KvRawGetRequest_default_instance_);
}
inline ::kvrpcpb::KvRawGetRequest* DsKvRawGetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawGetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawGetRequest* DsKvRawGetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetRequest.req)
  
  ::kvrpcpb::KvRawGetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawGetRequest::set_allocated_req(::kvrpcpb::KvRawGetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawGetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawGetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawGetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawGetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawGetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawGetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawGetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetResponse.header)
}

// .kvrpcpb.KvRawGetResponse resp = 2;
inline bool DsKvRawGetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawGetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawGetResponse& DsKvRawGetResponse::resp() const {
  const ::kvrpcpb::KvRawGetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawGetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawGetResponse*>(
      &::kvrpcpb::_KvRawGetResponse_default_instance_);
}
inline ::kvrpcpb::KvRawGetResponse* DsKvRawGetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawGetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawGetResponse* DsKvRawGetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawGetResponse.resp)
  
  ::kvrpcpb::KvRawGetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawGetResponse::set_allocated_resp(::kvrpcpb::KvRawGetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawGetResponse.resp)
}

// -------------------------------------------------------------------

// KvRawGetRequest

// bytes key = 1;
inline void KvRawGetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawGetRequest.key)
  return key_.GetNoArena();
}
inline void KvRawGetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawGetRequest.key)
}
#if LANG_CXX11
inline void KvRawGetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawGetRequest.key)
}
#endif
inline void KvRawGetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawGetRequest.key)
}
inline void KvRawGetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawGetRequest.key)
}
inline ::std::string* KvRawGetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawGetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawGetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawGetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawGetRequest.key)
}

// -------------------------------------------------------------------

// KvRawGetResponse

// int32 code = 1;
inline void KvRawGetResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawGetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawGetResponse.code)
  return code_;
}
inline void KvRawGetResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawGetResponse.code)
}

// bytes value = 2;
inline void KvRawGetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawGetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawGetResponse.value)
  return value_.GetNoArena();
}
inline void KvRawGetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawGetResponse.value)
}
#if LANG_CXX11
inline void KvRawGetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawGetResponse.value)
}
#endif
inline void KvRawGetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawGetResponse.value)
}
inline void KvRawGetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawGetResponse.value)
}
inline ::std::string* KvRawGetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawGetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawGetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawGetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawGetResponse.value)
}

// -------------------------------------------------------------------

// DsKvRawPutRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawPutRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawPutRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawPutRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawPutRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawPutRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawPutRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutRequest.header)
}

// .kvrpcpb.KvRawPutRequest req = 2;
inline bool DsKvRawPutRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawPutRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawPutRequest& DsKvRawPutRequest::req() const {
  const ::kvrpcpb::KvRawPutRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawPutRequest*>(
      &::kvrpcpb::_KvRawPutRequest_default_instance_);
}
inline ::kvrpcpb::KvRawPutRequest* DsKvRawPutRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawPutRequest* DsKvRawPutRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutRequest.req)
  
  ::kvrpcpb::KvRawPutRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawPutRequest::set_allocated_req(::kvrpcpb::KvRawPutRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawPutResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawPutResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawPutResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawPutResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawPutResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawPutResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawPutResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutResponse.header)
}

// .kvrpcpb.KvRawPutResponse resp = 2;
inline bool DsKvRawPutResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawPutResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawPutResponse& DsKvRawPutResponse::resp() const {
  const ::kvrpcpb::KvRawPutResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawPutResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawPutResponse*>(
      &::kvrpcpb::_KvRawPutResponse_default_instance_);
}
inline ::kvrpcpb::KvRawPutResponse* DsKvRawPutResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawPutResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawPutResponse* DsKvRawPutResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawPutResponse.resp)
  
  ::kvrpcpb::KvRawPutResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawPutResponse::set_allocated_resp(::kvrpcpb::KvRawPutResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawPutResponse.resp)
}

// -------------------------------------------------------------------

// KvRawPutRequest

// bytes key = 1;
inline void KvRawPutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawPutRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawPutRequest.key)
  return key_.GetNoArena();
}
inline void KvRawPutRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawPutRequest.key)
}
#if LANG_CXX11
inline void KvRawPutRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawPutRequest.key)
}
#endif
inline void KvRawPutRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawPutRequest.key)
}
inline void KvRawPutRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawPutRequest.key)
}
inline ::std::string* KvRawPutRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawPutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawPutRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawPutRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawPutRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawPutRequest.key)
}

// bytes value = 2;
inline void KvRawPutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawPutRequest::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawPutRequest.value)
  return value_.GetNoArena();
}
inline void KvRawPutRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawPutRequest.value)
}
#if LANG_CXX11
inline void KvRawPutRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawPutRequest.value)
}
#endif
inline void KvRawPutRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawPutRequest.value)
}
inline void KvRawPutRequest::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawPutRequest.value)
}
inline ::std::string* KvRawPutRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawPutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawPutRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawPutRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawPutRequest.value)
}

// -------------------------------------------------------------------

// KvRawPutResponse

// int32 code = 1;
inline void KvRawPutResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawPutResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawPutResponse.code)
  return code_;
}
inline void KvRawPutResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawPutResponse.code)
}

// -------------------------------------------------------------------

// DsKvRawDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteRequest.header)
}

// .kvrpcpb.KvRawDeleteRequest req = 2;
inline bool DsKvRawDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawDeleteRequest& DsKvRawDeleteRequest::req() const {
  const ::kvrpcpb::KvRawDeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawDeleteRequest*>(
      &::kvrpcpb::_KvRawDeleteRequest_default_instance_);
}
inline ::kvrpcpb::KvRawDeleteRequest* DsKvRawDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawDeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawDeleteRequest* DsKvRawDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteRequest.req)
  
  ::kvrpcpb::KvRawDeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawDeleteRequest::set_allocated_req(::kvrpcpb::KvRawDeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteResponse.header)
}

// .kvrpcpb.KvRawDeleteResponse resp = 2;
inline bool DsKvRawDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawDeleteResponse& DsKvRawDeleteResponse::resp() const {
  const ::kvrpcpb::KvRawDeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawDeleteResponse*>(
      &::kvrpcpb::_KvRawDeleteResponse_default_instance_);
}
inline ::kvrpcpb::KvRawDeleteResponse* DsKvRawDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawDeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawDeleteResponse* DsKvRawDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawDeleteResponse.resp)
  
  ::kvrpcpb::KvRawDeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawDeleteResponse::set_allocated_resp(::kvrpcpb::KvRawDeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawDeleteResponse.resp)
}

// -------------------------------------------------------------------

// KvRawDeleteRequest

// bytes key = 1;
inline void KvRawDeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvRawDeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawDeleteRequest.key)
  return key_.GetNoArena();
}
inline void KvRawDeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawDeleteRequest.key)
}
#if LANG_CXX11
inline void KvRawDeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvRawDeleteRequest.key)
}
#endif
inline void KvRawDeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvRawDeleteRequest.key)
}
inline void KvRawDeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvRawDeleteRequest.key)
}
inline ::std::string* KvRawDeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawDeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvRawDeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvRawDeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvRawDeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvRawDeleteRequest.key)
}

// -------------------------------------------------------------------

// KvRawDeleteResponse

// int32 code = 1;
inline void KvRawDeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawDeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawDeleteResponse.code)
  return code_;
}
inline void KvRawDeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawDeleteResponse.code)
}

// -------------------------------------------------------------------

// KvPairRawExecute

// .kvrpcpb.ExecuteType do = 1;
inline void KvPairRawExecute::clear_do_() {
  do__ = 0;
}
inline ::kvrpcpb::ExecuteType KvPairRawExecute::do_() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPairRawExecute.do)
  return static_cast< ::kvrpcpb::ExecuteType >(do__);
}
inline void KvPairRawExecute::set_do_(::kvrpcpb::ExecuteType value) {
  
  do__ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPairRawExecute.do)
}

// .kvrpcpb.KvPair kv_pair = 2;
inline bool KvPairRawExecute::has_kv_pair() const {
  return this != internal_default_instance() && kv_pair_ != NULL;
}
inline void KvPairRawExecute::clear_kv_pair() {
  if (GetArenaNoVirtual() == NULL && kv_pair_ != NULL) delete kv_pair_;
  kv_pair_ = NULL;
}
inline const ::kvrpcpb::KvPair& KvPairRawExecute::kv_pair() const {
  const ::kvrpcpb::KvPair* p = kv_pair_;
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPairRawExecute.kv_pair)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvPair*>(
      &::kvrpcpb::_KvPair_default_instance_);
}
inline ::kvrpcpb::KvPair* KvPairRawExecute::mutable_kv_pair() {
  
  if (kv_pair_ == NULL) {
    kv_pair_ = new ::kvrpcpb::KvPair;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPairRawExecute.kv_pair)
  return kv_pair_;
}
inline ::kvrpcpb::KvPair* KvPairRawExecute::release_kv_pair() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPairRawExecute.kv_pair)
  
  ::kvrpcpb::KvPair* temp = kv_pair_;
  kv_pair_ = NULL;
  return temp;
}
inline void KvPairRawExecute::set_allocated_kv_pair(::kvrpcpb::KvPair* kv_pair) {
  delete kv_pair_;
  kv_pair_ = kv_pair;
  if (kv_pair) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPairRawExecute.kv_pair)
}

// -------------------------------------------------------------------

// DsKvRawExecuteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsKvRawExecuteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawExecuteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsKvRawExecuteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsKvRawExecuteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsKvRawExecuteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawExecuteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteRequest.header)
}

// .kvrpcpb.KvRawExecuteRequest req = 2;
inline bool DsKvRawExecuteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsKvRawExecuteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::KvRawExecuteRequest& DsKvRawExecuteRequest::req() const {
  const ::kvrpcpb::KvRawExecuteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawExecuteRequest*>(
      &::kvrpcpb::_KvRawExecuteRequest_default_instance_);
}
inline ::kvrpcpb::KvRawExecuteRequest* DsKvRawExecuteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::KvRawExecuteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteRequest.req)
  return req_;
}
inline ::kvrpcpb::KvRawExecuteRequest* DsKvRawExecuteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteRequest.req)
  
  ::kvrpcpb::KvRawExecuteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsKvRawExecuteRequest::set_allocated_req(::kvrpcpb::KvRawExecuteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteRequest.req)
}

// -------------------------------------------------------------------

// DsKvRawExecuteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsKvRawExecuteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsKvRawExecuteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsKvRawExecuteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsKvRawExecuteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsKvRawExecuteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsKvRawExecuteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteResponse.header)
}

// .kvrpcpb.KvRawExecuteResponse resp = 2;
inline bool DsKvRawExecuteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsKvRawExecuteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::KvRawExecuteResponse& DsKvRawExecuteResponse::resp() const {
  const ::kvrpcpb::KvRawExecuteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsKvRawExecuteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KvRawExecuteResponse*>(
      &::kvrpcpb::_KvRawExecuteResponse_default_instance_);
}
inline ::kvrpcpb::KvRawExecuteResponse* DsKvRawExecuteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::KvRawExecuteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsKvRawExecuteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::KvRawExecuteResponse* DsKvRawExecuteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsKvRawExecuteResponse.resp)
  
  ::kvrpcpb::KvRawExecuteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsKvRawExecuteResponse::set_allocated_resp(::kvrpcpb::KvRawExecuteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsKvRawExecuteResponse.resp)
}

// -------------------------------------------------------------------

// KvRawExecuteRequest

// repeated .kvrpcpb.KvPairRawExecute execs = 1;
inline int KvRawExecuteRequest::execs_size() const {
  return execs_.size();
}
inline void KvRawExecuteRequest::clear_execs() {
  execs_.Clear();
}
inline const ::kvrpcpb::KvPairRawExecute& KvRawExecuteRequest::execs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_.Get(index);
}
inline ::kvrpcpb::KvPairRawExecute* KvRawExecuteRequest::mutable_execs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_.Mutable(index);
}
inline ::kvrpcpb::KvPairRawExecute* KvRawExecuteRequest::add_execs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >*
KvRawExecuteRequest::mutable_execs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.KvRawExecuteRequest.execs)
  return &execs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPairRawExecute >&
KvRawExecuteRequest::execs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.KvRawExecuteRequest.execs)
  return execs_;
}

// -------------------------------------------------------------------

// KvRawExecuteResponse

// int32 code = 1;
inline void KvRawExecuteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 KvRawExecuteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvRawExecuteResponse.code)
  return code_;
}
inline void KvRawExecuteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KvRawExecuteResponse.code)
}

// -------------------------------------------------------------------

// Scope

// bytes start = 1;
inline void Scope::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scope::start() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Scope.start)
  return start_.GetNoArena();
}
inline void Scope::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Scope.start)
}
#if LANG_CXX11
inline void Scope::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Scope.start)
}
#endif
inline void Scope::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Scope.start)
}
inline void Scope::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Scope.start)
}
inline ::std::string* Scope::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Scope.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scope::release_start() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Scope.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scope::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Scope.start)
}

// bytes limit = 2;
inline void Scope::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Scope::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Scope.limit)
  return limit_.GetNoArena();
}
inline void Scope::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Scope.limit)
}
#if LANG_CXX11
inline void Scope::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Scope.limit)
}
#endif
inline void Scope::set_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Scope.limit)
}
inline void Scope::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Scope.limit)
}
inline ::std::string* Scope::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Scope.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scope::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Scope.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Scope::set_allocated_limit(::std::string* limit) {
  if (limit != NULL) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Scope.limit)
}

// -------------------------------------------------------------------

// SelectField

// .kvrpcpb.SelectField.Type typ = 1;
inline void SelectField::clear_typ() {
  typ_ = 0;
}
inline ::kvrpcpb::SelectField_Type SelectField::typ() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectField.typ)
  return static_cast< ::kvrpcpb::SelectField_Type >(typ_);
}
inline void SelectField::set_typ(::kvrpcpb::SelectField_Type value) {
  
  typ_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectField.typ)
}

// string aggre_func = 2;
inline void SelectField::clear_aggre_func() {
  aggre_func_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectField::aggre_func() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectField.aggre_func)
  return aggre_func_.GetNoArena();
}
inline void SelectField::set_aggre_func(const ::std::string& value) {
  
  aggre_func_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectField.aggre_func)
}
#if LANG_CXX11
inline void SelectField::set_aggre_func(::std::string&& value) {
  
  aggre_func_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.SelectField.aggre_func)
}
#endif
inline void SelectField::set_aggre_func(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  aggre_func_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.SelectField.aggre_func)
}
inline void SelectField::set_aggre_func(const char* value, size_t size) {
  
  aggre_func_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.SelectField.aggre_func)
}
inline ::std::string* SelectField::mutable_aggre_func() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectField.aggre_func)
  return aggre_func_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectField::release_aggre_func() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectField.aggre_func)
  
  return aggre_func_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectField::set_allocated_aggre_func(::std::string* aggre_func) {
  if (aggre_func != NULL) {
    
  } else {
    
  }
  aggre_func_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), aggre_func);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectField.aggre_func)
}

// .metapb.Column column = 3;
inline bool SelectField::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void SelectField::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& SelectField::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectField.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* SelectField::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectField.column)
  return column_;
}
inline ::metapb::Column* SelectField::release_column() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectField.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void SelectField::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectField.column)
}

// -------------------------------------------------------------------

// Match

// .metapb.Column column = 1;
inline bool Match::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void Match::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& Match::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:kvrpcpb.Match.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* Match::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Match.column)
  return column_;
}
inline ::metapb::Column* Match::release_column() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Match.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void Match::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Match.column)
}

// bytes threshold = 2;
inline void Match::clear_threshold() {
  threshold_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Match::threshold() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Match.threshold)
  return threshold_.GetNoArena();
}
inline void Match::set_threshold(const ::std::string& value) {
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Match.threshold)
}
#if LANG_CXX11
inline void Match::set_threshold(::std::string&& value) {
  
  threshold_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Match.threshold)
}
#endif
inline void Match::set_threshold(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Match.threshold)
}
inline void Match::set_threshold(const void* value, size_t size) {
  
  threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Match.threshold)
}
inline ::std::string* Match::mutable_threshold() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Match.threshold)
  return threshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Match::release_threshold() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Match.threshold)
  
  return threshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Match::set_allocated_threshold(::std::string* threshold) {
  if (threshold != NULL) {
    
  } else {
    
  }
  threshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), threshold);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Match.threshold)
}

// .kvrpcpb.MatchType match_type = 3;
inline void Match::clear_match_type() {
  match_type_ = 0;
}
inline ::kvrpcpb::MatchType Match::match_type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Match.match_type)
  return static_cast< ::kvrpcpb::MatchType >(match_type_);
}
inline void Match::set_match_type(::kvrpcpb::MatchType value) {
  
  match_type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Match.match_type)
}

// -------------------------------------------------------------------

// Limit

// uint64 offset = 1;
inline void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Limit.offset)
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Limit.offset)
}

// uint64 count = 2;
inline void Limit::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Limit::count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Limit.count)
  return count_;
}
inline void Limit::set_count(::google::protobuf::uint64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Limit.count)
}

// -------------------------------------------------------------------

// DsSelectRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsSelectRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsSelectRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsSelectRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsSelectRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsSelectRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsSelectRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectRequest.header)
}

// .kvrpcpb.SelectRequest req = 2;
inline bool DsSelectRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsSelectRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::SelectRequest& DsSelectRequest::req() const {
  const ::kvrpcpb::SelectRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::SelectRequest*>(
      &::kvrpcpb::_SelectRequest_default_instance_);
}
inline ::kvrpcpb::SelectRequest* DsSelectRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::SelectRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectRequest.req)
  return req_;
}
inline ::kvrpcpb::SelectRequest* DsSelectRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectRequest.req)
  
  ::kvrpcpb::SelectRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsSelectRequest::set_allocated_req(::kvrpcpb::SelectRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectRequest.req)
}

// -------------------------------------------------------------------

// SelectRequest

// bytes key = 1;
inline void SelectRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.key)
  return key_.GetNoArena();
}
inline void SelectRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectRequest.key)
}
#if LANG_CXX11
inline void SelectRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.SelectRequest.key)
}
#endif
inline void SelectRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.SelectRequest.key)
}
inline void SelectRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.SelectRequest.key)
}
inline ::std::string* SelectRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool SelectRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void SelectRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& SelectRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* SelectRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* SelectRequest::release_scope() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.scope)
}

// repeated .kvrpcpb.SelectField field_list = 3;
inline int SelectRequest::field_list_size() const {
  return field_list_.size();
}
inline void SelectRequest::clear_field_list() {
  field_list_.Clear();
}
inline const ::kvrpcpb::SelectField& SelectRequest::field_list(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.field_list)
  return field_list_.Get(index);
}
inline ::kvrpcpb::SelectField* SelectRequest::mutable_field_list(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.field_list)
  return field_list_.Mutable(index);
}
inline ::kvrpcpb::SelectField* SelectRequest::add_field_list() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectRequest.field_list)
  return field_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >*
SelectRequest::mutable_field_list() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectRequest.field_list)
  return &field_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >&
SelectRequest::field_list() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectRequest.field_list)
  return field_list_;
}

// repeated .kvrpcpb.Match where_filters = 4;
inline int SelectRequest::where_filters_size() const {
  return where_filters_.size();
}
inline void SelectRequest::clear_where_filters() {
  where_filters_.Clear();
}
inline const ::kvrpcpb::Match& SelectRequest::where_filters(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.where_filters)
  return where_filters_.Get(index);
}
inline ::kvrpcpb::Match* SelectRequest::mutable_where_filters(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.where_filters)
  return where_filters_.Mutable(index);
}
inline ::kvrpcpb::Match* SelectRequest::add_where_filters() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectRequest.where_filters)
  return where_filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
SelectRequest::mutable_where_filters() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectRequest.where_filters)
  return &where_filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
SelectRequest::where_filters() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectRequest.where_filters)
  return where_filters_;
}

// repeated .metapb.Column group_bys = 5;
inline int SelectRequest::group_bys_size() const {
  return group_bys_.size();
}
inline void SelectRequest::clear_group_bys() {
  group_bys_.Clear();
}
inline const ::metapb::Column& SelectRequest::group_bys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.group_bys)
  return group_bys_.Get(index);
}
inline ::metapb::Column* SelectRequest::mutable_group_bys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.group_bys)
  return group_bys_.Mutable(index);
}
inline ::metapb::Column* SelectRequest::add_group_bys() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectRequest.group_bys)
  return group_bys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
SelectRequest::mutable_group_bys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectRequest.group_bys)
  return &group_bys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
SelectRequest::group_bys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectRequest.group_bys)
  return group_bys_;
}

// .kvrpcpb.Limit limit = 6;
inline bool SelectRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void SelectRequest::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) delete limit_;
  limit_ = NULL;
}
inline const ::kvrpcpb::Limit& SelectRequest::limit() const {
  const ::kvrpcpb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Limit*>(
      &::kvrpcpb::_Limit_default_instance_);
}
inline ::kvrpcpb::Limit* SelectRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    limit_ = new ::kvrpcpb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.limit)
  return limit_;
}
inline ::kvrpcpb::Limit* SelectRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.limit)
  
  ::kvrpcpb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_limit(::kvrpcpb::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.limit)
}

// .exprpb.Expr where_expr = 10;
inline bool SelectRequest::has_where_expr() const {
  return this != internal_default_instance() && where_expr_ != NULL;
}
inline void SelectRequest::clear_where_expr() {
  if (GetArenaNoVirtual() == NULL && where_expr_ != NULL) delete where_expr_;
  where_expr_ = NULL;
}
inline const ::exprpb::Expr& SelectRequest::where_expr() const {
  const ::exprpb::Expr* p = where_expr_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectRequest.where_expr)
  return p != NULL ? *p : *reinterpret_cast<const ::exprpb::Expr*>(
      &::exprpb::_Expr_default_instance_);
}
inline ::exprpb::Expr* SelectRequest::mutable_where_expr() {
  
  if (where_expr_ == NULL) {
    where_expr_ = new ::exprpb::Expr;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectRequest.where_expr)
  return where_expr_;
}
inline ::exprpb::Expr* SelectRequest::release_where_expr() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SelectRequest.where_expr)
  
  ::exprpb::Expr* temp = where_expr_;
  where_expr_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_where_expr(::exprpb::Expr* where_expr) {
  delete where_expr_;
  where_expr_ = where_expr;
  if (where_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SelectRequest.where_expr)
}

// -------------------------------------------------------------------

// Row

// bytes key = 1;
inline void Row::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Row::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Row.key)
  return key_.GetNoArena();
}
inline void Row::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Row.key)
}
#if LANG_CXX11
inline void Row::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Row.key)
}
#endif
inline void Row::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Row.key)
}
inline void Row::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Row.key)
}
inline ::std::string* Row::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Row.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Row::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Row.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Row::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Row.key)
}

// bytes fields = 2;
inline void Row::clear_fields() {
  fields_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Row::fields() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Row.fields)
  return fields_.GetNoArena();
}
inline void Row::set_fields(const ::std::string& value) {
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Row.fields)
}
#if LANG_CXX11
inline void Row::set_fields(::std::string&& value) {
  
  fields_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Row.fields)
}
#endif
inline void Row::set_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Row.fields)
}
inline void Row::set_fields(const void* value, size_t size) {
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Row.fields)
}
inline ::std::string* Row::mutable_fields() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Row.fields)
  return fields_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Row::release_fields() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Row.fields)
  
  return fields_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Row::set_allocated_fields(::std::string* fields) {
  if (fields != NULL) {
    
  } else {
    
  }
  fields_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fields);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Row.fields)
}

// repeated int64 aggred_counts = 3;
inline int Row::aggred_counts_size() const {
  return aggred_counts_.size();
}
inline void Row::clear_aggred_counts() {
  aggred_counts_.Clear();
}
inline ::google::protobuf::int64 Row::aggred_counts(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Row.aggred_counts)
  return aggred_counts_.Get(index);
}
inline void Row::set_aggred_counts(int index, ::google::protobuf::int64 value) {
  aggred_counts_.Set(index, value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Row.aggred_counts)
}
inline void Row::add_aggred_counts(::google::protobuf::int64 value) {
  aggred_counts_.Add(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.Row.aggred_counts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Row::aggred_counts() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.Row.aggred_counts)
  return aggred_counts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Row::mutable_aggred_counts() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.Row.aggred_counts)
  return &aggred_counts_;
}

// -------------------------------------------------------------------

// DsSelectResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsSelectResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsSelectResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsSelectResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsSelectResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsSelectResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsSelectResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectResponse.header)
}

// .kvrpcpb.SelectResponse resp = 2;
inline bool DsSelectResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsSelectResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::SelectResponse& DsSelectResponse::resp() const {
  const ::kvrpcpb::SelectResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsSelectResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::SelectResponse*>(
      &::kvrpcpb::_SelectResponse_default_instance_);
}
inline ::kvrpcpb::SelectResponse* DsSelectResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::SelectResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsSelectResponse.resp)
  return resp_;
}
inline ::kvrpcpb::SelectResponse* DsSelectResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsSelectResponse.resp)
  
  ::kvrpcpb::SelectResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsSelectResponse::set_allocated_resp(::kvrpcpb::SelectResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsSelectResponse.resp)
}

// -------------------------------------------------------------------

// SelectResponse

// int32 code = 1;
inline void SelectResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 SelectResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectResponse.code)
  return code_;
}
inline void SelectResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectResponse.code)
}

// repeated .kvrpcpb.Row rows = 2;
inline int SelectResponse::rows_size() const {
  return rows_.size();
}
inline void SelectResponse::clear_rows() {
  rows_.Clear();
}
inline const ::kvrpcpb::Row& SelectResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectResponse.rows)
  return rows_.Get(index);
}
inline ::kvrpcpb::Row* SelectResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SelectResponse.rows)
  return rows_.Mutable(index);
}
inline ::kvrpcpb::Row* SelectResponse::add_rows() {
  // @@protoc_insertion_point(field_add:kvrpcpb.SelectResponse.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >*
SelectResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.SelectResponse.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Row >&
SelectResponse::rows() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.SelectResponse.rows)
  return rows_;
}

// uint64 offset = 3;
inline void SelectResponse::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SelectResponse::offset() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SelectResponse.offset)
  return offset_;
}
inline void SelectResponse::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.SelectResponse.offset)
}

// -------------------------------------------------------------------

// KeyValue

// bytes Key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyValue.Key)
  return key_.GetNoArena();
}
inline void KeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyValue.Key)
}
#if LANG_CXX11
inline void KeyValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyValue.Key)
}
#endif
inline void KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyValue.Key)
}
inline void KeyValue::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyValue.Key)
}
inline ::std::string* KeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyValue.Key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyValue.Key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyValue.Key)
}

// bytes Value = 2;
inline void KeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyValue.Value)
  return value_.GetNoArena();
}
inline void KeyValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyValue.Value)
}
#if LANG_CXX11
inline void KeyValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyValue.Value)
}
#endif
inline void KeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyValue.Value)
}
inline void KeyValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyValue.Value)
}
inline ::std::string* KeyValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyValue.Value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyValue.Value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyValue.Value)
}

// uint64 TTL = 3;
inline void KeyValue::clear_ttl() {
  ttl_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KeyValue::ttl() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyValue.TTL)
  return ttl_;
}
inline void KeyValue::set_ttl(::google::protobuf::uint64 value) {
  
  ttl_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyValue.TTL)
}

// -------------------------------------------------------------------

// DsInsertRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsInsertRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsInsertRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsInsertRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsInsertRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsInsertRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsInsertRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertRequest.header)
}

// .kvrpcpb.InsertRequest req = 2;
inline bool DsInsertRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsInsertRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::InsertRequest& DsInsertRequest::req() const {
  const ::kvrpcpb::InsertRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::InsertRequest*>(
      &::kvrpcpb::_InsertRequest_default_instance_);
}
inline ::kvrpcpb::InsertRequest* DsInsertRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::InsertRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertRequest.req)
  return req_;
}
inline ::kvrpcpb::InsertRequest* DsInsertRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertRequest.req)
  
  ::kvrpcpb::InsertRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsInsertRequest::set_allocated_req(::kvrpcpb::InsertRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertRequest.req)
}

// -------------------------------------------------------------------

// DsInsertResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsInsertResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsInsertResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsInsertResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsInsertResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsInsertResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsInsertResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertResponse.header)
}

// .kvrpcpb.InsertResponse resp = 2;
inline bool DsInsertResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsInsertResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::InsertResponse& DsInsertResponse::resp() const {
  const ::kvrpcpb::InsertResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsInsertResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::InsertResponse*>(
      &::kvrpcpb::_InsertResponse_default_instance_);
}
inline ::kvrpcpb::InsertResponse* DsInsertResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::InsertResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsInsertResponse.resp)
  return resp_;
}
inline ::kvrpcpb::InsertResponse* DsInsertResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsInsertResponse.resp)
  
  ::kvrpcpb::InsertResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsInsertResponse::set_allocated_resp(::kvrpcpb::InsertResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsInsertResponse.resp)
}

// -------------------------------------------------------------------

// InsertRequest

// repeated .kvrpcpb.KeyValue rows = 1;
inline int InsertRequest::rows_size() const {
  return rows_.size();
}
inline void InsertRequest::clear_rows() {
  rows_.Clear();
}
inline const ::kvrpcpb::KeyValue& InsertRequest::rows(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertRequest.rows)
  return rows_.Get(index);
}
inline ::kvrpcpb::KeyValue* InsertRequest::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.InsertRequest.rows)
  return rows_.Mutable(index);
}
inline ::kvrpcpb::KeyValue* InsertRequest::add_rows() {
  // @@protoc_insertion_point(field_add:kvrpcpb.InsertRequest.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >*
InsertRequest::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.InsertRequest.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyValue >&
InsertRequest::rows() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.InsertRequest.rows)
  return rows_;
}

// bool check_duplicate = 2;
inline void InsertRequest::clear_check_duplicate() {
  check_duplicate_ = false;
}
inline bool InsertRequest::check_duplicate() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertRequest.check_duplicate)
  return check_duplicate_;
}
inline void InsertRequest::set_check_duplicate(bool value) {
  
  check_duplicate_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertRequest.check_duplicate)
}

// -------------------------------------------------------------------

// InsertResponse

// int32 code = 1;
inline void InsertResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 InsertResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertResponse.code)
  return code_;
}
inline void InsertResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertResponse.code)
}

// uint64 affected_keys = 2;
inline void InsertResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InsertResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertResponse.affected_keys)
  return affected_keys_;
}
inline void InsertResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertResponse.affected_keys)
}

// bytes duplicate_key = 3;
inline void InsertResponse::clear_duplicate_key() {
  duplicate_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InsertResponse::duplicate_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.InsertResponse.duplicate_key)
  return duplicate_key_.GetNoArena();
}
inline void InsertResponse::set_duplicate_key(const ::std::string& value) {
  
  duplicate_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.InsertResponse.duplicate_key)
}
#if LANG_CXX11
inline void InsertResponse::set_duplicate_key(::std::string&& value) {
  
  duplicate_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.InsertResponse.duplicate_key)
}
#endif
inline void InsertResponse::set_duplicate_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  duplicate_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.InsertResponse.duplicate_key)
}
inline void InsertResponse::set_duplicate_key(const void* value, size_t size) {
  
  duplicate_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.InsertResponse.duplicate_key)
}
inline ::std::string* InsertResponse::mutable_duplicate_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.InsertResponse.duplicate_key)
  return duplicate_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InsertResponse::release_duplicate_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.InsertResponse.duplicate_key)
  
  return duplicate_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InsertResponse::set_allocated_duplicate_key(::std::string* duplicate_key) {
  if (duplicate_key != NULL) {
    
  } else {
    
  }
  duplicate_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duplicate_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.InsertResponse.duplicate_key)
}

// -------------------------------------------------------------------

// BatchInsertRequest

// repeated .kvrpcpb.InsertRequest reqs = 1;
inline int BatchInsertRequest::reqs_size() const {
  return reqs_.size();
}
inline void BatchInsertRequest::clear_reqs() {
  reqs_.Clear();
}
inline const ::kvrpcpb::InsertRequest& BatchInsertRequest::reqs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_.Get(index);
}
inline ::kvrpcpb::InsertRequest* BatchInsertRequest::mutable_reqs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_.Mutable(index);
}
inline ::kvrpcpb::InsertRequest* BatchInsertRequest::add_reqs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >*
BatchInsertRequest::mutable_reqs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchInsertRequest.reqs)
  return &reqs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertRequest >&
BatchInsertRequest::reqs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchInsertRequest.reqs)
  return reqs_;
}

// -------------------------------------------------------------------

// BatchInsertResponse

// repeated .kvrpcpb.InsertResponse resps = 2;
inline int BatchInsertResponse::resps_size() const {
  return resps_.size();
}
inline void BatchInsertResponse::clear_resps() {
  resps_.Clear();
}
inline const ::kvrpcpb::InsertResponse& BatchInsertResponse::resps(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchInsertResponse.resps)
  return resps_.Get(index);
}
inline ::kvrpcpb::InsertResponse* BatchInsertResponse::mutable_resps(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchInsertResponse.resps)
  return resps_.Mutable(index);
}
inline ::kvrpcpb::InsertResponse* BatchInsertResponse::add_resps() {
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchInsertResponse.resps)
  return resps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >*
BatchInsertResponse::mutable_resps() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchInsertResponse.resps)
  return &resps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::InsertResponse >&
BatchInsertResponse::resps() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchInsertResponse.resps)
  return resps_;
}

// -------------------------------------------------------------------

// DsDeleteRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsDeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsDeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsDeleteRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsDeleteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsDeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsDeleteRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteRequest.header)
}

// .kvrpcpb.DeleteRequest req = 2;
inline bool DsDeleteRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsDeleteRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::DeleteRequest& DsDeleteRequest::req() const {
  const ::kvrpcpb::DeleteRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::DeleteRequest*>(
      &::kvrpcpb::_DeleteRequest_default_instance_);
}
inline ::kvrpcpb::DeleteRequest* DsDeleteRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteRequest.req)
  return req_;
}
inline ::kvrpcpb::DeleteRequest* DsDeleteRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteRequest.req)
  
  ::kvrpcpb::DeleteRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsDeleteRequest::set_allocated_req(::kvrpcpb::DeleteRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteRequest.req)
}

// -------------------------------------------------------------------

// DsDeleteResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsDeleteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsDeleteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsDeleteResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsDeleteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsDeleteResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsDeleteResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteResponse.header)
}

// .kvrpcpb.DeleteResponse resp = 2;
inline bool DsDeleteResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsDeleteResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::DeleteResponse& DsDeleteResponse::resp() const {
  const ::kvrpcpb::DeleteResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsDeleteResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::DeleteResponse*>(
      &::kvrpcpb::_DeleteResponse_default_instance_);
}
inline ::kvrpcpb::DeleteResponse* DsDeleteResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsDeleteResponse.resp)
  return resp_;
}
inline ::kvrpcpb::DeleteResponse* DsDeleteResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsDeleteResponse.resp)
  
  ::kvrpcpb::DeleteResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsDeleteResponse::set_allocated_resp(::kvrpcpb::DeleteResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsDeleteResponse.resp)
}

// -------------------------------------------------------------------

// DeleteRequest

// bytes key = 1;
inline void DeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.key)
  return key_.GetNoArena();
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRequest.key)
}
#if LANG_CXX11
inline void DeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.DeleteRequest.key)
}
#endif
inline void DeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.DeleteRequest.key)
}
inline ::std::string* DeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool DeleteRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void DeleteRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& DeleteRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* DeleteRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* DeleteRequest::release_scope() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void DeleteRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRequest.scope)
}

// repeated .kvrpcpb.Match where_filters = 3;
inline int DeleteRequest::where_filters_size() const {
  return where_filters_.size();
}
inline void DeleteRequest::clear_where_filters() {
  where_filters_.Clear();
}
inline const ::kvrpcpb::Match& DeleteRequest::where_filters(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_.Get(index);
}
inline ::kvrpcpb::Match* DeleteRequest::mutable_where_filters(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_.Mutable(index);
}
inline ::kvrpcpb::Match* DeleteRequest::add_where_filters() {
  // @@protoc_insertion_point(field_add:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
DeleteRequest::mutable_where_filters() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.DeleteRequest.where_filters)
  return &where_filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
DeleteRequest::where_filters() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.DeleteRequest.where_filters)
  return where_filters_;
}

// repeated uint64 indexs = 4;
inline int DeleteRequest::indexs_size() const {
  return indexs_.size();
}
inline void DeleteRequest::clear_indexs() {
  indexs_.Clear();
}
inline ::google::protobuf::uint64 DeleteRequest::indexs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRequest.indexs)
  return indexs_.Get(index);
}
inline void DeleteRequest::set_indexs(int index, ::google::protobuf::uint64 value) {
  indexs_.Set(index, value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRequest.indexs)
}
inline void DeleteRequest::add_indexs(::google::protobuf::uint64 value) {
  indexs_.Add(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.DeleteRequest.indexs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DeleteRequest::indexs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.DeleteRequest.indexs)
  return indexs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DeleteRequest::mutable_indexs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.DeleteRequest.indexs)
  return &indexs_;
}

// -------------------------------------------------------------------

// DeleteResponse

// int32 code = 1;
inline void DeleteResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 DeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteResponse.code)
  return code_;
}
inline void DeleteResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteResponse.code)
}

// uint64 affected_keys = 2;
inline void DeleteResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DeleteResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteResponse.affected_keys)
  return affected_keys_;
}
inline void DeleteResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteResponse.affected_keys)
}

// -------------------------------------------------------------------

// Field

// .metapb.Column column = 1;
inline bool Field::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void Field::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& Field::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:kvrpcpb.Field.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* Field::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Field.column)
  return column_;
}
inline ::metapb::Column* Field::release_column() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Field.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void Field::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Field.column)
}

// bytes value = 2;
inline void Field::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Field.value)
  return value_.GetNoArena();
}
inline void Field::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Field.value)
}
#if LANG_CXX11
inline void Field::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Field.value)
}
#endif
inline void Field::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Field.value)
}
inline void Field::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Field.value)
}
inline ::std::string* Field::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Field.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Field.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Field.value)
}

// .kvrpcpb.FieldType field_type = 3;
inline void Field::clear_field_type() {
  field_type_ = 0;
}
inline ::kvrpcpb::FieldType Field::field_type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Field.field_type)
  return static_cast< ::kvrpcpb::FieldType >(field_type_);
}
inline void Field::set_field_type(::kvrpcpb::FieldType value) {
  
  field_type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Field.field_type)
}

// -------------------------------------------------------------------

// UpdateRequest

// bytes key = 1;
inline void UpdateRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateRequest.key)
  return key_.GetNoArena();
}
inline void UpdateRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UpdateRequest.key)
}
#if LANG_CXX11
inline void UpdateRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UpdateRequest.key)
}
#endif
inline void UpdateRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UpdateRequest.key)
}
inline void UpdateRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UpdateRequest.key)
}
inline ::std::string* UpdateRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UpdateRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UpdateRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UpdateRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool UpdateRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void UpdateRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& UpdateRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* UpdateRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UpdateRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* UpdateRequest::release_scope() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UpdateRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void UpdateRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UpdateRequest.scope)
}

// repeated .kvrpcpb.Field fields = 3;
inline int UpdateRequest::fields_size() const {
  return fields_.size();
}
inline void UpdateRequest::clear_fields() {
  fields_.Clear();
}
inline const ::kvrpcpb::Field& UpdateRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateRequest.fields)
  return fields_.Get(index);
}
inline ::kvrpcpb::Field* UpdateRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UpdateRequest.fields)
  return fields_.Mutable(index);
}
inline ::kvrpcpb::Field* UpdateRequest::add_fields() {
  // @@protoc_insertion_point(field_add:kvrpcpb.UpdateRequest.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Field >*
UpdateRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.UpdateRequest.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Field >&
UpdateRequest::fields() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.UpdateRequest.fields)
  return fields_;
}

// repeated .kvrpcpb.Match where_filters = 4;
inline int UpdateRequest::where_filters_size() const {
  return where_filters_.size();
}
inline void UpdateRequest::clear_where_filters() {
  where_filters_.Clear();
}
inline const ::kvrpcpb::Match& UpdateRequest::where_filters(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateRequest.where_filters)
  return where_filters_.Get(index);
}
inline ::kvrpcpb::Match* UpdateRequest::mutable_where_filters(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UpdateRequest.where_filters)
  return where_filters_.Mutable(index);
}
inline ::kvrpcpb::Match* UpdateRequest::add_where_filters() {
  // @@protoc_insertion_point(field_add:kvrpcpb.UpdateRequest.where_filters)
  return where_filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
UpdateRequest::mutable_where_filters() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.UpdateRequest.where_filters)
  return &where_filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
UpdateRequest::where_filters() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.UpdateRequest.where_filters)
  return where_filters_;
}

// .kvrpcpb.Limit limit = 5;
inline bool UpdateRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void UpdateRequest::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) delete limit_;
  limit_ = NULL;
}
inline const ::kvrpcpb::Limit& UpdateRequest::limit() const {
  const ::kvrpcpb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Limit*>(
      &::kvrpcpb::_Limit_default_instance_);
}
inline ::kvrpcpb::Limit* UpdateRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    limit_ = new ::kvrpcpb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UpdateRequest.limit)
  return limit_;
}
inline ::kvrpcpb::Limit* UpdateRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UpdateRequest.limit)
  
  ::kvrpcpb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void UpdateRequest::set_allocated_limit(::kvrpcpb::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UpdateRequest.limit)
}

// -------------------------------------------------------------------

// DsUpdateRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsUpdateRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUpdateRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsUpdateRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUpdateRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsUpdateRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUpdateRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsUpdateRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUpdateRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUpdateRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUpdateRequest.header)
}

// .kvrpcpb.UpdateRequest req = 2;
inline bool DsUpdateRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsUpdateRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::UpdateRequest& DsUpdateRequest::req() const {
  const ::kvrpcpb::UpdateRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUpdateRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::UpdateRequest*>(
      &::kvrpcpb::_UpdateRequest_default_instance_);
}
inline ::kvrpcpb::UpdateRequest* DsUpdateRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::UpdateRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUpdateRequest.req)
  return req_;
}
inline ::kvrpcpb::UpdateRequest* DsUpdateRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUpdateRequest.req)
  
  ::kvrpcpb::UpdateRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsUpdateRequest::set_allocated_req(::kvrpcpb::UpdateRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUpdateRequest.req)
}

// -------------------------------------------------------------------

// UpdateResponse

// int32 code = 1;
inline void UpdateResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 UpdateResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateResponse.code)
  return code_;
}
inline void UpdateResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.UpdateResponse.code)
}

// uint64 affected_keys = 2;
inline void UpdateResponse::clear_affected_keys() {
  affected_keys_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UpdateResponse::affected_keys() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UpdateResponse.affected_keys)
  return affected_keys_;
}
inline void UpdateResponse::set_affected_keys(::google::protobuf::uint64 value) {
  
  affected_keys_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.UpdateResponse.affected_keys)
}

// -------------------------------------------------------------------

// DsUpdateResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsUpdateResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUpdateResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsUpdateResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUpdateResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsUpdateResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUpdateResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsUpdateResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUpdateResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUpdateResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUpdateResponse.header)
}

// .kvrpcpb.UpdateResponse resp = 2;
inline bool DsUpdateResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsUpdateResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::UpdateResponse& DsUpdateResponse::resp() const {
  const ::kvrpcpb::UpdateResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUpdateResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::UpdateResponse*>(
      &::kvrpcpb::_UpdateResponse_default_instance_);
}
inline ::kvrpcpb::UpdateResponse* DsUpdateResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::UpdateResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUpdateResponse.resp)
  return resp_;
}
inline ::kvrpcpb::UpdateResponse* DsUpdateResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUpdateResponse.resp)
  
  ::kvrpcpb::UpdateResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsUpdateResponse::set_allocated_resp(::kvrpcpb::UpdateResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUpdateResponse.resp)
}

// -------------------------------------------------------------------

// IndexScanRequest

// bytes key = 1;
inline void IndexScanRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IndexScanRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.IndexScanRequest.key)
  return key_.GetNoArena();
}
inline void IndexScanRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.IndexScanRequest.key)
}
#if LANG_CXX11
inline void IndexScanRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.IndexScanRequest.key)
}
#endif
inline void IndexScanRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.IndexScanRequest.key)
}
inline void IndexScanRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.IndexScanRequest.key)
}
inline ::std::string* IndexScanRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.IndexScanRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IndexScanRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.IndexScanRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IndexScanRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.IndexScanRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool IndexScanRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void IndexScanRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& IndexScanRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:kvrpcpb.IndexScanRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* IndexScanRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.IndexScanRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* IndexScanRequest::release_scope() {
  // @@protoc_insertion_point(field_release:kvrpcpb.IndexScanRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void IndexScanRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.IndexScanRequest.scope)
}

// .kvrpcpb.Limit limit = 3;
inline bool IndexScanRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void IndexScanRequest::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) delete limit_;
  limit_ = NULL;
}
inline const ::kvrpcpb::Limit& IndexScanRequest::limit() const {
  const ::kvrpcpb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:kvrpcpb.IndexScanRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Limit*>(
      &::kvrpcpb::_Limit_default_instance_);
}
inline ::kvrpcpb::Limit* IndexScanRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    limit_ = new ::kvrpcpb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.IndexScanRequest.limit)
  return limit_;
}
inline ::kvrpcpb::Limit* IndexScanRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.IndexScanRequest.limit)
  
  ::kvrpcpb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void IndexScanRequest::set_allocated_limit(::kvrpcpb::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.IndexScanRequest.limit)
}

// -------------------------------------------------------------------

// DsIndexScanRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsIndexScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsIndexScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsIndexScanRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsIndexScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsIndexScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsIndexScanRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsIndexScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsIndexScanRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsIndexScanRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsIndexScanRequest.header)
}

// .kvrpcpb.IndexScanRequest req = 2;
inline bool DsIndexScanRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsIndexScanRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::IndexScanRequest& DsIndexScanRequest::req() const {
  const ::kvrpcpb::IndexScanRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsIndexScanRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::IndexScanRequest*>(
      &::kvrpcpb::_IndexScanRequest_default_instance_);
}
inline ::kvrpcpb::IndexScanRequest* DsIndexScanRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::IndexScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsIndexScanRequest.req)
  return req_;
}
inline ::kvrpcpb::IndexScanRequest* DsIndexScanRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsIndexScanRequest.req)
  
  ::kvrpcpb::IndexScanRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsIndexScanRequest::set_allocated_req(::kvrpcpb::IndexScanRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsIndexScanRequest.req)
}

// -------------------------------------------------------------------

// IndexScanResponse

// repeated bytes pk_values = 1;
inline int IndexScanResponse::pk_values_size() const {
  return pk_values_.size();
}
inline void IndexScanResponse::clear_pk_values() {
  pk_values_.Clear();
}
inline const ::std::string& IndexScanResponse::pk_values(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.IndexScanResponse.pk_values)
  return pk_values_.Get(index);
}
inline ::std::string* IndexScanResponse::mutable_pk_values(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.IndexScanResponse.pk_values)
  return pk_values_.Mutable(index);
}
inline void IndexScanResponse::set_pk_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.IndexScanResponse.pk_values)
  pk_values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IndexScanResponse::set_pk_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.IndexScanResponse.pk_values)
  pk_values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IndexScanResponse::set_pk_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pk_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.IndexScanResponse.pk_values)
}
inline void IndexScanResponse::set_pk_values(int index, const void* value, size_t size) {
  pk_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.IndexScanResponse.pk_values)
}
inline ::std::string* IndexScanResponse::add_pk_values() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.IndexScanResponse.pk_values)
  return pk_values_.Add();
}
inline void IndexScanResponse::add_pk_values(const ::std::string& value) {
  pk_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.IndexScanResponse.pk_values)
}
#if LANG_CXX11
inline void IndexScanResponse::add_pk_values(::std::string&& value) {
  pk_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.IndexScanResponse.pk_values)
}
#endif
inline void IndexScanResponse::add_pk_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pk_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.IndexScanResponse.pk_values)
}
inline void IndexScanResponse::add_pk_values(const void* value, size_t size) {
  pk_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.IndexScanResponse.pk_values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexScanResponse::pk_values() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.IndexScanResponse.pk_values)
  return pk_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexScanResponse::mutable_pk_values() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.IndexScanResponse.pk_values)
  return &pk_values_;
}

// -------------------------------------------------------------------

// DsIndexScanResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsIndexScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsIndexScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsIndexScanResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsIndexScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsIndexScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsIndexScanResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsIndexScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsIndexScanResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsIndexScanResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsIndexScanResponse.header)
}

// .kvrpcpb.IndexScanResponse resp = 2;
inline bool DsIndexScanResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsIndexScanResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::IndexScanResponse& DsIndexScanResponse::resp() const {
  const ::kvrpcpb::IndexScanResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsIndexScanResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::IndexScanResponse*>(
      &::kvrpcpb::_IndexScanResponse_default_instance_);
}
inline ::kvrpcpb::IndexScanResponse* DsIndexScanResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::IndexScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsIndexScanResponse.resp)
  return resp_;
}
inline ::kvrpcpb::IndexScanResponse* DsIndexScanResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsIndexScanResponse.resp)
  
  ::kvrpcpb::IndexScanResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsIndexScanResponse::set_allocated_resp(::kvrpcpb::IndexScanResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsIndexScanResponse.resp)
}

// -------------------------------------------------------------------

// LockValue

// bytes value = 2;
inline void LockValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockValue::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.value)
  return value_.GetNoArena();
}
inline void LockValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.value)
}
#if LANG_CXX11
inline void LockValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockValue.value)
}
#endif
inline void LockValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockValue.value)
}
inline void LockValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockValue.value)
}
inline ::std::string* LockValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockValue::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockValue.value)
}

// string id = 3;
inline void LockValue::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockValue::id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.id)
  return id_.GetNoArena();
}
inline void LockValue::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.id)
}
#if LANG_CXX11
inline void LockValue::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockValue.id)
}
#endif
inline void LockValue::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockValue.id)
}
inline void LockValue::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockValue.id)
}
inline ::std::string* LockValue::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockValue.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockValue::release_id() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockValue.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockValue::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockValue.id)
}

// int64 delete_time = 4;
inline void LockValue::clear_delete_time() {
  delete_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockValue::delete_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.delete_time)
  return delete_time_;
}
inline void LockValue::set_delete_time(::google::protobuf::int64 value) {
  
  delete_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.delete_time)
}

// int64 update_time = 5;
inline void LockValue::clear_update_time() {
  update_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockValue::update_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.update_time)
  return update_time_;
}
inline void LockValue::set_update_time(::google::protobuf::int64 value) {
  
  update_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.update_time)
}

// string by = 7;
inline void LockValue::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockValue::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockValue.by)
  return by_.GetNoArena();
}
inline void LockValue::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockValue.by)
}
#if LANG_CXX11
inline void LockValue::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockValue.by)
}
#endif
inline void LockValue::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockValue.by)
}
inline void LockValue::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockValue.by)
}
inline ::std::string* LockValue::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockValue.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockValue::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockValue.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockValue::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockValue.by)
}

// -------------------------------------------------------------------

// LockRequest

// bytes key = 1;
inline void LockRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockRequest.key)
  return key_.GetNoArena();
}
inline void LockRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockRequest.key)
}
#if LANG_CXX11
inline void LockRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockRequest.key)
}
#endif
inline void LockRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockRequest.key)
}
inline void LockRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockRequest.key)
}
inline ::std::string* LockRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockRequest.key)
}

// .kvrpcpb.LockValue value = 2;
inline bool LockRequest::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void LockRequest::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::kvrpcpb::LockValue& LockRequest::value() const {
  const ::kvrpcpb::LockValue* p = value_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockRequest.value)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockValue*>(
      &::kvrpcpb::_LockValue_default_instance_);
}
inline ::kvrpcpb::LockValue* LockRequest::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::kvrpcpb::LockValue;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockRequest.value)
  return value_;
}
inline ::kvrpcpb::LockValue* LockRequest::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockRequest.value)
  
  ::kvrpcpb::LockValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void LockRequest::set_allocated_value(::kvrpcpb::LockValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockRequest.value)
}

// -------------------------------------------------------------------

// DsLockRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockRequest.header)
}

// .kvrpcpb.LockRequest req = 2;
inline bool DsLockRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockRequest& DsLockRequest::req() const {
  const ::kvrpcpb::LockRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockRequest*>(
      &::kvrpcpb::_LockRequest_default_instance_);
}
inline ::kvrpcpb::LockRequest* DsLockRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockRequest.req)
  return req_;
}
inline ::kvrpcpb::LockRequest* DsLockRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockRequest.req)
  
  ::kvrpcpb::LockRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockRequest::set_allocated_req(::kvrpcpb::LockRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockRequest.req)
}

// -------------------------------------------------------------------

// LockResponse

// int64 code = 1;
inline void LockResponse::clear_code() {
  code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.code)
  return code_;
}
inline void LockResponse::set_code(::google::protobuf::int64 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.code)
}

// string error = 2;
inline void LockResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.error)
  return error_.GetNoArena();
}
inline void LockResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.error)
}
#if LANG_CXX11
inline void LockResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockResponse.error)
}
#endif
inline void LockResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockResponse.error)
}
inline void LockResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockResponse.error)
}
inline ::std::string* LockResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockResponse.error)
}

// bytes value = 3;
inline void LockResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.value)
  return value_.GetNoArena();
}
inline void LockResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.value)
}
#if LANG_CXX11
inline void LockResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockResponse.value)
}
#endif
inline void LockResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockResponse.value)
}
inline void LockResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockResponse.value)
}
inline ::std::string* LockResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockResponse.value)
}

// int64 update_time = 4;
inline void LockResponse::clear_update_time() {
  update_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockResponse::update_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockResponse.update_time)
  return update_time_;
}
inline void LockResponse::set_update_time(::google::protobuf::int64 value) {
  
  update_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockResponse.update_time)
}

// -------------------------------------------------------------------

// LockInfo

// bytes key = 1;
inline void LockInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockInfo::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.key)
  return key_.GetNoArena();
}
inline void LockInfo::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.key)
}
#if LANG_CXX11
inline void LockInfo::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockInfo.key)
}
#endif
inline void LockInfo::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockInfo.key)
}
inline void LockInfo::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockInfo.key)
}
inline ::std::string* LockInfo::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockInfo::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockInfo.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockInfo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.key)
}

// .kvrpcpb.LockValue value = 2;
inline bool LockInfo::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void LockInfo::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::kvrpcpb::LockValue& LockInfo::value() const {
  const ::kvrpcpb::LockValue* p = value_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.value)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockValue*>(
      &::kvrpcpb::_LockValue_default_instance_);
}
inline ::kvrpcpb::LockValue* LockInfo::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::kvrpcpb::LockValue;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.value)
  return value_;
}
inline ::kvrpcpb::LockValue* LockInfo::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockInfo.value)
  
  ::kvrpcpb::LockValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void LockInfo::set_allocated_value(::kvrpcpb::LockValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.value)
}

// -------------------------------------------------------------------

// LockScanResponse

// repeated .kvrpcpb.LockInfo info = 1;
inline int LockScanResponse::info_size() const {
  return info_.size();
}
inline void LockScanResponse::clear_info() {
  info_.Clear();
}
inline const ::kvrpcpb::LockInfo& LockScanResponse::info(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanResponse.info)
  return info_.Get(index);
}
inline ::kvrpcpb::LockInfo* LockScanResponse::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanResponse.info)
  return info_.Mutable(index);
}
inline ::kvrpcpb::LockInfo* LockScanResponse::add_info() {
  // @@protoc_insertion_point(field_add:kvrpcpb.LockScanResponse.info)
  return info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
LockScanResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.LockScanResponse.info)
  return &info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
LockScanResponse::info() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.LockScanResponse.info)
  return info_;
}

// bytes last_key = 2;
inline void LockScanResponse::clear_last_key() {
  last_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockScanResponse::last_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanResponse.last_key)
  return last_key_.GetNoArena();
}
inline void LockScanResponse::set_last_key(const ::std::string& value) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanResponse.last_key)
}
#if LANG_CXX11
inline void LockScanResponse::set_last_key(::std::string&& value) {
  
  last_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockScanResponse.last_key)
}
#endif
inline void LockScanResponse::set_last_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockScanResponse.last_key)
}
inline void LockScanResponse::set_last_key(const void* value, size_t size) {
  
  last_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockScanResponse.last_key)
}
inline ::std::string* LockScanResponse::mutable_last_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanResponse.last_key)
  return last_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockScanResponse::release_last_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockScanResponse.last_key)
  
  return last_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockScanResponse::set_allocated_last_key(::std::string* last_key) {
  if (last_key != NULL) {
    
  } else {
    
  }
  last_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockScanResponse.last_key)
}

// -------------------------------------------------------------------

// DsLockResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsLockResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsLockResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsLockResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsLockResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockResponse.resp)
}

// -------------------------------------------------------------------

// LockUpdateRequest

// bytes key = 1;
inline void LockUpdateRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.key)
  return key_.GetNoArena();
}
inline void LockUpdateRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.key)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.key)
}
#endif
inline void LockUpdateRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.key)
}
inline void LockUpdateRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.key)
}
inline ::std::string* LockUpdateRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.key)
}

// string id = 3;
inline void LockUpdateRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.id)
  return id_.GetNoArena();
}
inline void LockUpdateRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.id)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.id)
}
#endif
inline void LockUpdateRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.id)
}
inline void LockUpdateRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.id)
}
inline ::std::string* LockUpdateRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_id() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.id)
}

// int64 delete_time = 5;
inline void LockUpdateRequest::clear_delete_time() {
  delete_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockUpdateRequest::delete_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.delete_time)
  return delete_time_;
}
inline void LockUpdateRequest::set_delete_time(::google::protobuf::int64 value) {
  
  delete_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.delete_time)
}

// bytes update_value = 6;
inline void LockUpdateRequest::clear_update_value() {
  update_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::update_value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.update_value)
  return update_value_.GetNoArena();
}
inline void LockUpdateRequest::set_update_value(const ::std::string& value) {
  
  update_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.update_value)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_update_value(::std::string&& value) {
  
  update_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.update_value)
}
#endif
inline void LockUpdateRequest::set_update_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  update_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.update_value)
}
inline void LockUpdateRequest::set_update_value(const void* value, size_t size) {
  
  update_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.update_value)
}
inline ::std::string* LockUpdateRequest::mutable_update_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.update_value)
  return update_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_update_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.update_value)
  
  return update_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_update_value(::std::string* update_value) {
  if (update_value != NULL) {
    
  } else {
    
  }
  update_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.update_value)
}

// string by = 11;
inline void LockUpdateRequest::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockUpdateRequest::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockUpdateRequest.by)
  return by_.GetNoArena();
}
inline void LockUpdateRequest::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockUpdateRequest.by)
}
#if LANG_CXX11
inline void LockUpdateRequest::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockUpdateRequest.by)
}
#endif
inline void LockUpdateRequest::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockUpdateRequest.by)
}
inline void LockUpdateRequest::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockUpdateRequest.by)
}
inline ::std::string* LockUpdateRequest::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockUpdateRequest.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockUpdateRequest::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockUpdateRequest.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockUpdateRequest::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockUpdateRequest.by)
}

// -------------------------------------------------------------------

// DsLockUpdateRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockUpdateRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockUpdateRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockUpdateRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockUpdateRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockUpdateRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockUpdateRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateRequest.header)
}

// .kvrpcpb.LockUpdateRequest req = 2;
inline bool DsLockUpdateRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockUpdateRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockUpdateRequest& DsLockUpdateRequest::req() const {
  const ::kvrpcpb::LockUpdateRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockUpdateRequest*>(
      &::kvrpcpb::_LockUpdateRequest_default_instance_);
}
inline ::kvrpcpb::LockUpdateRequest* DsLockUpdateRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockUpdateRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateRequest.req)
  return req_;
}
inline ::kvrpcpb::LockUpdateRequest* DsLockUpdateRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateRequest.req)
  
  ::kvrpcpb::LockUpdateRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockUpdateRequest::set_allocated_req(::kvrpcpb::LockUpdateRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateRequest.req)
}

// -------------------------------------------------------------------

// DsLockUpdateResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockUpdateResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockUpdateResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockUpdateResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockUpdateResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockUpdateResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockUpdateResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsLockUpdateResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockUpdateResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsLockUpdateResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockUpdateResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsLockUpdateResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockUpdateResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsLockUpdateResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockUpdateResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockUpdateResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockUpdateResponse.resp)
}

// -------------------------------------------------------------------

// UnlockRequest

// bytes key = 1;
inline void UnlockRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.key)
  return key_.GetNoArena();
}
inline void UnlockRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockRequest.key)
}
#if LANG_CXX11
inline void UnlockRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockRequest.key)
}
#endif
inline void UnlockRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockRequest.key)
}
inline void UnlockRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockRequest.key)
}
inline ::std::string* UnlockRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.key)
}

// string id = 3;
inline void UnlockRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockRequest::id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.id)
  return id_.GetNoArena();
}
inline void UnlockRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockRequest.id)
}
#if LANG_CXX11
inline void UnlockRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockRequest.id)
}
#endif
inline void UnlockRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockRequest.id)
}
inline void UnlockRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockRequest.id)
}
inline ::std::string* UnlockRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_id() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.id)
}

// string by = 11;
inline void UnlockRequest::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockRequest::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockRequest.by)
  return by_.GetNoArena();
}
inline void UnlockRequest::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockRequest.by)
}
#if LANG_CXX11
inline void UnlockRequest::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockRequest.by)
}
#endif
inline void UnlockRequest::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockRequest.by)
}
inline void UnlockRequest::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockRequest.by)
}
inline ::std::string* UnlockRequest::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockRequest.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockRequest::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockRequest.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockRequest::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockRequest.by)
}

// -------------------------------------------------------------------

// DsUnlockRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsUnlockRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsUnlockRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsUnlockRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsUnlockRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockRequest.header)
}

// .kvrpcpb.UnlockRequest req = 2;
inline bool DsUnlockRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsUnlockRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::UnlockRequest& DsUnlockRequest::req() const {
  const ::kvrpcpb::UnlockRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::UnlockRequest*>(
      &::kvrpcpb::_UnlockRequest_default_instance_);
}
inline ::kvrpcpb::UnlockRequest* DsUnlockRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::UnlockRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockRequest.req)
  return req_;
}
inline ::kvrpcpb::UnlockRequest* DsUnlockRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockRequest.req)
  
  ::kvrpcpb::UnlockRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsUnlockRequest::set_allocated_req(::kvrpcpb::UnlockRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockRequest.req)
}

// -------------------------------------------------------------------

// DsUnlockResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsUnlockResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsUnlockResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsUnlockResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsUnlockResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsUnlockResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsUnlockResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsUnlockResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsUnlockResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsUnlockResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsUnlockResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockResponse.resp)
}

// -------------------------------------------------------------------

// UnlockForceRequest

// bytes key = 1;
inline void UnlockForceRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockForceRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockForceRequest.key)
  return key_.GetNoArena();
}
inline void UnlockForceRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockForceRequest.key)
}
#if LANG_CXX11
inline void UnlockForceRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockForceRequest.key)
}
#endif
inline void UnlockForceRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockForceRequest.key)
}
inline void UnlockForceRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockForceRequest.key)
}
inline ::std::string* UnlockForceRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockForceRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockForceRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockForceRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockForceRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockForceRequest.key)
}

// string by = 11;
inline void UnlockForceRequest::clear_by() {
  by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockForceRequest::by() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.UnlockForceRequest.by)
  return by_.GetNoArena();
}
inline void UnlockForceRequest::set_by(const ::std::string& value) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.UnlockForceRequest.by)
}
#if LANG_CXX11
inline void UnlockForceRequest::set_by(::std::string&& value) {
  
  by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.UnlockForceRequest.by)
}
#endif
inline void UnlockForceRequest::set_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.UnlockForceRequest.by)
}
inline void UnlockForceRequest::set_by(const char* value, size_t size) {
  
  by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.UnlockForceRequest.by)
}
inline ::std::string* UnlockForceRequest::mutable_by() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.UnlockForceRequest.by)
  return by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockForceRequest::release_by() {
  // @@protoc_insertion_point(field_release:kvrpcpb.UnlockForceRequest.by)
  
  return by_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockForceRequest::set_allocated_by(::std::string* by) {
  if (by != NULL) {
    
  } else {
    
  }
  by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), by);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.UnlockForceRequest.by)
}

// -------------------------------------------------------------------

// DsUnlockForceRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsUnlockForceRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockForceRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsUnlockForceRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsUnlockForceRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsUnlockForceRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockForceRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceRequest.header)
}

// .kvrpcpb.UnlockForceRequest req = 2;
inline bool DsUnlockForceRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsUnlockForceRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::UnlockForceRequest& DsUnlockForceRequest::req() const {
  const ::kvrpcpb::UnlockForceRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::UnlockForceRequest*>(
      &::kvrpcpb::_UnlockForceRequest_default_instance_);
}
inline ::kvrpcpb::UnlockForceRequest* DsUnlockForceRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::UnlockForceRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceRequest.req)
  return req_;
}
inline ::kvrpcpb::UnlockForceRequest* DsUnlockForceRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceRequest.req)
  
  ::kvrpcpb::UnlockForceRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsUnlockForceRequest::set_allocated_req(::kvrpcpb::UnlockForceRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceRequest.req)
}

// -------------------------------------------------------------------

// DsUnlockForceResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsUnlockForceResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsUnlockForceResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsUnlockForceResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsUnlockForceResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsUnlockForceResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsUnlockForceResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceResponse.header)
}

// .kvrpcpb.LockResponse resp = 2;
inline bool DsUnlockForceResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsUnlockForceResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockResponse& DsUnlockForceResponse::resp() const {
  const ::kvrpcpb::LockResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsUnlockForceResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockResponse*>(
      &::kvrpcpb::_LockResponse_default_instance_);
}
inline ::kvrpcpb::LockResponse* DsUnlockForceResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsUnlockForceResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockResponse* DsUnlockForceResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsUnlockForceResponse.resp)
  
  ::kvrpcpb::LockResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsUnlockForceResponse::set_allocated_resp(::kvrpcpb::LockResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsUnlockForceResponse.resp)
}

// -------------------------------------------------------------------

// LockScanRequest

// bytes start = 1;
inline void LockScanRequest::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockScanRequest::start() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanRequest.start)
  return start_.GetNoArena();
}
inline void LockScanRequest::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanRequest.start)
}
#if LANG_CXX11
inline void LockScanRequest::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockScanRequest.start)
}
#endif
inline void LockScanRequest::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockScanRequest.start)
}
inline void LockScanRequest::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockScanRequest.start)
}
inline ::std::string* LockScanRequest::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanRequest.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockScanRequest::release_start() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockScanRequest.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockScanRequest::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockScanRequest.start)
}

// bytes limit = 2;
inline void LockScanRequest::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockScanRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanRequest.limit)
  return limit_.GetNoArena();
}
inline void LockScanRequest::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanRequest.limit)
}
#if LANG_CXX11
inline void LockScanRequest::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockScanRequest.limit)
}
#endif
inline void LockScanRequest::set_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockScanRequest.limit)
}
inline void LockScanRequest::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockScanRequest.limit)
}
inline ::std::string* LockScanRequest::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockScanRequest.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockScanRequest::release_limit() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockScanRequest.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockScanRequest::set_allocated_limit(::std::string* limit) {
  if (limit != NULL) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockScanRequest.limit)
}

// uint32 count = 3;
inline void LockScanRequest::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 LockScanRequest::count() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockScanRequest.count)
  return count_;
}
inline void LockScanRequest::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockScanRequest.count)
}

// -------------------------------------------------------------------

// DsLockScanRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockScanRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockScanRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockScanRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockScanRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockScanRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockScanRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanRequest.header)
}

// .kvrpcpb.LockScanRequest req = 2;
inline bool DsLockScanRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockScanRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockScanRequest& DsLockScanRequest::req() const {
  const ::kvrpcpb::LockScanRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockScanRequest*>(
      &::kvrpcpb::_LockScanRequest_default_instance_);
}
inline ::kvrpcpb::LockScanRequest* DsLockScanRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanRequest.req)
  return req_;
}
inline ::kvrpcpb::LockScanRequest* DsLockScanRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanRequest.req)
  
  ::kvrpcpb::LockScanRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockScanRequest::set_allocated_req(::kvrpcpb::LockScanRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanRequest.req)
}

// -------------------------------------------------------------------

// DsLockScanResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockScanResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockScanResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockScanResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockScanResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockScanResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockScanResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanResponse.header)
}

// .kvrpcpb.LockScanResponse resp = 2;
inline bool DsLockScanResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockScanResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockScanResponse& DsLockScanResponse::resp() const {
  const ::kvrpcpb::LockScanResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockScanResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockScanResponse*>(
      &::kvrpcpb::_LockScanResponse_default_instance_);
}
inline ::kvrpcpb::LockScanResponse* DsLockScanResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockScanResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockScanResponse* DsLockScanResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockScanResponse.resp)
  
  ::kvrpcpb::LockScanResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockScanResponse::set_allocated_resp(::kvrpcpb::LockScanResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockScanResponse.resp)
}

// -------------------------------------------------------------------

// LockGetRequest

// bytes key = 1;
inline void LockGetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockGetRequest.key)
  return key_.GetNoArena();
}
inline void LockGetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockGetRequest.key)
}
#if LANG_CXX11
inline void LockGetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockGetRequest.key)
}
#endif
inline void LockGetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockGetRequest.key)
}
inline void LockGetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockGetRequest.key)
}
inline ::std::string* LockGetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockGetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockGetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockGetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockGetRequest.key)
}

// -------------------------------------------------------------------

// LockGetResponse

// int64 code = 1;
inline void LockGetResponse::clear_code() {
  code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LockGetResponse::code() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockGetResponse.code)
  return code_;
}
inline void LockGetResponse::set_code(::google::protobuf::int64 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockGetResponse.code)
}

// string error = 2;
inline void LockGetResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockGetResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockGetResponse.error)
  return error_.GetNoArena();
}
inline void LockGetResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockGetResponse.error)
}
#if LANG_CXX11
inline void LockGetResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockGetResponse.error)
}
#endif
inline void LockGetResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockGetResponse.error)
}
inline void LockGetResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockGetResponse.error)
}
inline ::std::string* LockGetResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockGetResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockGetResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockGetResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockGetResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockGetResponse.error)
}

// .kvrpcpb.LockValue value = 3;
inline bool LockGetResponse::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void LockGetResponse::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::kvrpcpb::LockValue& LockGetResponse::value() const {
  const ::kvrpcpb::LockValue* p = value_;
  // @@protoc_insertion_point(field_get:kvrpcpb.LockGetResponse.value)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockValue*>(
      &::kvrpcpb::_LockValue_default_instance_);
}
inline ::kvrpcpb::LockValue* LockGetResponse::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::kvrpcpb::LockValue;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockGetResponse.value)
  return value_;
}
inline ::kvrpcpb::LockValue* LockGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockGetResponse.value)
  
  ::kvrpcpb::LockValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void LockGetResponse::set_allocated_value(::kvrpcpb::LockValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockGetResponse.value)
}

// -------------------------------------------------------------------

// DsLockGetRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsLockGetRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockGetRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsLockGetRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockGetRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsLockGetRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockGetRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsLockGetRequest::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockGetRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockGetRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockGetRequest.header)
}

// .kvrpcpb.LockGetRequest req = 2;
inline bool DsLockGetRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsLockGetRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::kvrpcpb::LockGetRequest& DsLockGetRequest::req() const {
  const ::kvrpcpb::LockGetRequest* p = req_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockGetRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockGetRequest*>(
      &::kvrpcpb::_LockGetRequest_default_instance_);
}
inline ::kvrpcpb::LockGetRequest* DsLockGetRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::kvrpcpb::LockGetRequest;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockGetRequest.req)
  return req_;
}
inline ::kvrpcpb::LockGetRequest* DsLockGetRequest::release_req() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockGetRequest.req)
  
  ::kvrpcpb::LockGetRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsLockGetRequest::set_allocated_req(::kvrpcpb::LockGetRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockGetRequest.req)
}

// -------------------------------------------------------------------

// DsLockGetResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsLockGetResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsLockGetResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsLockGetResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockGetResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsLockGetResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockGetResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsLockGetResponse::release_header() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockGetResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsLockGetResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockGetResponse.header)
}

// .kvrpcpb.LockGetResponse resp = 2;
inline bool DsLockGetResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsLockGetResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::kvrpcpb::LockGetResponse& DsLockGetResponse::resp() const {
  const ::kvrpcpb::LockGetResponse* p = resp_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DsLockGetResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockGetResponse*>(
      &::kvrpcpb::_LockGetResponse_default_instance_);
}
inline ::kvrpcpb::LockGetResponse* DsLockGetResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::kvrpcpb::LockGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DsLockGetResponse.resp)
  return resp_;
}
inline ::kvrpcpb::LockGetResponse* DsLockGetResponse::release_resp() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DsLockGetResponse.resp)
  
  ::kvrpcpb::LockGetResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsLockGetResponse::set_allocated_resp(::kvrpcpb::LockGetResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DsLockGetResponse.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace kvrpcpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kvrpcpb::SelectField_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::SelectField_Type>() {
  return ::kvrpcpb::SelectField_Type_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::ExecuteType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::ExecuteType>() {
  return ::kvrpcpb::ExecuteType_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::MatchType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::MatchType>() {
  return ::kvrpcpb::MatchType_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::FieldType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::FieldType>() {
  return ::kvrpcpb::FieldType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kvrpcpb_2eproto__INCLUDED
