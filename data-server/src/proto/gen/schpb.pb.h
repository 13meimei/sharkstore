// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schpb.proto

#ifndef PROTOBUF_schpb_2eproto__INCLUDED
#define PROTOBUF_schpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "errorpb.pb.h"
// @@protoc_insertion_point(includes)
namespace schpb {
class CreateRangeRequest;
class CreateRangeRequestDefaultTypeInternal;
extern CreateRangeRequestDefaultTypeInternal _CreateRangeRequest_default_instance_;
class CreateRangeResponse;
class CreateRangeResponseDefaultTypeInternal;
extern CreateRangeResponseDefaultTypeInternal _CreateRangeResponse_default_instance_;
class DeleteRangeRequest;
class DeleteRangeRequestDefaultTypeInternal;
extern DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
class DeleteRangeResponse;
class DeleteRangeResponseDefaultTypeInternal;
extern DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
class GetPeerInfoRequest;
class GetPeerInfoRequestDefaultTypeInternal;
extern GetPeerInfoRequestDefaultTypeInternal _GetPeerInfoRequest_default_instance_;
class GetPeerInfoResponse;
class GetPeerInfoResponseDefaultTypeInternal;
extern GetPeerInfoResponseDefaultTypeInternal _GetPeerInfoResponse_default_instance_;
class OfflineRangeRequest;
class OfflineRangeRequestDefaultTypeInternal;
extern OfflineRangeRequestDefaultTypeInternal _OfflineRangeRequest_default_instance_;
class OfflineRangeResponse;
class OfflineRangeResponseDefaultTypeInternal;
extern OfflineRangeResponseDefaultTypeInternal _OfflineRangeResponse_default_instance_;
class ReplaceRangeRequest;
class ReplaceRangeRequestDefaultTypeInternal;
extern ReplaceRangeRequestDefaultTypeInternal _ReplaceRangeRequest_default_instance_;
class ReplaceRangeResponse;
class ReplaceRangeResponseDefaultTypeInternal;
extern ReplaceRangeResponseDefaultTypeInternal _ReplaceRangeResponse_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class SetNodeLogLevelRequest;
class SetNodeLogLevelRequestDefaultTypeInternal;
extern SetNodeLogLevelRequestDefaultTypeInternal _SetNodeLogLevelRequest_default_instance_;
class SetNodeLogLevelResponse;
class SetNodeLogLevelResponseDefaultTypeInternal;
extern SetNodeLogLevelResponseDefaultTypeInternal _SetNodeLogLevelResponse_default_instance_;
class TransferRangeLeaderRequest;
class TransferRangeLeaderRequestDefaultTypeInternal;
extern TransferRangeLeaderRequestDefaultTypeInternal _TransferRangeLeaderRequest_default_instance_;
class TransferRangeLeaderResponse;
class TransferRangeLeaderResponseDefaultTypeInternal;
extern TransferRangeLeaderResponseDefaultTypeInternal _TransferRangeLeaderResponse_default_instance_;
class UpdateRangeRequest;
class UpdateRangeRequestDefaultTypeInternal;
extern UpdateRangeRequestDefaultTypeInternal _UpdateRangeRequest_default_instance_;
class UpdateRangeResponse;
class UpdateRangeResponseDefaultTypeInternal;
extern UpdateRangeResponseDefaultTypeInternal _UpdateRangeResponse_default_instance_;
}  // namespace schpb

namespace schpb {

namespace protobuf_schpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_schpb_2eproto

// ===================================================================

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::errorpb::Error& error() const;
  ::errorpb::Error* mutable_error();
  ::errorpb::Error* release_error();
  void set_allocated_error(::errorpb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.CreateRangeRequest) */ {
 public:
  CreateRangeRequest();
  virtual ~CreateRangeRequest();

  CreateRangeRequest(const CreateRangeRequest& from);

  inline CreateRangeRequest& operator=(const CreateRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRangeRequest(CreateRangeRequest&& from) noexcept
    : CreateRangeRequest() {
    *this = ::std::move(from);
  }

  inline CreateRangeRequest& operator=(CreateRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRangeRequest& default_instance();

  static inline const CreateRangeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRangeRequest*>(
               &_CreateRangeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CreateRangeRequest* other);
  friend void swap(CreateRangeRequest& a, CreateRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRangeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRangeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRangeRequest& from);
  void MergeFrom(const CreateRangeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // .metapb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // @@protoc_insertion_point(class_scope:schpb.CreateRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::metapb::Range* range_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.CreateRangeResponse) */ {
 public:
  CreateRangeResponse();
  virtual ~CreateRangeResponse();

  CreateRangeResponse(const CreateRangeResponse& from);

  inline CreateRangeResponse& operator=(const CreateRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRangeResponse(CreateRangeResponse&& from) noexcept
    : CreateRangeResponse() {
    *this = ::std::move(from);
  }

  inline CreateRangeResponse& operator=(CreateRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRangeResponse& default_instance();

  static inline const CreateRangeResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRangeResponse*>(
               &_CreateRangeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CreateRangeResponse* other);
  friend void swap(CreateRangeResponse& a, CreateRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRangeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRangeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRangeResponse& from);
  void MergeFrom(const CreateRangeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.CreateRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.DeleteRangeRequest) */ {
 public:
  DeleteRangeRequest();
  virtual ~DeleteRangeRequest();

  DeleteRangeRequest(const DeleteRangeRequest& from);

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRangeRequest(DeleteRangeRequest&& from) noexcept
    : DeleteRangeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRangeRequest& operator=(DeleteRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeRequest& default_instance();

  static inline const DeleteRangeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeRequest*>(
               &_DeleteRangeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DeleteRangeRequest* other);
  friend void swap(DeleteRangeRequest& a, DeleteRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRangeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteRangeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteRangeRequest& from);
  void MergeFrom(const DeleteRangeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // uint64 peer_id = 3;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 3;
  ::google::protobuf::uint64 peer_id() const;
  void set_peer_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.DeleteRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::google::protobuf::uint64 range_id_;
  ::google::protobuf::uint64 peer_id_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.DeleteRangeResponse) */ {
 public:
  DeleteRangeResponse();
  virtual ~DeleteRangeResponse();

  DeleteRangeResponse(const DeleteRangeResponse& from);

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRangeResponse(DeleteRangeResponse&& from) noexcept
    : DeleteRangeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRangeResponse& operator=(DeleteRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeResponse& default_instance();

  static inline const DeleteRangeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeResponse*>(
               &_DeleteRangeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DeleteRangeResponse* other);
  friend void swap(DeleteRangeResponse& a, DeleteRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRangeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteRangeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteRangeResponse& from);
  void MergeFrom(const DeleteRangeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.DeleteRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransferRangeLeaderRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.TransferRangeLeaderRequest) */ {
 public:
  TransferRangeLeaderRequest();
  virtual ~TransferRangeLeaderRequest();

  TransferRangeLeaderRequest(const TransferRangeLeaderRequest& from);

  inline TransferRangeLeaderRequest& operator=(const TransferRangeLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferRangeLeaderRequest(TransferRangeLeaderRequest&& from) noexcept
    : TransferRangeLeaderRequest() {
    *this = ::std::move(from);
  }

  inline TransferRangeLeaderRequest& operator=(TransferRangeLeaderRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferRangeLeaderRequest& default_instance();

  static inline const TransferRangeLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const TransferRangeLeaderRequest*>(
               &_TransferRangeLeaderRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TransferRangeLeaderRequest* other);
  friend void swap(TransferRangeLeaderRequest& a, TransferRangeLeaderRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferRangeLeaderRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TransferRangeLeaderRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransferRangeLeaderRequest& from);
  void MergeFrom(const TransferRangeLeaderRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransferRangeLeaderRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.TransferRangeLeaderRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransferRangeLeaderResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.TransferRangeLeaderResponse) */ {
 public:
  TransferRangeLeaderResponse();
  virtual ~TransferRangeLeaderResponse();

  TransferRangeLeaderResponse(const TransferRangeLeaderResponse& from);

  inline TransferRangeLeaderResponse& operator=(const TransferRangeLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferRangeLeaderResponse(TransferRangeLeaderResponse&& from) noexcept
    : TransferRangeLeaderResponse() {
    *this = ::std::move(from);
  }

  inline TransferRangeLeaderResponse& operator=(TransferRangeLeaderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferRangeLeaderResponse& default_instance();

  static inline const TransferRangeLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const TransferRangeLeaderResponse*>(
               &_TransferRangeLeaderResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TransferRangeLeaderResponse* other);
  friend void swap(TransferRangeLeaderResponse& a, TransferRangeLeaderResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferRangeLeaderResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TransferRangeLeaderResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransferRangeLeaderResponse& from);
  void MergeFrom(const TransferRangeLeaderResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransferRangeLeaderResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.TransferRangeLeaderResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPeerInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.GetPeerInfoRequest) */ {
 public:
  GetPeerInfoRequest();
  virtual ~GetPeerInfoRequest();

  GetPeerInfoRequest(const GetPeerInfoRequest& from);

  inline GetPeerInfoRequest& operator=(const GetPeerInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPeerInfoRequest(GetPeerInfoRequest&& from) noexcept
    : GetPeerInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetPeerInfoRequest& operator=(GetPeerInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPeerInfoRequest& default_instance();

  static inline const GetPeerInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetPeerInfoRequest*>(
               &_GetPeerInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetPeerInfoRequest* other);
  friend void swap(GetPeerInfoRequest& a, GetPeerInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPeerInfoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetPeerInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPeerInfoRequest& from);
  void MergeFrom(const GetPeerInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPeerInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.GetPeerInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPeerInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.GetPeerInfoResponse) */ {
 public:
  GetPeerInfoResponse();
  virtual ~GetPeerInfoResponse();

  GetPeerInfoResponse(const GetPeerInfoResponse& from);

  inline GetPeerInfoResponse& operator=(const GetPeerInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPeerInfoResponse(GetPeerInfoResponse&& from) noexcept
    : GetPeerInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetPeerInfoResponse& operator=(GetPeerInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPeerInfoResponse& default_instance();

  static inline const GetPeerInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetPeerInfoResponse*>(
               &_GetPeerInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(GetPeerInfoResponse* other);
  friend void swap(GetPeerInfoResponse& a, GetPeerInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPeerInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetPeerInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPeerInfoResponse& from);
  void MergeFrom(const GetPeerInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPeerInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // .metapb.Replica replica = 2;
  bool has_replica() const;
  void clear_replica();
  static const int kReplicaFieldNumber = 2;
  const ::metapb::Replica& replica() const;
  ::metapb::Replica* mutable_replica();
  ::metapb::Replica* release_replica();
  void set_allocated_replica(::metapb::Replica* replica);

  // uint64 index = 3;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // uint64 term = 4;
  void clear_term();
  static const int kTermFieldNumber = 4;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // uint64 commit = 5;
  void clear_commit();
  static const int kCommitFieldNumber = 5;
  ::google::protobuf::uint64 commit() const;
  void set_commit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.GetPeerInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  ::metapb::Replica* replica_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 term_;
  ::google::protobuf::uint64 commit_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.UpdateRangeRequest) */ {
 public:
  UpdateRangeRequest();
  virtual ~UpdateRangeRequest();

  UpdateRangeRequest(const UpdateRangeRequest& from);

  inline UpdateRangeRequest& operator=(const UpdateRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRangeRequest(UpdateRangeRequest&& from) noexcept
    : UpdateRangeRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRangeRequest& operator=(UpdateRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRangeRequest& default_instance();

  static inline const UpdateRangeRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRangeRequest*>(
               &_UpdateRangeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(UpdateRangeRequest* other);
  friend void swap(UpdateRangeRequest& a, UpdateRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRangeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateRangeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateRangeRequest& from);
  void MergeFrom(const UpdateRangeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // .metapb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // @@protoc_insertion_point(class_scope:schpb.UpdateRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::metapb::Range* range_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.UpdateRangeResponse) */ {
 public:
  UpdateRangeResponse();
  virtual ~UpdateRangeResponse();

  UpdateRangeResponse(const UpdateRangeResponse& from);

  inline UpdateRangeResponse& operator=(const UpdateRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRangeResponse(UpdateRangeResponse&& from) noexcept
    : UpdateRangeResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRangeResponse& operator=(UpdateRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRangeResponse& default_instance();

  static inline const UpdateRangeResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRangeResponse*>(
               &_UpdateRangeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(UpdateRangeResponse* other);
  friend void swap(UpdateRangeResponse& a, UpdateRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRangeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateRangeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateRangeResponse& from);
  void MergeFrom(const UpdateRangeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.UpdateRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplaceRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.ReplaceRangeRequest) */ {
 public:
  ReplaceRangeRequest();
  virtual ~ReplaceRangeRequest();

  ReplaceRangeRequest(const ReplaceRangeRequest& from);

  inline ReplaceRangeRequest& operator=(const ReplaceRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplaceRangeRequest(ReplaceRangeRequest&& from) noexcept
    : ReplaceRangeRequest() {
    *this = ::std::move(from);
  }

  inline ReplaceRangeRequest& operator=(ReplaceRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceRangeRequest& default_instance();

  static inline const ReplaceRangeRequest* internal_default_instance() {
    return reinterpret_cast<const ReplaceRangeRequest*>(
               &_ReplaceRangeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ReplaceRangeRequest* other);
  friend void swap(ReplaceRangeRequest& a, ReplaceRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplaceRangeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReplaceRangeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReplaceRangeRequest& from);
  void MergeFrom(const ReplaceRangeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReplaceRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // .metapb.Range new_range = 3;
  bool has_new_range() const;
  void clear_new_range();
  static const int kNewRangeFieldNumber = 3;
  const ::metapb::Range& new_range() const;
  ::metapb::Range* mutable_new_range();
  ::metapb::Range* release_new_range();
  void set_allocated_new_range(::metapb::Range* new_range);

  // uint64 old_range_id = 2;
  void clear_old_range_id();
  static const int kOldRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 old_range_id() const;
  void set_old_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.ReplaceRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::metapb::Range* new_range_;
  ::google::protobuf::uint64 old_range_id_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplaceRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.ReplaceRangeResponse) */ {
 public:
  ReplaceRangeResponse();
  virtual ~ReplaceRangeResponse();

  ReplaceRangeResponse(const ReplaceRangeResponse& from);

  inline ReplaceRangeResponse& operator=(const ReplaceRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplaceRangeResponse(ReplaceRangeResponse&& from) noexcept
    : ReplaceRangeResponse() {
    *this = ::std::move(from);
  }

  inline ReplaceRangeResponse& operator=(ReplaceRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceRangeResponse& default_instance();

  static inline const ReplaceRangeResponse* internal_default_instance() {
    return reinterpret_cast<const ReplaceRangeResponse*>(
               &_ReplaceRangeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ReplaceRangeResponse* other);
  friend void swap(ReplaceRangeResponse& a, ReplaceRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplaceRangeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReplaceRangeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReplaceRangeResponse& from);
  void MergeFrom(const ReplaceRangeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReplaceRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.ReplaceRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetNodeLogLevelRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.SetNodeLogLevelRequest) */ {
 public:
  SetNodeLogLevelRequest();
  virtual ~SetNodeLogLevelRequest();

  SetNodeLogLevelRequest(const SetNodeLogLevelRequest& from);

  inline SetNodeLogLevelRequest& operator=(const SetNodeLogLevelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetNodeLogLevelRequest(SetNodeLogLevelRequest&& from) noexcept
    : SetNodeLogLevelRequest() {
    *this = ::std::move(from);
  }

  inline SetNodeLogLevelRequest& operator=(SetNodeLogLevelRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetNodeLogLevelRequest& default_instance();

  static inline const SetNodeLogLevelRequest* internal_default_instance() {
    return reinterpret_cast<const SetNodeLogLevelRequest*>(
               &_SetNodeLogLevelRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SetNodeLogLevelRequest* other);
  friend void swap(SetNodeLogLevelRequest& a, SetNodeLogLevelRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetNodeLogLevelRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SetNodeLogLevelRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetNodeLogLevelRequest& from);
  void MergeFrom(const SetNodeLogLevelRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetNodeLogLevelRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string level = 2;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  const ::std::string& level() const;
  void set_level(const ::std::string& value);
  #if LANG_CXX11
  void set_level(::std::string&& value);
  #endif
  void set_level(const char* value);
  void set_level(const char* value, size_t size);
  ::std::string* mutable_level();
  ::std::string* release_level();
  void set_allocated_level(::std::string* level);

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.SetNodeLogLevelRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr level_;
  ::schpb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetNodeLogLevelResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.SetNodeLogLevelResponse) */ {
 public:
  SetNodeLogLevelResponse();
  virtual ~SetNodeLogLevelResponse();

  SetNodeLogLevelResponse(const SetNodeLogLevelResponse& from);

  inline SetNodeLogLevelResponse& operator=(const SetNodeLogLevelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetNodeLogLevelResponse(SetNodeLogLevelResponse&& from) noexcept
    : SetNodeLogLevelResponse() {
    *this = ::std::move(from);
  }

  inline SetNodeLogLevelResponse& operator=(SetNodeLogLevelResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetNodeLogLevelResponse& default_instance();

  static inline const SetNodeLogLevelResponse* internal_default_instance() {
    return reinterpret_cast<const SetNodeLogLevelResponse*>(
               &_SetNodeLogLevelResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SetNodeLogLevelResponse* other);
  friend void swap(SetNodeLogLevelResponse& a, SetNodeLogLevelResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetNodeLogLevelResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SetNodeLogLevelResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetNodeLogLevelResponse& from);
  void MergeFrom(const SetNodeLogLevelResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetNodeLogLevelResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.SetNodeLogLevelResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.OfflineRangeRequest) */ {
 public:
  OfflineRangeRequest();
  virtual ~OfflineRangeRequest();

  OfflineRangeRequest(const OfflineRangeRequest& from);

  inline OfflineRangeRequest& operator=(const OfflineRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineRangeRequest(OfflineRangeRequest&& from) noexcept
    : OfflineRangeRequest() {
    *this = ::std::move(from);
  }

  inline OfflineRangeRequest& operator=(OfflineRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineRangeRequest& default_instance();

  static inline const OfflineRangeRequest* internal_default_instance() {
    return reinterpret_cast<const OfflineRangeRequest*>(
               &_OfflineRangeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(OfflineRangeRequest* other);
  friend void swap(OfflineRangeRequest& a, OfflineRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineRangeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  OfflineRangeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OfflineRangeRequest& from);
  void MergeFrom(const OfflineRangeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OfflineRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::RequestHeader& header() const;
  ::schpb::RequestHeader* mutable_header();
  ::schpb::RequestHeader* release_header();
  void set_allocated_header(::schpb::RequestHeader* header);

  // uint64 rangeId = 2;
  void clear_rangeid();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 rangeid() const;
  void set_rangeid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:schpb.OfflineRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::RequestHeader* header_;
  ::google::protobuf::uint64 rangeid_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schpb.OfflineRangeResponse) */ {
 public:
  OfflineRangeResponse();
  virtual ~OfflineRangeResponse();

  OfflineRangeResponse(const OfflineRangeResponse& from);

  inline OfflineRangeResponse& operator=(const OfflineRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineRangeResponse(OfflineRangeResponse&& from) noexcept
    : OfflineRangeResponse() {
    *this = ::std::move(from);
  }

  inline OfflineRangeResponse& operator=(OfflineRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineRangeResponse& default_instance();

  static inline const OfflineRangeResponse* internal_default_instance() {
    return reinterpret_cast<const OfflineRangeResponse*>(
               &_OfflineRangeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(OfflineRangeResponse* other);
  friend void swap(OfflineRangeResponse& a, OfflineRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineRangeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  OfflineRangeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OfflineRangeResponse& from);
  void MergeFrom(const OfflineRangeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OfflineRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schpb::ResponseHeader& header() const;
  ::schpb::ResponseHeader* mutable_header();
  ::schpb::ResponseHeader* release_header();
  void set_allocated_header(::schpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schpb.OfflineRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schpb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_schpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:schpb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.RequestHeader.cluster_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:schpb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.ResponseHeader.cluster_id)
}

// .errorpb.Error error = 2;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::errorpb::Error& ResponseHeader::error() const {
  const ::errorpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:schpb.ResponseHeader.error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::errorpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:schpb.ResponseHeader.error)
  return error_;
}
inline ::errorpb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:schpb.ResponseHeader.error)
  
  ::errorpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_error(::errorpb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// CreateRangeRequest

// .schpb.RequestHeader header = 1;
inline bool CreateRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& CreateRangeRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.CreateRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* CreateRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.CreateRangeRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* CreateRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.CreateRangeRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateRangeRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.CreateRangeRequest.header)
}

// .metapb.Range range = 2;
inline bool CreateRangeRequest::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void CreateRangeRequest::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& CreateRangeRequest::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:schpb.CreateRangeRequest.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* CreateRangeRequest::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:schpb.CreateRangeRequest.range)
  return range_;
}
inline ::metapb::Range* CreateRangeRequest::release_range() {
  // @@protoc_insertion_point(field_release:schpb.CreateRangeRequest.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void CreateRangeRequest::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.CreateRangeRequest.range)
}

// -------------------------------------------------------------------

// CreateRangeResponse

// .schpb.ResponseHeader header = 1;
inline bool CreateRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& CreateRangeResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.CreateRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* CreateRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.CreateRangeResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* CreateRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.CreateRangeResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateRangeResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.CreateRangeResponse.header)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

// .schpb.RequestHeader header = 1;
inline bool DeleteRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DeleteRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& DeleteRangeRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.DeleteRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* DeleteRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.DeleteRangeRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* DeleteRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.DeleteRangeRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRangeRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.DeleteRangeRequest.header)
}

// uint64 range_id = 2;
inline void DeleteRangeRequest::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DeleteRangeRequest::range_id() const {
  // @@protoc_insertion_point(field_get:schpb.DeleteRangeRequest.range_id)
  return range_id_;
}
inline void DeleteRangeRequest::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.DeleteRangeRequest.range_id)
}

// uint64 peer_id = 3;
inline void DeleteRangeRequest::clear_peer_id() {
  peer_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DeleteRangeRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:schpb.DeleteRangeRequest.peer_id)
  return peer_id_;
}
inline void DeleteRangeRequest::set_peer_id(::google::protobuf::uint64 value) {
  
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.DeleteRangeRequest.peer_id)
}

// -------------------------------------------------------------------

// DeleteRangeResponse

// .schpb.ResponseHeader header = 1;
inline bool DeleteRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DeleteRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& DeleteRangeResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.DeleteRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* DeleteRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.DeleteRangeResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* DeleteRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.DeleteRangeResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRangeResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.DeleteRangeResponse.header)
}

// -------------------------------------------------------------------

// TransferRangeLeaderRequest

// .schpb.RequestHeader header = 1;
inline bool TransferRangeLeaderRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TransferRangeLeaderRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& TransferRangeLeaderRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.TransferRangeLeaderRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* TransferRangeLeaderRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.TransferRangeLeaderRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* TransferRangeLeaderRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.TransferRangeLeaderRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TransferRangeLeaderRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.TransferRangeLeaderRequest.header)
}

// uint64 range_id = 2;
inline void TransferRangeLeaderRequest::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TransferRangeLeaderRequest::range_id() const {
  // @@protoc_insertion_point(field_get:schpb.TransferRangeLeaderRequest.range_id)
  return range_id_;
}
inline void TransferRangeLeaderRequest::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.TransferRangeLeaderRequest.range_id)
}

// -------------------------------------------------------------------

// TransferRangeLeaderResponse

// .schpb.ResponseHeader header = 1;
inline bool TransferRangeLeaderResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TransferRangeLeaderResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& TransferRangeLeaderResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.TransferRangeLeaderResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* TransferRangeLeaderResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.TransferRangeLeaderResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* TransferRangeLeaderResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.TransferRangeLeaderResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TransferRangeLeaderResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.TransferRangeLeaderResponse.header)
}

// -------------------------------------------------------------------

// GetPeerInfoRequest

// .schpb.RequestHeader header = 1;
inline bool GetPeerInfoRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetPeerInfoRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& GetPeerInfoRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* GetPeerInfoRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.GetPeerInfoRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* GetPeerInfoRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.GetPeerInfoRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetPeerInfoRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.GetPeerInfoRequest.header)
}

// uint64 range_id = 2;
inline void GetPeerInfoRequest::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetPeerInfoRequest::range_id() const {
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoRequest.range_id)
  return range_id_;
}
inline void GetPeerInfoRequest::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.GetPeerInfoRequest.range_id)
}

// -------------------------------------------------------------------

// GetPeerInfoResponse

// .schpb.ResponseHeader header = 1;
inline bool GetPeerInfoResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetPeerInfoResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& GetPeerInfoResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* GetPeerInfoResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.GetPeerInfoResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* GetPeerInfoResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.GetPeerInfoResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetPeerInfoResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.GetPeerInfoResponse.header)
}

// .metapb.Replica replica = 2;
inline bool GetPeerInfoResponse::has_replica() const {
  return this != internal_default_instance() && replica_ != NULL;
}
inline void GetPeerInfoResponse::clear_replica() {
  if (GetArenaNoVirtual() == NULL && replica_ != NULL) delete replica_;
  replica_ = NULL;
}
inline const ::metapb::Replica& GetPeerInfoResponse::replica() const {
  const ::metapb::Replica* p = replica_;
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoResponse.replica)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Replica*>(
      &::metapb::_Replica_default_instance_);
}
inline ::metapb::Replica* GetPeerInfoResponse::mutable_replica() {
  
  if (replica_ == NULL) {
    replica_ = new ::metapb::Replica;
  }
  // @@protoc_insertion_point(field_mutable:schpb.GetPeerInfoResponse.replica)
  return replica_;
}
inline ::metapb::Replica* GetPeerInfoResponse::release_replica() {
  // @@protoc_insertion_point(field_release:schpb.GetPeerInfoResponse.replica)
  
  ::metapb::Replica* temp = replica_;
  replica_ = NULL;
  return temp;
}
inline void GetPeerInfoResponse::set_allocated_replica(::metapb::Replica* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.GetPeerInfoResponse.replica)
}

// uint64 index = 3;
inline void GetPeerInfoResponse::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetPeerInfoResponse::index() const {
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoResponse.index)
  return index_;
}
inline void GetPeerInfoResponse::set_index(::google::protobuf::uint64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:schpb.GetPeerInfoResponse.index)
}

// uint64 term = 4;
inline void GetPeerInfoResponse::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetPeerInfoResponse::term() const {
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoResponse.term)
  return term_;
}
inline void GetPeerInfoResponse::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:schpb.GetPeerInfoResponse.term)
}

// uint64 commit = 5;
inline void GetPeerInfoResponse::clear_commit() {
  commit_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetPeerInfoResponse::commit() const {
  // @@protoc_insertion_point(field_get:schpb.GetPeerInfoResponse.commit)
  return commit_;
}
inline void GetPeerInfoResponse::set_commit(::google::protobuf::uint64 value) {
  
  commit_ = value;
  // @@protoc_insertion_point(field_set:schpb.GetPeerInfoResponse.commit)
}

// -------------------------------------------------------------------

// UpdateRangeRequest

// .schpb.RequestHeader header = 1;
inline bool UpdateRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpdateRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& UpdateRangeRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.UpdateRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* UpdateRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.UpdateRangeRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* UpdateRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.UpdateRangeRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UpdateRangeRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.UpdateRangeRequest.header)
}

// .metapb.Range range = 2;
inline bool UpdateRangeRequest::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void UpdateRangeRequest::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& UpdateRangeRequest::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:schpb.UpdateRangeRequest.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* UpdateRangeRequest::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:schpb.UpdateRangeRequest.range)
  return range_;
}
inline ::metapb::Range* UpdateRangeRequest::release_range() {
  // @@protoc_insertion_point(field_release:schpb.UpdateRangeRequest.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void UpdateRangeRequest::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.UpdateRangeRequest.range)
}

// -------------------------------------------------------------------

// UpdateRangeResponse

// .schpb.ResponseHeader header = 1;
inline bool UpdateRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void UpdateRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& UpdateRangeResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.UpdateRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* UpdateRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.UpdateRangeResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* UpdateRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.UpdateRangeResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UpdateRangeResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.UpdateRangeResponse.header)
}

// -------------------------------------------------------------------

// ReplaceRangeRequest

// .schpb.RequestHeader header = 1;
inline bool ReplaceRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReplaceRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& ReplaceRangeRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.ReplaceRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* ReplaceRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.ReplaceRangeRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* ReplaceRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.ReplaceRangeRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReplaceRangeRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.ReplaceRangeRequest.header)
}

// uint64 old_range_id = 2;
inline void ReplaceRangeRequest::clear_old_range_id() {
  old_range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ReplaceRangeRequest::old_range_id() const {
  // @@protoc_insertion_point(field_get:schpb.ReplaceRangeRequest.old_range_id)
  return old_range_id_;
}
inline void ReplaceRangeRequest::set_old_range_id(::google::protobuf::uint64 value) {
  
  old_range_id_ = value;
  // @@protoc_insertion_point(field_set:schpb.ReplaceRangeRequest.old_range_id)
}

// .metapb.Range new_range = 3;
inline bool ReplaceRangeRequest::has_new_range() const {
  return this != internal_default_instance() && new_range_ != NULL;
}
inline void ReplaceRangeRequest::clear_new_range() {
  if (GetArenaNoVirtual() == NULL && new_range_ != NULL) delete new_range_;
  new_range_ = NULL;
}
inline const ::metapb::Range& ReplaceRangeRequest::new_range() const {
  const ::metapb::Range* p = new_range_;
  // @@protoc_insertion_point(field_get:schpb.ReplaceRangeRequest.new_range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* ReplaceRangeRequest::mutable_new_range() {
  
  if (new_range_ == NULL) {
    new_range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:schpb.ReplaceRangeRequest.new_range)
  return new_range_;
}
inline ::metapb::Range* ReplaceRangeRequest::release_new_range() {
  // @@protoc_insertion_point(field_release:schpb.ReplaceRangeRequest.new_range)
  
  ::metapb::Range* temp = new_range_;
  new_range_ = NULL;
  return temp;
}
inline void ReplaceRangeRequest::set_allocated_new_range(::metapb::Range* new_range) {
  delete new_range_;
  new_range_ = new_range;
  if (new_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.ReplaceRangeRequest.new_range)
}

// -------------------------------------------------------------------

// ReplaceRangeResponse

// .schpb.ResponseHeader header = 1;
inline bool ReplaceRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReplaceRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& ReplaceRangeResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.ReplaceRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* ReplaceRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.ReplaceRangeResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* ReplaceRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.ReplaceRangeResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReplaceRangeResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.ReplaceRangeResponse.header)
}

// -------------------------------------------------------------------

// SetNodeLogLevelRequest

// .schpb.RequestHeader header = 1;
inline bool SetNodeLogLevelRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SetNodeLogLevelRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& SetNodeLogLevelRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.SetNodeLogLevelRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* SetNodeLogLevelRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.SetNodeLogLevelRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* SetNodeLogLevelRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.SetNodeLogLevelRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SetNodeLogLevelRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.SetNodeLogLevelRequest.header)
}

// string level = 2;
inline void SetNodeLogLevelRequest::clear_level() {
  level_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetNodeLogLevelRequest::level() const {
  // @@protoc_insertion_point(field_get:schpb.SetNodeLogLevelRequest.level)
  return level_.GetNoArena();
}
inline void SetNodeLogLevelRequest::set_level(const ::std::string& value) {
  
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schpb.SetNodeLogLevelRequest.level)
}
#if LANG_CXX11
inline void SetNodeLogLevelRequest::set_level(::std::string&& value) {
  
  level_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schpb.SetNodeLogLevelRequest.level)
}
#endif
inline void SetNodeLogLevelRequest::set_level(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schpb.SetNodeLogLevelRequest.level)
}
inline void SetNodeLogLevelRequest::set_level(const char* value, size_t size) {
  
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schpb.SetNodeLogLevelRequest.level)
}
inline ::std::string* SetNodeLogLevelRequest::mutable_level() {
  
  // @@protoc_insertion_point(field_mutable:schpb.SetNodeLogLevelRequest.level)
  return level_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetNodeLogLevelRequest::release_level() {
  // @@protoc_insertion_point(field_release:schpb.SetNodeLogLevelRequest.level)
  
  return level_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetNodeLogLevelRequest::set_allocated_level(::std::string* level) {
  if (level != NULL) {
    
  } else {
    
  }
  level_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), level);
  // @@protoc_insertion_point(field_set_allocated:schpb.SetNodeLogLevelRequest.level)
}

// -------------------------------------------------------------------

// SetNodeLogLevelResponse

// .schpb.ResponseHeader header = 1;
inline bool SetNodeLogLevelResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SetNodeLogLevelResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& SetNodeLogLevelResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.SetNodeLogLevelResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* SetNodeLogLevelResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.SetNodeLogLevelResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* SetNodeLogLevelResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.SetNodeLogLevelResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SetNodeLogLevelResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.SetNodeLogLevelResponse.header)
}

// -------------------------------------------------------------------

// OfflineRangeRequest

// .schpb.RequestHeader header = 1;
inline bool OfflineRangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void OfflineRangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::RequestHeader& OfflineRangeRequest::header() const {
  const ::schpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.OfflineRangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::RequestHeader*>(
      &::schpb::_RequestHeader_default_instance_);
}
inline ::schpb::RequestHeader* OfflineRangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.OfflineRangeRequest.header)
  return header_;
}
inline ::schpb::RequestHeader* OfflineRangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:schpb.OfflineRangeRequest.header)
  
  ::schpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void OfflineRangeRequest::set_allocated_header(::schpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.OfflineRangeRequest.header)
}

// uint64 rangeId = 2;
inline void OfflineRangeRequest::clear_rangeid() {
  rangeid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OfflineRangeRequest::rangeid() const {
  // @@protoc_insertion_point(field_get:schpb.OfflineRangeRequest.rangeId)
  return rangeid_;
}
inline void OfflineRangeRequest::set_rangeid(::google::protobuf::uint64 value) {
  
  rangeid_ = value;
  // @@protoc_insertion_point(field_set:schpb.OfflineRangeRequest.rangeId)
}

// -------------------------------------------------------------------

// OfflineRangeResponse

// .schpb.ResponseHeader header = 1;
inline bool OfflineRangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void OfflineRangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::schpb::ResponseHeader& OfflineRangeResponse::header() const {
  const ::schpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schpb.OfflineRangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::schpb::ResponseHeader*>(
      &::schpb::_ResponseHeader_default_instance_);
}
inline ::schpb::ResponseHeader* OfflineRangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::schpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:schpb.OfflineRangeResponse.header)
  return header_;
}
inline ::schpb::ResponseHeader* OfflineRangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:schpb.OfflineRangeResponse.header)
  
  ::schpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void OfflineRangeResponse::set_allocated_header(::schpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:schpb.OfflineRangeResponse.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace schpb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_schpb_2eproto__INCLUDED
