// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: errorpb.proto

#ifndef PROTOBUF_errorpb_2eproto__INCLUDED
#define PROTOBUF_errorpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
// @@protoc_insertion_point(includes)
namespace errorpb {
class EntryTooLarge;
class EntryTooLargeDefaultTypeInternal;
extern EntryTooLargeDefaultTypeInternal _EntryTooLarge_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class KeyNotInRange;
class KeyNotInRangeDefaultTypeInternal;
extern KeyNotInRangeDefaultTypeInternal _KeyNotInRange_default_instance_;
class NotLeader;
class NotLeaderDefaultTypeInternal;
extern NotLeaderDefaultTypeInternal _NotLeader_default_instance_;
class RaftFail;
class RaftFailDefaultTypeInternal;
extern RaftFailDefaultTypeInternal _RaftFail_default_instance_;
class RangeNotFound;
class RangeNotFoundDefaultTypeInternal;
extern RangeNotFoundDefaultTypeInternal _RangeNotFound_default_instance_;
class ServerIsBusy;
class ServerIsBusyDefaultTypeInternal;
extern ServerIsBusyDefaultTypeInternal _ServerIsBusy_default_instance_;
class StaleCommand;
class StaleCommandDefaultTypeInternal;
extern StaleCommandDefaultTypeInternal _StaleCommand_default_instance_;
class StaleEpoch;
class StaleEpochDefaultTypeInternal;
extern StaleEpochDefaultTypeInternal _StaleEpoch_default_instance_;
class StaleRange;
class StaleRangeDefaultTypeInternal;
extern StaleRangeDefaultTypeInternal _StaleRange_default_instance_;
class StaleReadIndex;
class StaleReadIndexDefaultTypeInternal;
extern StaleReadIndexDefaultTypeInternal _StaleReadIndex_default_instance_;
class Timeout;
class TimeoutDefaultTypeInternal;
extern TimeoutDefaultTypeInternal _Timeout_default_instance_;
}  // namespace errorpb

namespace errorpb {

namespace protobuf_errorpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_errorpb_2eproto

// ===================================================================

class NotLeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.NotLeader) */ {
 public:
  NotLeader();
  virtual ~NotLeader();

  NotLeader(const NotLeader& from);

  inline NotLeader& operator=(const NotLeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotLeader(NotLeader&& from) noexcept
    : NotLeader() {
    *this = ::std::move(from);
  }

  inline NotLeader& operator=(NotLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NotLeader& default_instance();

  static inline const NotLeader* internal_default_instance() {
    return reinterpret_cast<const NotLeader*>(
               &_NotLeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NotLeader* other);
  friend void swap(NotLeader& a, NotLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotLeader* New() const PROTOBUF_FINAL { return New(NULL); }

  NotLeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NotLeader& from);
  void MergeFrom(const NotLeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NotLeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.RangeEpoch epoch = 2;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 2;
  const ::metapb::RangeEpoch& epoch() const;
  ::metapb::RangeEpoch* mutable_epoch();
  ::metapb::RangeEpoch* release_epoch();
  void set_allocated_epoch(::metapb::RangeEpoch* epoch);

  // .metapb.Peer leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* mutable_leader();
  ::metapb::Peer* release_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // uint64 range_id = 1;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.NotLeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::RangeEpoch* epoch_;
  ::metapb::Peer* leader_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeNotFound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.RangeNotFound) */ {
 public:
  RangeNotFound();
  virtual ~RangeNotFound();

  RangeNotFound(const RangeNotFound& from);

  inline RangeNotFound& operator=(const RangeNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeNotFound(RangeNotFound&& from) noexcept
    : RangeNotFound() {
    *this = ::std::move(from);
  }

  inline RangeNotFound& operator=(RangeNotFound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeNotFound& default_instance();

  static inline const RangeNotFound* internal_default_instance() {
    return reinterpret_cast<const RangeNotFound*>(
               &_RangeNotFound_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RangeNotFound* other);
  friend void swap(RangeNotFound& a, RangeNotFound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeNotFound* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeNotFound* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeNotFound& from);
  void MergeFrom(const RangeNotFound& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeNotFound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 range_id = 1;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.RangeNotFound)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyNotInRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.KeyNotInRange) */ {
 public:
  KeyNotInRange();
  virtual ~KeyNotInRange();

  KeyNotInRange(const KeyNotInRange& from);

  inline KeyNotInRange& operator=(const KeyNotInRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyNotInRange(KeyNotInRange&& from) noexcept
    : KeyNotInRange() {
    *this = ::std::move(from);
  }

  inline KeyNotInRange& operator=(KeyNotInRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyNotInRange& default_instance();

  static inline const KeyNotInRange* internal_default_instance() {
    return reinterpret_cast<const KeyNotInRange*>(
               &_KeyNotInRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(KeyNotInRange* other);
  friend void swap(KeyNotInRange& a, KeyNotInRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyNotInRange* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyNotInRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyNotInRange& from);
  void MergeFrom(const KeyNotInRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyNotInRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes start_key = 3;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 3;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // bytes end_key = 4;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 4;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  #if LANG_CXX11
  void set_end_key(::std::string&& value);
  #endif
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.KeyNotInRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaleCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleCommand) */ {
 public:
  StaleCommand();
  virtual ~StaleCommand();

  StaleCommand(const StaleCommand& from);

  inline StaleCommand& operator=(const StaleCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaleCommand(StaleCommand&& from) noexcept
    : StaleCommand() {
    *this = ::std::move(from);
  }

  inline StaleCommand& operator=(StaleCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StaleCommand& default_instance();

  static inline const StaleCommand* internal_default_instance() {
    return reinterpret_cast<const StaleCommand*>(
               &_StaleCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(StaleCommand* other);
  friend void swap(StaleCommand& a, StaleCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaleCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  StaleCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaleCommand& from);
  void MergeFrom(const StaleCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaleCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:errorpb.StaleCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Timeout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.Timeout) */ {
 public:
  Timeout();
  virtual ~Timeout();

  Timeout(const Timeout& from);

  inline Timeout& operator=(const Timeout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timeout(Timeout&& from) noexcept
    : Timeout() {
    *this = ::std::move(from);
  }

  inline Timeout& operator=(Timeout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timeout& default_instance();

  static inline const Timeout* internal_default_instance() {
    return reinterpret_cast<const Timeout*>(
               &_Timeout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Timeout* other);
  friend void swap(Timeout& a, Timeout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timeout* New() const PROTOBUF_FINAL { return New(NULL); }

  Timeout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Timeout& from);
  void MergeFrom(const Timeout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Timeout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:errorpb.Timeout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RaftFail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.RaftFail) */ {
 public:
  RaftFail();
  virtual ~RaftFail();

  RaftFail(const RaftFail& from);

  inline RaftFail& operator=(const RaftFail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RaftFail(RaftFail&& from) noexcept
    : RaftFail() {
    *this = ::std::move(from);
  }

  inline RaftFail& operator=(RaftFail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftFail& default_instance();

  static inline const RaftFail* internal_default_instance() {
    return reinterpret_cast<const RaftFail*>(
               &_RaftFail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RaftFail* other);
  friend void swap(RaftFail& a, RaftFail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RaftFail* New() const PROTOBUF_FINAL { return New(NULL); }

  RaftFail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RaftFail& from);
  void MergeFrom(const RaftFail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RaftFail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:errorpb.RaftFail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaleEpoch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleEpoch) */ {
 public:
  StaleEpoch();
  virtual ~StaleEpoch();

  StaleEpoch(const StaleEpoch& from);

  inline StaleEpoch& operator=(const StaleEpoch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaleEpoch(StaleEpoch&& from) noexcept
    : StaleEpoch() {
    *this = ::std::move(from);
  }

  inline StaleEpoch& operator=(StaleEpoch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StaleEpoch& default_instance();

  static inline const StaleEpoch* internal_default_instance() {
    return reinterpret_cast<const StaleEpoch*>(
               &_StaleEpoch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(StaleEpoch* other);
  friend void swap(StaleEpoch& a, StaleEpoch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaleEpoch* New() const PROTOBUF_FINAL { return New(NULL); }

  StaleEpoch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaleEpoch& from);
  void MergeFrom(const StaleEpoch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaleEpoch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Range old_range = 1;
  bool has_old_range() const;
  void clear_old_range();
  static const int kOldRangeFieldNumber = 1;
  const ::metapb::Range& old_range() const;
  ::metapb::Range* mutable_old_range();
  ::metapb::Range* release_old_range();
  void set_allocated_old_range(::metapb::Range* old_range);

  // .metapb.Range new_range = 2;
  bool has_new_range() const;
  void clear_new_range();
  static const int kNewRangeFieldNumber = 2;
  const ::metapb::Range& new_range() const;
  ::metapb::Range* mutable_new_range();
  ::metapb::Range* release_new_range();
  void set_allocated_new_range(::metapb::Range* new_range);

  // @@protoc_insertion_point(class_scope:errorpb.StaleEpoch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Range* old_range_;
  ::metapb::Range* new_range_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaleRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleRange) */ {
 public:
  StaleRange();
  virtual ~StaleRange();

  StaleRange(const StaleRange& from);

  inline StaleRange& operator=(const StaleRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaleRange(StaleRange&& from) noexcept
    : StaleRange() {
    *this = ::std::move(from);
  }

  inline StaleRange& operator=(StaleRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StaleRange& default_instance();

  static inline const StaleRange* internal_default_instance() {
    return reinterpret_cast<const StaleRange*>(
               &_StaleRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(StaleRange* other);
  friend void swap(StaleRange& a, StaleRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaleRange* New() const PROTOBUF_FINAL { return New(NULL); }

  StaleRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaleRange& from);
  void MergeFrom(const StaleRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaleRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Range range = 1;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // @@protoc_insertion_point(class_scope:errorpb.StaleRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Range* range_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaleReadIndex : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleReadIndex) */ {
 public:
  StaleReadIndex();
  virtual ~StaleReadIndex();

  StaleReadIndex(const StaleReadIndex& from);

  inline StaleReadIndex& operator=(const StaleReadIndex& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaleReadIndex(StaleReadIndex&& from) noexcept
    : StaleReadIndex() {
    *this = ::std::move(from);
  }

  inline StaleReadIndex& operator=(StaleReadIndex&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StaleReadIndex& default_instance();

  static inline const StaleReadIndex* internal_default_instance() {
    return reinterpret_cast<const StaleReadIndex*>(
               &_StaleReadIndex_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StaleReadIndex* other);
  friend void swap(StaleReadIndex& a, StaleReadIndex& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaleReadIndex* New() const PROTOBUF_FINAL { return New(NULL); }

  StaleReadIndex* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaleReadIndex& from);
  void MergeFrom(const StaleReadIndex& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaleReadIndex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 read_index = 1;
  void clear_read_index();
  static const int kReadIndexFieldNumber = 1;
  ::google::protobuf::uint64 read_index() const;
  void set_read_index(::google::protobuf::uint64 value);

  // uint64 replica_index = 2;
  void clear_replica_index();
  static const int kReplicaIndexFieldNumber = 2;
  ::google::protobuf::uint64 replica_index() const;
  void set_replica_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.StaleReadIndex)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 read_index_;
  ::google::protobuf::uint64 replica_index_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerIsBusy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.ServerIsBusy) */ {
 public:
  ServerIsBusy();
  virtual ~ServerIsBusy();

  ServerIsBusy(const ServerIsBusy& from);

  inline ServerIsBusy& operator=(const ServerIsBusy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerIsBusy(ServerIsBusy&& from) noexcept
    : ServerIsBusy() {
    *this = ::std::move(from);
  }

  inline ServerIsBusy& operator=(ServerIsBusy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerIsBusy& default_instance();

  static inline const ServerIsBusy* internal_default_instance() {
    return reinterpret_cast<const ServerIsBusy*>(
               &_ServerIsBusy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ServerIsBusy* other);
  friend void swap(ServerIsBusy& a, ServerIsBusy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerIsBusy* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerIsBusy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerIsBusy& from);
  void MergeFrom(const ServerIsBusy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerIsBusy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:errorpb.ServerIsBusy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntryTooLarge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.EntryTooLarge) */ {
 public:
  EntryTooLarge();
  virtual ~EntryTooLarge();

  EntryTooLarge(const EntryTooLarge& from);

  inline EntryTooLarge& operator=(const EntryTooLarge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntryTooLarge(EntryTooLarge&& from) noexcept
    : EntryTooLarge() {
    *this = ::std::move(from);
  }

  inline EntryTooLarge& operator=(EntryTooLarge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntryTooLarge& default_instance();

  static inline const EntryTooLarge* internal_default_instance() {
    return reinterpret_cast<const EntryTooLarge*>(
               &_EntryTooLarge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(EntryTooLarge* other);
  friend void swap(EntryTooLarge& a, EntryTooLarge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntryTooLarge* New() const PROTOBUF_FINAL { return New(NULL); }

  EntryTooLarge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntryTooLarge& from);
  void MergeFrom(const EntryTooLarge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntryTooLarge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 range_id = 1;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // uint64 entry_size = 2;
  void clear_entry_size();
  static const int kEntrySizeFieldNumber = 2;
  ::google::protobuf::uint64 entry_size() const;
  void set_entry_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.EntryTooLarge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 range_id_;
  ::google::protobuf::uint64 entry_size_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .errorpb.NotLeader not_leader = 2;
  bool has_not_leader() const;
  void clear_not_leader();
  static const int kNotLeaderFieldNumber = 2;
  const ::errorpb::NotLeader& not_leader() const;
  ::errorpb::NotLeader* mutable_not_leader();
  ::errorpb::NotLeader* release_not_leader();
  void set_allocated_not_leader(::errorpb::NotLeader* not_leader);

  // .errorpb.StaleCommand stale_command = 3;
  bool has_stale_command() const;
  void clear_stale_command();
  static const int kStaleCommandFieldNumber = 3;
  const ::errorpb::StaleCommand& stale_command() const;
  ::errorpb::StaleCommand* mutable_stale_command();
  ::errorpb::StaleCommand* release_stale_command();
  void set_allocated_stale_command(::errorpb::StaleCommand* stale_command);

  // .errorpb.RangeNotFound range_not_found = 4;
  bool has_range_not_found() const;
  void clear_range_not_found();
  static const int kRangeNotFoundFieldNumber = 4;
  const ::errorpb::RangeNotFound& range_not_found() const;
  ::errorpb::RangeNotFound* mutable_range_not_found();
  ::errorpb::RangeNotFound* release_range_not_found();
  void set_allocated_range_not_found(::errorpb::RangeNotFound* range_not_found);

  // .errorpb.KeyNotInRange key_not_in_range = 5;
  bool has_key_not_in_range() const;
  void clear_key_not_in_range();
  static const int kKeyNotInRangeFieldNumber = 5;
  const ::errorpb::KeyNotInRange& key_not_in_range() const;
  ::errorpb::KeyNotInRange* mutable_key_not_in_range();
  ::errorpb::KeyNotInRange* release_key_not_in_range();
  void set_allocated_key_not_in_range(::errorpb::KeyNotInRange* key_not_in_range);

  // .errorpb.StaleEpoch stale_epoch = 6;
  bool has_stale_epoch() const;
  void clear_stale_epoch();
  static const int kStaleEpochFieldNumber = 6;
  const ::errorpb::StaleEpoch& stale_epoch() const;
  ::errorpb::StaleEpoch* mutable_stale_epoch();
  ::errorpb::StaleEpoch* release_stale_epoch();
  void set_allocated_stale_epoch(::errorpb::StaleEpoch* stale_epoch);

  // .errorpb.ServerIsBusy server_is_busy = 7;
  bool has_server_is_busy() const;
  void clear_server_is_busy();
  static const int kServerIsBusyFieldNumber = 7;
  const ::errorpb::ServerIsBusy& server_is_busy() const;
  ::errorpb::ServerIsBusy* mutable_server_is_busy();
  ::errorpb::ServerIsBusy* release_server_is_busy();
  void set_allocated_server_is_busy(::errorpb::ServerIsBusy* server_is_busy);

  // .errorpb.EntryTooLarge entry_too_large = 8;
  bool has_entry_too_large() const;
  void clear_entry_too_large();
  static const int kEntryTooLargeFieldNumber = 8;
  const ::errorpb::EntryTooLarge& entry_too_large() const;
  ::errorpb::EntryTooLarge* mutable_entry_too_large();
  ::errorpb::EntryTooLarge* release_entry_too_large();
  void set_allocated_entry_too_large(::errorpb::EntryTooLarge* entry_too_large);

  // .errorpb.Timeout timeout = 9;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  const ::errorpb::Timeout& timeout() const;
  ::errorpb::Timeout* mutable_timeout();
  ::errorpb::Timeout* release_timeout();
  void set_allocated_timeout(::errorpb::Timeout* timeout);

  // .errorpb.RaftFail raft_fail = 10;
  bool has_raft_fail() const;
  void clear_raft_fail();
  static const int kRaftFailFieldNumber = 10;
  const ::errorpb::RaftFail& raft_fail() const;
  ::errorpb::RaftFail* mutable_raft_fail();
  ::errorpb::RaftFail* release_raft_fail();
  void set_allocated_raft_fail(::errorpb::RaftFail* raft_fail);

  // .errorpb.StaleRange stale_range = 11;
  bool has_stale_range() const;
  void clear_stale_range();
  static const int kStaleRangeFieldNumber = 11;
  const ::errorpb::StaleRange& stale_range() const;
  ::errorpb::StaleRange* mutable_stale_range();
  ::errorpb::StaleRange* release_stale_range();
  void set_allocated_stale_range(::errorpb::StaleRange* stale_range);

  // .errorpb.StaleReadIndex stale_read_index = 12;
  bool has_stale_read_index() const;
  void clear_stale_read_index();
  static const int kStaleReadIndexFieldNumber = 12;
  const ::errorpb::StaleReadIndex& stale_read_index() const;
  ::errorpb::StaleReadIndex* mutable_stale_read_index();
  ::errorpb::StaleReadIndex* release_stale_read_index();
  void set_allocated_stale_read_index(::errorpb::StaleReadIndex* stale_read_index);

  // @@protoc_insertion_point(class_scope:errorpb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::errorpb::NotLeader* not_leader_;
  ::errorpb::StaleCommand* stale_command_;
  ::errorpb::RangeNotFound* range_not_found_;
  ::errorpb::KeyNotInRange* key_not_in_range_;
  ::errorpb::StaleEpoch* stale_epoch_;
  ::errorpb::ServerIsBusy* server_is_busy_;
  ::errorpb::EntryTooLarge* entry_too_large_;
  ::errorpb::Timeout* timeout_;
  ::errorpb::RaftFail* raft_fail_;
  ::errorpb::StaleRange* stale_range_;
  ::errorpb::StaleReadIndex* stale_read_index_;
  mutable int _cached_size_;
  friend struct protobuf_errorpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NotLeader

// uint64 range_id = 1;
inline void NotLeader::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NotLeader::range_id() const {
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.range_id)
  return range_id_;
}
inline void NotLeader::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.NotLeader.range_id)
}

// .metapb.RangeEpoch epoch = 2;
inline bool NotLeader::has_epoch() const {
  return this != internal_default_instance() && epoch_ != NULL;
}
inline void NotLeader::clear_epoch() {
  if (GetArenaNoVirtual() == NULL && epoch_ != NULL) delete epoch_;
  epoch_ = NULL;
}
inline const ::metapb::RangeEpoch& NotLeader::epoch() const {
  const ::metapb::RangeEpoch* p = epoch_;
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::RangeEpoch*>(
      &::metapb::_RangeEpoch_default_instance_);
}
inline ::metapb::RangeEpoch* NotLeader::mutable_epoch() {
  
  if (epoch_ == NULL) {
    epoch_ = new ::metapb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.NotLeader.epoch)
  return epoch_;
}
inline ::metapb::RangeEpoch* NotLeader::release_epoch() {
  // @@protoc_insertion_point(field_release:errorpb.NotLeader.epoch)
  
  ::metapb::RangeEpoch* temp = epoch_;
  epoch_ = NULL;
  return temp;
}
inline void NotLeader::set_allocated_epoch(::metapb::RangeEpoch* epoch) {
  delete epoch_;
  epoch_ = epoch;
  if (epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.NotLeader.epoch)
}

// .metapb.Peer leader = 3;
inline bool NotLeader::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void NotLeader::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) delete leader_;
  leader_ = NULL;
}
inline const ::metapb::Peer& NotLeader::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* NotLeader::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.NotLeader.leader)
  return leader_;
}
inline ::metapb::Peer* NotLeader::release_leader() {
  // @@protoc_insertion_point(field_release:errorpb.NotLeader.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline void NotLeader::set_allocated_leader(::metapb::Peer* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.NotLeader.leader)
}

// -------------------------------------------------------------------

// RangeNotFound

// uint64 range_id = 1;
inline void RangeNotFound::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeNotFound::range_id() const {
  // @@protoc_insertion_point(field_get:errorpb.RangeNotFound.range_id)
  return range_id_;
}
inline void RangeNotFound::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.RangeNotFound.range_id)
}

// -------------------------------------------------------------------

// KeyNotInRange

// bytes key = 1;
inline void KeyNotInRange::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyNotInRange::key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRange.key)
  return key_.GetNoArena();
}
inline void KeyNotInRange::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRange.key)
}
#if LANG_CXX11
inline void KeyNotInRange::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:errorpb.KeyNotInRange.key)
}
#endif
inline void KeyNotInRange::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRange.key)
}
inline void KeyNotInRange::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRange.key)
}
inline ::std::string* KeyNotInRange::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRange.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyNotInRange::release_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRange.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRange::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRange.key)
}

// uint64 range_id = 2;
inline void KeyNotInRange::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KeyNotInRange::range_id() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRange.range_id)
  return range_id_;
}
inline void KeyNotInRange::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRange.range_id)
}

// bytes start_key = 3;
inline void KeyNotInRange::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyNotInRange::start_key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRange.start_key)
  return start_key_.GetNoArena();
}
inline void KeyNotInRange::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRange.start_key)
}
#if LANG_CXX11
inline void KeyNotInRange::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:errorpb.KeyNotInRange.start_key)
}
#endif
inline void KeyNotInRange::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRange.start_key)
}
inline void KeyNotInRange::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRange.start_key)
}
inline ::std::string* KeyNotInRange::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRange.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyNotInRange::release_start_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRange.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRange::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRange.start_key)
}

// bytes end_key = 4;
inline void KeyNotInRange::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyNotInRange::end_key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRange.end_key)
  return end_key_.GetNoArena();
}
inline void KeyNotInRange::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRange.end_key)
}
#if LANG_CXX11
inline void KeyNotInRange::set_end_key(::std::string&& value) {
  
  end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:errorpb.KeyNotInRange.end_key)
}
#endif
inline void KeyNotInRange::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRange.end_key)
}
inline void KeyNotInRange::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRange.end_key)
}
inline ::std::string* KeyNotInRange::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRange.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyNotInRange::release_end_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRange.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRange::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRange.end_key)
}

// -------------------------------------------------------------------

// StaleCommand

// -------------------------------------------------------------------

// Timeout

// -------------------------------------------------------------------

// RaftFail

// -------------------------------------------------------------------

// StaleEpoch

// .metapb.Range old_range = 1;
inline bool StaleEpoch::has_old_range() const {
  return this != internal_default_instance() && old_range_ != NULL;
}
inline void StaleEpoch::clear_old_range() {
  if (GetArenaNoVirtual() == NULL && old_range_ != NULL) delete old_range_;
  old_range_ = NULL;
}
inline const ::metapb::Range& StaleEpoch::old_range() const {
  const ::metapb::Range* p = old_range_;
  // @@protoc_insertion_point(field_get:errorpb.StaleEpoch.old_range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* StaleEpoch::mutable_old_range() {
  
  if (old_range_ == NULL) {
    old_range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.StaleEpoch.old_range)
  return old_range_;
}
inline ::metapb::Range* StaleEpoch::release_old_range() {
  // @@protoc_insertion_point(field_release:errorpb.StaleEpoch.old_range)
  
  ::metapb::Range* temp = old_range_;
  old_range_ = NULL;
  return temp;
}
inline void StaleEpoch::set_allocated_old_range(::metapb::Range* old_range) {
  delete old_range_;
  old_range_ = old_range;
  if (old_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.StaleEpoch.old_range)
}

// .metapb.Range new_range = 2;
inline bool StaleEpoch::has_new_range() const {
  return this != internal_default_instance() && new_range_ != NULL;
}
inline void StaleEpoch::clear_new_range() {
  if (GetArenaNoVirtual() == NULL && new_range_ != NULL) delete new_range_;
  new_range_ = NULL;
}
inline const ::metapb::Range& StaleEpoch::new_range() const {
  const ::metapb::Range* p = new_range_;
  // @@protoc_insertion_point(field_get:errorpb.StaleEpoch.new_range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* StaleEpoch::mutable_new_range() {
  
  if (new_range_ == NULL) {
    new_range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.StaleEpoch.new_range)
  return new_range_;
}
inline ::metapb::Range* StaleEpoch::release_new_range() {
  // @@protoc_insertion_point(field_release:errorpb.StaleEpoch.new_range)
  
  ::metapb::Range* temp = new_range_;
  new_range_ = NULL;
  return temp;
}
inline void StaleEpoch::set_allocated_new_range(::metapb::Range* new_range) {
  delete new_range_;
  new_range_ = new_range;
  if (new_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.StaleEpoch.new_range)
}

// -------------------------------------------------------------------

// StaleRange

// .metapb.Range range = 1;
inline bool StaleRange::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void StaleRange::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& StaleRange::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:errorpb.StaleRange.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* StaleRange::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.StaleRange.range)
  return range_;
}
inline ::metapb::Range* StaleRange::release_range() {
  // @@protoc_insertion_point(field_release:errorpb.StaleRange.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void StaleRange::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.StaleRange.range)
}

// -------------------------------------------------------------------

// StaleReadIndex

// uint64 read_index = 1;
inline void StaleReadIndex::clear_read_index() {
  read_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StaleReadIndex::read_index() const {
  // @@protoc_insertion_point(field_get:errorpb.StaleReadIndex.read_index)
  return read_index_;
}
inline void StaleReadIndex::set_read_index(::google::protobuf::uint64 value) {
  
  read_index_ = value;
  // @@protoc_insertion_point(field_set:errorpb.StaleReadIndex.read_index)
}

// uint64 replica_index = 2;
inline void StaleReadIndex::clear_replica_index() {
  replica_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StaleReadIndex::replica_index() const {
  // @@protoc_insertion_point(field_get:errorpb.StaleReadIndex.replica_index)
  return replica_index_;
}
inline void StaleReadIndex::set_replica_index(::google::protobuf::uint64 value) {
  
  replica_index_ = value;
  // @@protoc_insertion_point(field_set:errorpb.StaleReadIndex.replica_index)
}

// -------------------------------------------------------------------

// ServerIsBusy

// string reason = 1;
inline void ServerIsBusy::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerIsBusy::reason() const {
  // @@protoc_insertion_point(field_get:errorpb.ServerIsBusy.reason)
  return reason_.GetNoArena();
}
inline void ServerIsBusy::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.ServerIsBusy.reason)
}
#if LANG_CXX11
inline void ServerIsBusy::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:errorpb.ServerIsBusy.reason)
}
#endif
inline void ServerIsBusy::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.ServerIsBusy.reason)
}
inline void ServerIsBusy::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.ServerIsBusy.reason)
}
inline ::std::string* ServerIsBusy::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.ServerIsBusy.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerIsBusy::release_reason() {
  // @@protoc_insertion_point(field_release:errorpb.ServerIsBusy.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerIsBusy::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:errorpb.ServerIsBusy.reason)
}

// -------------------------------------------------------------------

// EntryTooLarge

// uint64 range_id = 1;
inline void EntryTooLarge::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EntryTooLarge::range_id() const {
  // @@protoc_insertion_point(field_get:errorpb.EntryTooLarge.range_id)
  return range_id_;
}
inline void EntryTooLarge::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.EntryTooLarge.range_id)
}

// uint64 entry_size = 2;
inline void EntryTooLarge::clear_entry_size() {
  entry_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EntryTooLarge::entry_size() const {
  // @@protoc_insertion_point(field_get:errorpb.EntryTooLarge.entry_size)
  return entry_size_;
}
inline void EntryTooLarge::set_entry_size(::google::protobuf::uint64 value) {
  
  entry_size_ = value;
  // @@protoc_insertion_point(field_set:errorpb.EntryTooLarge.entry_size)
}

// -------------------------------------------------------------------

// Error

// string message = 1;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:errorpb.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:errorpb.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.message)
}

// .errorpb.NotLeader not_leader = 2;
inline bool Error::has_not_leader() const {
  return this != internal_default_instance() && not_leader_ != NULL;
}
inline void Error::clear_not_leader() {
  if (GetArenaNoVirtual() == NULL && not_leader_ != NULL) delete not_leader_;
  not_leader_ = NULL;
}
inline const ::errorpb::NotLeader& Error::not_leader() const {
  const ::errorpb::NotLeader* p = not_leader_;
  // @@protoc_insertion_point(field_get:errorpb.Error.not_leader)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::NotLeader*>(
      &::errorpb::_NotLeader_default_instance_);
}
inline ::errorpb::NotLeader* Error::mutable_not_leader() {
  
  if (not_leader_ == NULL) {
    not_leader_ = new ::errorpb::NotLeader;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.not_leader)
  return not_leader_;
}
inline ::errorpb::NotLeader* Error::release_not_leader() {
  // @@protoc_insertion_point(field_release:errorpb.Error.not_leader)
  
  ::errorpb::NotLeader* temp = not_leader_;
  not_leader_ = NULL;
  return temp;
}
inline void Error::set_allocated_not_leader(::errorpb::NotLeader* not_leader) {
  delete not_leader_;
  not_leader_ = not_leader;
  if (not_leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.not_leader)
}

// .errorpb.StaleCommand stale_command = 3;
inline bool Error::has_stale_command() const {
  return this != internal_default_instance() && stale_command_ != NULL;
}
inline void Error::clear_stale_command() {
  if (GetArenaNoVirtual() == NULL && stale_command_ != NULL) delete stale_command_;
  stale_command_ = NULL;
}
inline const ::errorpb::StaleCommand& Error::stale_command() const {
  const ::errorpb::StaleCommand* p = stale_command_;
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_command)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::StaleCommand*>(
      &::errorpb::_StaleCommand_default_instance_);
}
inline ::errorpb::StaleCommand* Error::mutable_stale_command() {
  
  if (stale_command_ == NULL) {
    stale_command_ = new ::errorpb::StaleCommand;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_command)
  return stale_command_;
}
inline ::errorpb::StaleCommand* Error::release_stale_command() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_command)
  
  ::errorpb::StaleCommand* temp = stale_command_;
  stale_command_ = NULL;
  return temp;
}
inline void Error::set_allocated_stale_command(::errorpb::StaleCommand* stale_command) {
  delete stale_command_;
  stale_command_ = stale_command;
  if (stale_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_command)
}

// .errorpb.RangeNotFound range_not_found = 4;
inline bool Error::has_range_not_found() const {
  return this != internal_default_instance() && range_not_found_ != NULL;
}
inline void Error::clear_range_not_found() {
  if (GetArenaNoVirtual() == NULL && range_not_found_ != NULL) delete range_not_found_;
  range_not_found_ = NULL;
}
inline const ::errorpb::RangeNotFound& Error::range_not_found() const {
  const ::errorpb::RangeNotFound* p = range_not_found_;
  // @@protoc_insertion_point(field_get:errorpb.Error.range_not_found)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::RangeNotFound*>(
      &::errorpb::_RangeNotFound_default_instance_);
}
inline ::errorpb::RangeNotFound* Error::mutable_range_not_found() {
  
  if (range_not_found_ == NULL) {
    range_not_found_ = new ::errorpb::RangeNotFound;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.range_not_found)
  return range_not_found_;
}
inline ::errorpb::RangeNotFound* Error::release_range_not_found() {
  // @@protoc_insertion_point(field_release:errorpb.Error.range_not_found)
  
  ::errorpb::RangeNotFound* temp = range_not_found_;
  range_not_found_ = NULL;
  return temp;
}
inline void Error::set_allocated_range_not_found(::errorpb::RangeNotFound* range_not_found) {
  delete range_not_found_;
  range_not_found_ = range_not_found;
  if (range_not_found) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.range_not_found)
}

// .errorpb.KeyNotInRange key_not_in_range = 5;
inline bool Error::has_key_not_in_range() const {
  return this != internal_default_instance() && key_not_in_range_ != NULL;
}
inline void Error::clear_key_not_in_range() {
  if (GetArenaNoVirtual() == NULL && key_not_in_range_ != NULL) delete key_not_in_range_;
  key_not_in_range_ = NULL;
}
inline const ::errorpb::KeyNotInRange& Error::key_not_in_range() const {
  const ::errorpb::KeyNotInRange* p = key_not_in_range_;
  // @@protoc_insertion_point(field_get:errorpb.Error.key_not_in_range)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::KeyNotInRange*>(
      &::errorpb::_KeyNotInRange_default_instance_);
}
inline ::errorpb::KeyNotInRange* Error::mutable_key_not_in_range() {
  
  if (key_not_in_range_ == NULL) {
    key_not_in_range_ = new ::errorpb::KeyNotInRange;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.key_not_in_range)
  return key_not_in_range_;
}
inline ::errorpb::KeyNotInRange* Error::release_key_not_in_range() {
  // @@protoc_insertion_point(field_release:errorpb.Error.key_not_in_range)
  
  ::errorpb::KeyNotInRange* temp = key_not_in_range_;
  key_not_in_range_ = NULL;
  return temp;
}
inline void Error::set_allocated_key_not_in_range(::errorpb::KeyNotInRange* key_not_in_range) {
  delete key_not_in_range_;
  key_not_in_range_ = key_not_in_range;
  if (key_not_in_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.key_not_in_range)
}

// .errorpb.StaleEpoch stale_epoch = 6;
inline bool Error::has_stale_epoch() const {
  return this != internal_default_instance() && stale_epoch_ != NULL;
}
inline void Error::clear_stale_epoch() {
  if (GetArenaNoVirtual() == NULL && stale_epoch_ != NULL) delete stale_epoch_;
  stale_epoch_ = NULL;
}
inline const ::errorpb::StaleEpoch& Error::stale_epoch() const {
  const ::errorpb::StaleEpoch* p = stale_epoch_;
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::StaleEpoch*>(
      &::errorpb::_StaleEpoch_default_instance_);
}
inline ::errorpb::StaleEpoch* Error::mutable_stale_epoch() {
  
  if (stale_epoch_ == NULL) {
    stale_epoch_ = new ::errorpb::StaleEpoch;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_epoch)
  return stale_epoch_;
}
inline ::errorpb::StaleEpoch* Error::release_stale_epoch() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_epoch)
  
  ::errorpb::StaleEpoch* temp = stale_epoch_;
  stale_epoch_ = NULL;
  return temp;
}
inline void Error::set_allocated_stale_epoch(::errorpb::StaleEpoch* stale_epoch) {
  delete stale_epoch_;
  stale_epoch_ = stale_epoch;
  if (stale_epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_epoch)
}

// .errorpb.ServerIsBusy server_is_busy = 7;
inline bool Error::has_server_is_busy() const {
  return this != internal_default_instance() && server_is_busy_ != NULL;
}
inline void Error::clear_server_is_busy() {
  if (GetArenaNoVirtual() == NULL && server_is_busy_ != NULL) delete server_is_busy_;
  server_is_busy_ = NULL;
}
inline const ::errorpb::ServerIsBusy& Error::server_is_busy() const {
  const ::errorpb::ServerIsBusy* p = server_is_busy_;
  // @@protoc_insertion_point(field_get:errorpb.Error.server_is_busy)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::ServerIsBusy*>(
      &::errorpb::_ServerIsBusy_default_instance_);
}
inline ::errorpb::ServerIsBusy* Error::mutable_server_is_busy() {
  
  if (server_is_busy_ == NULL) {
    server_is_busy_ = new ::errorpb::ServerIsBusy;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.server_is_busy)
  return server_is_busy_;
}
inline ::errorpb::ServerIsBusy* Error::release_server_is_busy() {
  // @@protoc_insertion_point(field_release:errorpb.Error.server_is_busy)
  
  ::errorpb::ServerIsBusy* temp = server_is_busy_;
  server_is_busy_ = NULL;
  return temp;
}
inline void Error::set_allocated_server_is_busy(::errorpb::ServerIsBusy* server_is_busy) {
  delete server_is_busy_;
  server_is_busy_ = server_is_busy;
  if (server_is_busy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.server_is_busy)
}

// .errorpb.EntryTooLarge entry_too_large = 8;
inline bool Error::has_entry_too_large() const {
  return this != internal_default_instance() && entry_too_large_ != NULL;
}
inline void Error::clear_entry_too_large() {
  if (GetArenaNoVirtual() == NULL && entry_too_large_ != NULL) delete entry_too_large_;
  entry_too_large_ = NULL;
}
inline const ::errorpb::EntryTooLarge& Error::entry_too_large() const {
  const ::errorpb::EntryTooLarge* p = entry_too_large_;
  // @@protoc_insertion_point(field_get:errorpb.Error.entry_too_large)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::EntryTooLarge*>(
      &::errorpb::_EntryTooLarge_default_instance_);
}
inline ::errorpb::EntryTooLarge* Error::mutable_entry_too_large() {
  
  if (entry_too_large_ == NULL) {
    entry_too_large_ = new ::errorpb::EntryTooLarge;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.entry_too_large)
  return entry_too_large_;
}
inline ::errorpb::EntryTooLarge* Error::release_entry_too_large() {
  // @@protoc_insertion_point(field_release:errorpb.Error.entry_too_large)
  
  ::errorpb::EntryTooLarge* temp = entry_too_large_;
  entry_too_large_ = NULL;
  return temp;
}
inline void Error::set_allocated_entry_too_large(::errorpb::EntryTooLarge* entry_too_large) {
  delete entry_too_large_;
  entry_too_large_ = entry_too_large;
  if (entry_too_large) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.entry_too_large)
}

// .errorpb.Timeout timeout = 9;
inline bool Error::has_timeout() const {
  return this != internal_default_instance() && timeout_ != NULL;
}
inline void Error::clear_timeout() {
  if (GetArenaNoVirtual() == NULL && timeout_ != NULL) delete timeout_;
  timeout_ = NULL;
}
inline const ::errorpb::Timeout& Error::timeout() const {
  const ::errorpb::Timeout* p = timeout_;
  // @@protoc_insertion_point(field_get:errorpb.Error.timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Timeout*>(
      &::errorpb::_Timeout_default_instance_);
}
inline ::errorpb::Timeout* Error::mutable_timeout() {
  
  if (timeout_ == NULL) {
    timeout_ = new ::errorpb::Timeout;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.timeout)
  return timeout_;
}
inline ::errorpb::Timeout* Error::release_timeout() {
  // @@protoc_insertion_point(field_release:errorpb.Error.timeout)
  
  ::errorpb::Timeout* temp = timeout_;
  timeout_ = NULL;
  return temp;
}
inline void Error::set_allocated_timeout(::errorpb::Timeout* timeout) {
  delete timeout_;
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.timeout)
}

// .errorpb.RaftFail raft_fail = 10;
inline bool Error::has_raft_fail() const {
  return this != internal_default_instance() && raft_fail_ != NULL;
}
inline void Error::clear_raft_fail() {
  if (GetArenaNoVirtual() == NULL && raft_fail_ != NULL) delete raft_fail_;
  raft_fail_ = NULL;
}
inline const ::errorpb::RaftFail& Error::raft_fail() const {
  const ::errorpb::RaftFail* p = raft_fail_;
  // @@protoc_insertion_point(field_get:errorpb.Error.raft_fail)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::RaftFail*>(
      &::errorpb::_RaftFail_default_instance_);
}
inline ::errorpb::RaftFail* Error::mutable_raft_fail() {
  
  if (raft_fail_ == NULL) {
    raft_fail_ = new ::errorpb::RaftFail;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.raft_fail)
  return raft_fail_;
}
inline ::errorpb::RaftFail* Error::release_raft_fail() {
  // @@protoc_insertion_point(field_release:errorpb.Error.raft_fail)
  
  ::errorpb::RaftFail* temp = raft_fail_;
  raft_fail_ = NULL;
  return temp;
}
inline void Error::set_allocated_raft_fail(::errorpb::RaftFail* raft_fail) {
  delete raft_fail_;
  raft_fail_ = raft_fail;
  if (raft_fail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.raft_fail)
}

// .errorpb.StaleRange stale_range = 11;
inline bool Error::has_stale_range() const {
  return this != internal_default_instance() && stale_range_ != NULL;
}
inline void Error::clear_stale_range() {
  if (GetArenaNoVirtual() == NULL && stale_range_ != NULL) delete stale_range_;
  stale_range_ = NULL;
}
inline const ::errorpb::StaleRange& Error::stale_range() const {
  const ::errorpb::StaleRange* p = stale_range_;
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_range)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::StaleRange*>(
      &::errorpb::_StaleRange_default_instance_);
}
inline ::errorpb::StaleRange* Error::mutable_stale_range() {
  
  if (stale_range_ == NULL) {
    stale_range_ = new ::errorpb::StaleRange;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_range)
  return stale_range_;
}
inline ::errorpb::StaleRange* Error::release_stale_range() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_range)
  
  ::errorpb::StaleRange* temp = stale_range_;
  stale_range_ = NULL;
  return temp;
}
inline void Error::set_allocated_stale_range(::errorpb::StaleRange* stale_range) {
  delete stale_range_;
  stale_range_ = stale_range;
  if (stale_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_range)
}

// .errorpb.StaleReadIndex stale_read_index = 12;
inline bool Error::has_stale_read_index() const {
  return this != internal_default_instance() && stale_read_index_ != NULL;
}
inline void Error::clear_stale_read_index() {
  if (GetArenaNoVirtual() == NULL && stale_read_index_ != NULL) delete stale_read_index_;
  stale_read_index_ = NULL;
}
inline const ::errorpb::StaleReadIndex& Error::stale_read_index() const {
  const ::errorpb::StaleReadIndex* p = stale_read_index_;
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_read_index)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::StaleReadIndex*>(
      &::errorpb::_StaleReadIndex_default_instance_);
}
inline ::errorpb::StaleReadIndex* Error::mutable_stale_read_index() {
  
  if (stale_read_index_ == NULL) {
    stale_read_index_ = new ::errorpb::StaleReadIndex;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_read_index)
  return stale_read_index_;
}
inline ::errorpb::StaleReadIndex* Error::release_stale_read_index() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_read_index)
  
  ::errorpb::StaleReadIndex* temp = stale_read_index_;
  stale_read_index_ = NULL;
  return temp;
}
inline void Error::set_allocated_stale_read_index(::errorpb::StaleReadIndex* stale_read_index) {
  delete stale_read_index_;
  stale_read_index_ = stale_read_index;
  if (stale_read_index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_read_index)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace errorpb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_errorpb_2eproto__INCLUDED
