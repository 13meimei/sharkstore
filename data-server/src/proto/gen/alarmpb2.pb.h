// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: alarmpb2.proto

#ifndef PROTOBUF_alarmpb2_2eproto__INCLUDED
#define PROTOBUF_alarmpb2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace alarmpb2 {
class AlarmRequest;
class AlarmRequestDefaultTypeInternal;
extern AlarmRequestDefaultTypeInternal _AlarmRequest_default_instance_;
class AlarmResponse;
class AlarmResponseDefaultTypeInternal;
extern AlarmResponseDefaultTypeInternal _AlarmResponse_default_instance_;
class AppHeartbeatRequest;
class AppHeartbeatRequestDefaultTypeInternal;
extern AppHeartbeatRequestDefaultTypeInternal _AppHeartbeatRequest_default_instance_;
class AppNotAliveRequest;
class AppNotAliveRequestDefaultTypeInternal;
extern AppNotAliveRequestDefaultTypeInternal _AppNotAliveRequest_default_instance_;
class GatewayErrorLogRequest;
class GatewayErrorLogRequestDefaultTypeInternal;
extern GatewayErrorLogRequestDefaultTypeInternal _GatewayErrorLogRequest_default_instance_;
class GatewayInputOpsRequest;
class GatewayInputOpsRequestDefaultTypeInternal;
extern GatewayInputOpsRequestDefaultTypeInternal _GatewayInputOpsRequest_default_instance_;
class GatewaySlowLogRequest;
class GatewaySlowLogRequestDefaultTypeInternal;
extern GatewaySlowLogRequestDefaultTypeInternal _GatewaySlowLogRequest_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class RuleAlarmRequest;
class RuleAlarmRequestDefaultTypeInternal;
extern RuleAlarmRequestDefaultTypeInternal _RuleAlarmRequest_default_instance_;
}  // namespace alarmpb2

namespace alarmpb2 {

namespace protobuf_alarmpb2_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_alarmpb2_2eproto

enum AlarmResponseCode {
  OK = 0,
  ERROR = 1,
  AlarmResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AlarmResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AlarmResponseCode_IsValid(int value);
const AlarmResponseCode AlarmResponseCode_MIN = OK;
const AlarmResponseCode AlarmResponseCode_MAX = ERROR;
const int AlarmResponseCode_ARRAYSIZE = AlarmResponseCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlarmResponseCode_descriptor();
inline const ::std::string& AlarmResponseCode_Name(AlarmResponseCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlarmResponseCode_descriptor(), value);
}
inline bool AlarmResponseCode_Parse(
    const ::std::string& name, AlarmResponseCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmResponseCode>(
    AlarmResponseCode_descriptor(), name, value);
}
enum AlarmType {
  INVALID = 0,
  APP_HEARTBEAT = 1,
  RULE_ALARM = 2,
  APP_NOT_ALIVE = 3,
  GATEWAY_SLOWLOG = 4,
  GATEWAY_ERRORLOG = 5,
  AlarmType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AlarmType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AlarmType_IsValid(int value);
const AlarmType AlarmType_MIN = INVALID;
const AlarmType AlarmType_MAX = GATEWAY_ERRORLOG;
const int AlarmType_ARRAYSIZE = AlarmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlarmType_descriptor();
inline const ::std::string& AlarmType_Name(AlarmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlarmType_descriptor(), value);
}
inline bool AlarmType_Parse(
    const ::std::string& name, AlarmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmType>(
    AlarmType_descriptor(), name, value);
}
enum AlarmValueCompareType {
  EQUAL = 0,
  GREATER_THAN = 1,
  LESS_THAN = 2,
  NOT_EQUAL = 3,
  NOT_GREATER_THAN = 4,
  NOT_LESS_THAN = 5,
  AlarmValueCompareType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AlarmValueCompareType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AlarmValueCompareType_IsValid(int value);
const AlarmValueCompareType AlarmValueCompareType_MIN = EQUAL;
const AlarmValueCompareType AlarmValueCompareType_MAX = NOT_LESS_THAN;
const int AlarmValueCompareType_ARRAYSIZE = AlarmValueCompareType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlarmValueCompareType_descriptor();
inline const ::std::string& AlarmValueCompareType_Name(AlarmValueCompareType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlarmValueCompareType_descriptor(), value);
}
inline bool AlarmValueCompareType_Parse(
    const ::std::string& name, AlarmValueCompareType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmValueCompareType>(
    AlarmValueCompareType_descriptor(), name, value);
}
// ===================================================================

class AlarmRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.AlarmRequest) */ {
 public:
  AlarmRequest();
  virtual ~AlarmRequest();

  AlarmRequest(const AlarmRequest& from);

  inline AlarmRequest& operator=(const AlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AlarmRequest(AlarmRequest&& from) noexcept
    : AlarmRequest() {
    *this = ::std::move(from);
  }

  inline AlarmRequest& operator=(AlarmRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmRequest& default_instance();

  static inline const AlarmRequest* internal_default_instance() {
    return reinterpret_cast<const AlarmRequest*>(
               &_AlarmRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AlarmRequest* other);
  friend void swap(AlarmRequest& a, AlarmRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AlarmRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AlarmRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AlarmRequest& from);
  void MergeFrom(const AlarmRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AlarmRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb2.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::alarmpb2::RequestHeader& header() const;
  ::alarmpb2::RequestHeader* mutable_header();
  ::alarmpb2::RequestHeader* release_header();
  void set_allocated_header(::alarmpb2::RequestHeader* header);

  // .alarmpb2.RuleAlarmRequest rule_alarm = 2;
  bool has_rule_alarm() const;
  void clear_rule_alarm();
  static const int kRuleAlarmFieldNumber = 2;
  const ::alarmpb2::RuleAlarmRequest& rule_alarm() const;
  ::alarmpb2::RuleAlarmRequest* mutable_rule_alarm();
  ::alarmpb2::RuleAlarmRequest* release_rule_alarm();
  void set_allocated_rule_alarm(::alarmpb2::RuleAlarmRequest* rule_alarm);

  // .alarmpb2.AppHeartbeatRequest app_heartbeat = 3;
  bool has_app_heartbeat() const;
  void clear_app_heartbeat();
  static const int kAppHeartbeatFieldNumber = 3;
  const ::alarmpb2::AppHeartbeatRequest& app_heartbeat() const;
  ::alarmpb2::AppHeartbeatRequest* mutable_app_heartbeat();
  ::alarmpb2::AppHeartbeatRequest* release_app_heartbeat();
  void set_allocated_app_heartbeat(::alarmpb2::AppHeartbeatRequest* app_heartbeat);

  // @@protoc_insertion_point(class_scope:alarmpb2.AlarmRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb2::RequestHeader* header_;
  ::alarmpb2::RuleAlarmRequest* rule_alarm_;
  ::alarmpb2::AppHeartbeatRequest* app_heartbeat_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip_addr = 3;
  void clear_ip_addr();
  static const int kIpAddrFieldNumber = 3;
  const ::std::string& ip_addr() const;
  void set_ip_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_addr(::std::string&& value);
  #endif
  void set_ip_addr(const char* value);
  void set_ip_addr(const char* value, size_t size);
  ::std::string* mutable_ip_addr();
  ::std::string* release_ip_addr();
  void set_allocated_ip_addr(::std::string* ip_addr);

  // string app_name = 4;
  void clear_app_name();
  static const int kAppNameFieldNumber = 4;
  const ::std::string& app_name() const;
  void set_app_name(const ::std::string& value);
  #if LANG_CXX11
  void set_app_name(::std::string&& value);
  #endif
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  ::std::string* mutable_app_name();
  ::std::string* release_app_name();
  void set_allocated_app_name(::std::string* app_name);

  // int64 cluster_id = 2;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 2;
  ::google::protobuf::int64 cluster_id() const;
  void set_cluster_id(::google::protobuf::int64 value);

  // .alarmpb2.AlarmType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::alarmpb2::AlarmType type() const;
  void set_type(::alarmpb2::AlarmType value);

  // @@protoc_insertion_point(class_scope:alarmpb2.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_addr_;
  ::google::protobuf::internal::ArenaStringPtr app_name_;
  ::google::protobuf::int64 cluster_id_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RuleAlarmRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.RuleAlarmRequest) */ {
 public:
  RuleAlarmRequest();
  virtual ~RuleAlarmRequest();

  RuleAlarmRequest(const RuleAlarmRequest& from);

  inline RuleAlarmRequest& operator=(const RuleAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuleAlarmRequest(RuleAlarmRequest&& from) noexcept
    : RuleAlarmRequest() {
    *this = ::std::move(from);
  }

  inline RuleAlarmRequest& operator=(RuleAlarmRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuleAlarmRequest& default_instance();

  static inline const RuleAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const RuleAlarmRequest*>(
               &_RuleAlarmRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RuleAlarmRequest* other);
  friend void swap(RuleAlarmRequest& a, RuleAlarmRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuleAlarmRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RuleAlarmRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuleAlarmRequest& from);
  void MergeFrom(const RuleAlarmRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuleAlarmRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string remark = 4;
  int remark_size() const;
  void clear_remark();
  static const int kRemarkFieldNumber = 4;
  const ::std::string& remark(int index) const;
  ::std::string* mutable_remark(int index);
  void set_remark(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_remark(int index, ::std::string&& value);
  #endif
  void set_remark(int index, const char* value);
  void set_remark(int index, const char* value, size_t size);
  ::std::string* add_remark();
  void add_remark(const ::std::string& value);
  #if LANG_CXX11
  void add_remark(::std::string&& value);
  #endif
  void add_remark(const char* value);
  void add_remark(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& remark() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_remark();

  // string rule_name = 1;
  void clear_rule_name();
  static const int kRuleNameFieldNumber = 1;
  const ::std::string& rule_name() const;
  void set_rule_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rule_name(::std::string&& value);
  #endif
  void set_rule_name(const char* value);
  void set_rule_name(const char* value, size_t size);
  ::std::string* mutable_rule_name();
  ::std::string* release_rule_name();
  void set_allocated_rule_name(::std::string* rule_name);

  // double alarm_value = 2;
  void clear_alarm_value();
  static const int kAlarmValueFieldNumber = 2;
  double alarm_value() const;
  void set_alarm_value(double value);

  // .alarmpb2.AlarmValueCompareType cmp_type = 3;
  void clear_cmp_type();
  static const int kCmpTypeFieldNumber = 3;
  ::alarmpb2::AlarmValueCompareType cmp_type() const;
  void set_cmp_type(::alarmpb2::AlarmValueCompareType value);

  // @@protoc_insertion_point(class_scope:alarmpb2.RuleAlarmRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> remark_;
  ::google::protobuf::internal::ArenaStringPtr rule_name_;
  double alarm_value_;
  int cmp_type_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.AppHeartbeatRequest) */ {
 public:
  AppHeartbeatRequest();
  virtual ~AppHeartbeatRequest();

  AppHeartbeatRequest(const AppHeartbeatRequest& from);

  inline AppHeartbeatRequest& operator=(const AppHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppHeartbeatRequest(AppHeartbeatRequest&& from) noexcept
    : AppHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline AppHeartbeatRequest& operator=(AppHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppHeartbeatRequest& default_instance();

  static inline const AppHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const AppHeartbeatRequest*>(
               &_AppHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AppHeartbeatRequest* other);
  friend void swap(AppHeartbeatRequest& a, AppHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AppHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppHeartbeatRequest& from);
  void MergeFrom(const AppHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 hb_interval_time = 1;
  void clear_hb_interval_time();
  static const int kHbIntervalTimeFieldNumber = 1;
  ::google::protobuf::int64 hb_interval_time() const;
  void set_hb_interval_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:alarmpb2.AppHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 hb_interval_time_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppNotAliveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.AppNotAliveRequest) */ {
 public:
  AppNotAliveRequest();
  virtual ~AppNotAliveRequest();

  AppNotAliveRequest(const AppNotAliveRequest& from);

  inline AppNotAliveRequest& operator=(const AppNotAliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppNotAliveRequest(AppNotAliveRequest&& from) noexcept
    : AppNotAliveRequest() {
    *this = ::std::move(from);
  }

  inline AppNotAliveRequest& operator=(AppNotAliveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppNotAliveRequest& default_instance();

  static inline const AppNotAliveRequest* internal_default_instance() {
    return reinterpret_cast<const AppNotAliveRequest*>(
               &_AppNotAliveRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AppNotAliveRequest* other);
  friend void swap(AppNotAliveRequest& a, AppNotAliveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppNotAliveRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AppNotAliveRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppNotAliveRequest& from);
  void MergeFrom(const AppNotAliveRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppNotAliveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string app_name = 1;
  void clear_app_name();
  static const int kAppNameFieldNumber = 1;
  const ::std::string& app_name() const;
  void set_app_name(const ::std::string& value);
  #if LANG_CXX11
  void set_app_name(::std::string&& value);
  #endif
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  ::std::string* mutable_app_name();
  ::std::string* release_app_name();
  void set_allocated_app_name(::std::string* app_name);

  // string alive_check_time = 2;
  void clear_alive_check_time();
  static const int kAliveCheckTimeFieldNumber = 2;
  const ::std::string& alive_check_time() const;
  void set_alive_check_time(const ::std::string& value);
  #if LANG_CXX11
  void set_alive_check_time(::std::string&& value);
  #endif
  void set_alive_check_time(const char* value);
  void set_alive_check_time(const char* value, size_t size);
  ::std::string* mutable_alive_check_time();
  ::std::string* release_alive_check_time();
  void set_allocated_alive_check_time(::std::string* alive_check_time);

  // @@protoc_insertion_point(class_scope:alarmpb2.AppNotAliveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr app_name_;
  ::google::protobuf::internal::ArenaStringPtr alive_check_time_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GatewaySlowLogRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.GatewaySlowLogRequest) */ {
 public:
  GatewaySlowLogRequest();
  virtual ~GatewaySlowLogRequest();

  GatewaySlowLogRequest(const GatewaySlowLogRequest& from);

  inline GatewaySlowLogRequest& operator=(const GatewaySlowLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GatewaySlowLogRequest(GatewaySlowLogRequest&& from) noexcept
    : GatewaySlowLogRequest() {
    *this = ::std::move(from);
  }

  inline GatewaySlowLogRequest& operator=(GatewaySlowLogRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GatewaySlowLogRequest& default_instance();

  static inline const GatewaySlowLogRequest* internal_default_instance() {
    return reinterpret_cast<const GatewaySlowLogRequest*>(
               &_GatewaySlowLogRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GatewaySlowLogRequest* other);
  friend void swap(GatewaySlowLogRequest& a, GatewaySlowLogRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GatewaySlowLogRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GatewaySlowLogRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GatewaySlowLogRequest& from);
  void MergeFrom(const GatewaySlowLogRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GatewaySlowLogRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string slow_log = 1;
  int slow_log_size() const;
  void clear_slow_log();
  static const int kSlowLogFieldNumber = 1;
  const ::std::string& slow_log(int index) const;
  ::std::string* mutable_slow_log(int index);
  void set_slow_log(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_slow_log(int index, ::std::string&& value);
  #endif
  void set_slow_log(int index, const char* value);
  void set_slow_log(int index, const char* value, size_t size);
  ::std::string* add_slow_log();
  void add_slow_log(const ::std::string& value);
  #if LANG_CXX11
  void add_slow_log(::std::string&& value);
  #endif
  void add_slow_log(const char* value);
  void add_slow_log(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& slow_log() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_slow_log();

  // @@protoc_insertion_point(class_scope:alarmpb2.GatewaySlowLogRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> slow_log_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GatewayErrorLogRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.GatewayErrorLogRequest) */ {
 public:
  GatewayErrorLogRequest();
  virtual ~GatewayErrorLogRequest();

  GatewayErrorLogRequest(const GatewayErrorLogRequest& from);

  inline GatewayErrorLogRequest& operator=(const GatewayErrorLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GatewayErrorLogRequest(GatewayErrorLogRequest&& from) noexcept
    : GatewayErrorLogRequest() {
    *this = ::std::move(from);
  }

  inline GatewayErrorLogRequest& operator=(GatewayErrorLogRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GatewayErrorLogRequest& default_instance();

  static inline const GatewayErrorLogRequest* internal_default_instance() {
    return reinterpret_cast<const GatewayErrorLogRequest*>(
               &_GatewayErrorLogRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(GatewayErrorLogRequest* other);
  friend void swap(GatewayErrorLogRequest& a, GatewayErrorLogRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GatewayErrorLogRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GatewayErrorLogRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GatewayErrorLogRequest& from);
  void MergeFrom(const GatewayErrorLogRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GatewayErrorLogRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string error_log = 1;
  int error_log_size() const;
  void clear_error_log();
  static const int kErrorLogFieldNumber = 1;
  const ::std::string& error_log(int index) const;
  ::std::string* mutable_error_log(int index);
  void set_error_log(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_error_log(int index, ::std::string&& value);
  #endif
  void set_error_log(int index, const char* value);
  void set_error_log(int index, const char* value, size_t size);
  ::std::string* add_error_log();
  void add_error_log(const ::std::string& value);
  #if LANG_CXX11
  void add_error_log(::std::string&& value);
  #endif
  void add_error_log(const char* value);
  void add_error_log(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& error_log() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_error_log();

  // @@protoc_insertion_point(class_scope:alarmpb2.GatewayErrorLogRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> error_log_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GatewayInputOpsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.GatewayInputOpsRequest) */ {
 public:
  GatewayInputOpsRequest();
  virtual ~GatewayInputOpsRequest();

  GatewayInputOpsRequest(const GatewayInputOpsRequest& from);

  inline GatewayInputOpsRequest& operator=(const GatewayInputOpsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GatewayInputOpsRequest(GatewayInputOpsRequest&& from) noexcept
    : GatewayInputOpsRequest() {
    *this = ::std::move(from);
  }

  inline GatewayInputOpsRequest& operator=(GatewayInputOpsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GatewayInputOpsRequest& default_instance();

  static inline const GatewayInputOpsRequest* internal_default_instance() {
    return reinterpret_cast<const GatewayInputOpsRequest*>(
               &_GatewayInputOpsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GatewayInputOpsRequest* other);
  friend void swap(GatewayInputOpsRequest& a, GatewayInputOpsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GatewayInputOpsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GatewayInputOpsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GatewayInputOpsRequest& from);
  void MergeFrom(const GatewayInputOpsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GatewayInputOpsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double alarm_value = 1;
  void clear_alarm_value();
  static const int kAlarmValueFieldNumber = 1;
  double alarm_value() const;
  void set_alarm_value(double value);

  // .alarmpb2.AlarmValueCompareType cmp_type = 2;
  void clear_cmp_type();
  static const int kCmpTypeFieldNumber = 2;
  ::alarmpb2::AlarmValueCompareType cmp_type() const;
  void set_cmp_type(::alarmpb2::AlarmValueCompareType value);

  // @@protoc_insertion_point(class_scope:alarmpb2.GatewayInputOpsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double alarm_value_;
  int cmp_type_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AlarmResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.AlarmResponse) */ {
 public:
  AlarmResponse();
  virtual ~AlarmResponse();

  AlarmResponse(const AlarmResponse& from);

  inline AlarmResponse& operator=(const AlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AlarmResponse(AlarmResponse&& from) noexcept
    : AlarmResponse() {
    *this = ::std::move(from);
  }

  inline AlarmResponse& operator=(AlarmResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmResponse& default_instance();

  static inline const AlarmResponse* internal_default_instance() {
    return reinterpret_cast<const AlarmResponse*>(
               &_AlarmResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(AlarmResponse* other);
  friend void swap(AlarmResponse& a, AlarmResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AlarmResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AlarmResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AlarmResponse& from);
  void MergeFrom(const AlarmResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AlarmResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb2.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::alarmpb2::ResponseHeader& header() const;
  ::alarmpb2::ResponseHeader* mutable_header();
  ::alarmpb2::ResponseHeader* release_header();
  void set_allocated_header(::alarmpb2::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:alarmpb2.AlarmResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb2::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb2.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .alarmpb2.AlarmResponseCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::alarmpb2::AlarmResponseCode code() const;
  void set_code(::alarmpb2::AlarmResponseCode value);

  // @@protoc_insertion_point(class_scope:alarmpb2.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  int code_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb2_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AlarmRequest

// .alarmpb2.RequestHeader header = 1;
inline bool AlarmRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AlarmRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::alarmpb2::RequestHeader& AlarmRequest::header() const {
  const ::alarmpb2::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:alarmpb2.AlarmRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb2::RequestHeader*>(
      &::alarmpb2::_RequestHeader_default_instance_);
}
inline ::alarmpb2::RequestHeader* AlarmRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::alarmpb2::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb2.AlarmRequest.header)
  return header_;
}
inline ::alarmpb2::RequestHeader* AlarmRequest::release_header() {
  // @@protoc_insertion_point(field_release:alarmpb2.AlarmRequest.header)
  
  ::alarmpb2::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AlarmRequest::set_allocated_header(::alarmpb2::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.AlarmRequest.header)
}

// .alarmpb2.RuleAlarmRequest rule_alarm = 2;
inline bool AlarmRequest::has_rule_alarm() const {
  return this != internal_default_instance() && rule_alarm_ != NULL;
}
inline void AlarmRequest::clear_rule_alarm() {
  if (GetArenaNoVirtual() == NULL && rule_alarm_ != NULL) delete rule_alarm_;
  rule_alarm_ = NULL;
}
inline const ::alarmpb2::RuleAlarmRequest& AlarmRequest::rule_alarm() const {
  const ::alarmpb2::RuleAlarmRequest* p = rule_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb2.AlarmRequest.rule_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb2::RuleAlarmRequest*>(
      &::alarmpb2::_RuleAlarmRequest_default_instance_);
}
inline ::alarmpb2::RuleAlarmRequest* AlarmRequest::mutable_rule_alarm() {
  
  if (rule_alarm_ == NULL) {
    rule_alarm_ = new ::alarmpb2::RuleAlarmRequest;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb2.AlarmRequest.rule_alarm)
  return rule_alarm_;
}
inline ::alarmpb2::RuleAlarmRequest* AlarmRequest::release_rule_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb2.AlarmRequest.rule_alarm)
  
  ::alarmpb2::RuleAlarmRequest* temp = rule_alarm_;
  rule_alarm_ = NULL;
  return temp;
}
inline void AlarmRequest::set_allocated_rule_alarm(::alarmpb2::RuleAlarmRequest* rule_alarm) {
  delete rule_alarm_;
  rule_alarm_ = rule_alarm;
  if (rule_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.AlarmRequest.rule_alarm)
}

// .alarmpb2.AppHeartbeatRequest app_heartbeat = 3;
inline bool AlarmRequest::has_app_heartbeat() const {
  return this != internal_default_instance() && app_heartbeat_ != NULL;
}
inline void AlarmRequest::clear_app_heartbeat() {
  if (GetArenaNoVirtual() == NULL && app_heartbeat_ != NULL) delete app_heartbeat_;
  app_heartbeat_ = NULL;
}
inline const ::alarmpb2::AppHeartbeatRequest& AlarmRequest::app_heartbeat() const {
  const ::alarmpb2::AppHeartbeatRequest* p = app_heartbeat_;
  // @@protoc_insertion_point(field_get:alarmpb2.AlarmRequest.app_heartbeat)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb2::AppHeartbeatRequest*>(
      &::alarmpb2::_AppHeartbeatRequest_default_instance_);
}
inline ::alarmpb2::AppHeartbeatRequest* AlarmRequest::mutable_app_heartbeat() {
  
  if (app_heartbeat_ == NULL) {
    app_heartbeat_ = new ::alarmpb2::AppHeartbeatRequest;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb2.AlarmRequest.app_heartbeat)
  return app_heartbeat_;
}
inline ::alarmpb2::AppHeartbeatRequest* AlarmRequest::release_app_heartbeat() {
  // @@protoc_insertion_point(field_release:alarmpb2.AlarmRequest.app_heartbeat)
  
  ::alarmpb2::AppHeartbeatRequest* temp = app_heartbeat_;
  app_heartbeat_ = NULL;
  return temp;
}
inline void AlarmRequest::set_allocated_app_heartbeat(::alarmpb2::AppHeartbeatRequest* app_heartbeat) {
  delete app_heartbeat_;
  app_heartbeat_ = app_heartbeat;
  if (app_heartbeat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.AlarmRequest.app_heartbeat)
}

// -------------------------------------------------------------------

// RequestHeader

// .alarmpb2.AlarmType type = 1;
inline void RequestHeader::clear_type() {
  type_ = 0;
}
inline ::alarmpb2::AlarmType RequestHeader::type() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RequestHeader.type)
  return static_cast< ::alarmpb2::AlarmType >(type_);
}
inline void RequestHeader::set_type(::alarmpb2::AlarmType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.RequestHeader.type)
}

// int64 cluster_id = 2;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::int64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.RequestHeader.cluster_id)
}

// string ip_addr = 3;
inline void RequestHeader::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestHeader::ip_addr() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RequestHeader.ip_addr)
  return ip_addr_.GetNoArena();
}
inline void RequestHeader::set_ip_addr(const ::std::string& value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb2.RequestHeader.ip_addr)
}
#if LANG_CXX11
inline void RequestHeader::set_ip_addr(::std::string&& value) {
  
  ip_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb2.RequestHeader.ip_addr)
}
#endif
inline void RequestHeader::set_ip_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb2.RequestHeader.ip_addr)
}
inline void RequestHeader::set_ip_addr(const char* value, size_t size) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.RequestHeader.ip_addr)
}
inline ::std::string* RequestHeader::mutable_ip_addr() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb2.RequestHeader.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestHeader::release_ip_addr() {
  // @@protoc_insertion_point(field_release:alarmpb2.RequestHeader.ip_addr)
  
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeader::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    
  } else {
    
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.RequestHeader.ip_addr)
}

// string app_name = 4;
inline void RequestHeader::clear_app_name() {
  app_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestHeader::app_name() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RequestHeader.app_name)
  return app_name_.GetNoArena();
}
inline void RequestHeader::set_app_name(const ::std::string& value) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb2.RequestHeader.app_name)
}
#if LANG_CXX11
inline void RequestHeader::set_app_name(::std::string&& value) {
  
  app_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb2.RequestHeader.app_name)
}
#endif
inline void RequestHeader::set_app_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb2.RequestHeader.app_name)
}
inline void RequestHeader::set_app_name(const char* value, size_t size) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.RequestHeader.app_name)
}
inline ::std::string* RequestHeader::mutable_app_name() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb2.RequestHeader.app_name)
  return app_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestHeader::release_app_name() {
  // @@protoc_insertion_point(field_release:alarmpb2.RequestHeader.app_name)
  
  return app_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeader::set_allocated_app_name(::std::string* app_name) {
  if (app_name != NULL) {
    
  } else {
    
  }
  app_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_name);
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.RequestHeader.app_name)
}

// -------------------------------------------------------------------

// RuleAlarmRequest

// string rule_name = 1;
inline void RuleAlarmRequest::clear_rule_name() {
  rule_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuleAlarmRequest::rule_name() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RuleAlarmRequest.rule_name)
  return rule_name_.GetNoArena();
}
inline void RuleAlarmRequest::set_rule_name(const ::std::string& value) {
  
  rule_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb2.RuleAlarmRequest.rule_name)
}
#if LANG_CXX11
inline void RuleAlarmRequest::set_rule_name(::std::string&& value) {
  
  rule_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb2.RuleAlarmRequest.rule_name)
}
#endif
inline void RuleAlarmRequest::set_rule_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rule_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb2.RuleAlarmRequest.rule_name)
}
inline void RuleAlarmRequest::set_rule_name(const char* value, size_t size) {
  
  rule_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.RuleAlarmRequest.rule_name)
}
inline ::std::string* RuleAlarmRequest::mutable_rule_name() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb2.RuleAlarmRequest.rule_name)
  return rule_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuleAlarmRequest::release_rule_name() {
  // @@protoc_insertion_point(field_release:alarmpb2.RuleAlarmRequest.rule_name)
  
  return rule_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuleAlarmRequest::set_allocated_rule_name(::std::string* rule_name) {
  if (rule_name != NULL) {
    
  } else {
    
  }
  rule_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rule_name);
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.RuleAlarmRequest.rule_name)
}

// double alarm_value = 2;
inline void RuleAlarmRequest::clear_alarm_value() {
  alarm_value_ = 0;
}
inline double RuleAlarmRequest::alarm_value() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RuleAlarmRequest.alarm_value)
  return alarm_value_;
}
inline void RuleAlarmRequest::set_alarm_value(double value) {
  
  alarm_value_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.RuleAlarmRequest.alarm_value)
}

// .alarmpb2.AlarmValueCompareType cmp_type = 3;
inline void RuleAlarmRequest::clear_cmp_type() {
  cmp_type_ = 0;
}
inline ::alarmpb2::AlarmValueCompareType RuleAlarmRequest::cmp_type() const {
  // @@protoc_insertion_point(field_get:alarmpb2.RuleAlarmRequest.cmp_type)
  return static_cast< ::alarmpb2::AlarmValueCompareType >(cmp_type_);
}
inline void RuleAlarmRequest::set_cmp_type(::alarmpb2::AlarmValueCompareType value) {
  
  cmp_type_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.RuleAlarmRequest.cmp_type)
}

// repeated string remark = 4;
inline int RuleAlarmRequest::remark_size() const {
  return remark_.size();
}
inline void RuleAlarmRequest::clear_remark() {
  remark_.Clear();
}
inline const ::std::string& RuleAlarmRequest::remark(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb2.RuleAlarmRequest.remark)
  return remark_.Get(index);
}
inline ::std::string* RuleAlarmRequest::mutable_remark(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb2.RuleAlarmRequest.remark)
  return remark_.Mutable(index);
}
inline void RuleAlarmRequest::set_remark(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb2.RuleAlarmRequest.remark)
  remark_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RuleAlarmRequest::set_remark(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb2.RuleAlarmRequest.remark)
  remark_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RuleAlarmRequest::set_remark(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  remark_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb2.RuleAlarmRequest.remark)
}
inline void RuleAlarmRequest::set_remark(int index, const char* value, size_t size) {
  remark_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.RuleAlarmRequest.remark)
}
inline ::std::string* RuleAlarmRequest::add_remark() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb2.RuleAlarmRequest.remark)
  return remark_.Add();
}
inline void RuleAlarmRequest::add_remark(const ::std::string& value) {
  remark_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb2.RuleAlarmRequest.remark)
}
#if LANG_CXX11
inline void RuleAlarmRequest::add_remark(::std::string&& value) {
  remark_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb2.RuleAlarmRequest.remark)
}
#endif
inline void RuleAlarmRequest::add_remark(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  remark_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb2.RuleAlarmRequest.remark)
}
inline void RuleAlarmRequest::add_remark(const char* value, size_t size) {
  remark_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb2.RuleAlarmRequest.remark)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RuleAlarmRequest::remark() const {
  // @@protoc_insertion_point(field_list:alarmpb2.RuleAlarmRequest.remark)
  return remark_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RuleAlarmRequest::mutable_remark() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb2.RuleAlarmRequest.remark)
  return &remark_;
}

// -------------------------------------------------------------------

// AppHeartbeatRequest

// int64 hb_interval_time = 1;
inline void AppHeartbeatRequest::clear_hb_interval_time() {
  hb_interval_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AppHeartbeatRequest::hb_interval_time() const {
  // @@protoc_insertion_point(field_get:alarmpb2.AppHeartbeatRequest.hb_interval_time)
  return hb_interval_time_;
}
inline void AppHeartbeatRequest::set_hb_interval_time(::google::protobuf::int64 value) {
  
  hb_interval_time_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.AppHeartbeatRequest.hb_interval_time)
}

// -------------------------------------------------------------------

// AppNotAliveRequest

// string app_name = 1;
inline void AppNotAliveRequest::clear_app_name() {
  app_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AppNotAliveRequest::app_name() const {
  // @@protoc_insertion_point(field_get:alarmpb2.AppNotAliveRequest.app_name)
  return app_name_.GetNoArena();
}
inline void AppNotAliveRequest::set_app_name(const ::std::string& value) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb2.AppNotAliveRequest.app_name)
}
#if LANG_CXX11
inline void AppNotAliveRequest::set_app_name(::std::string&& value) {
  
  app_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb2.AppNotAliveRequest.app_name)
}
#endif
inline void AppNotAliveRequest::set_app_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb2.AppNotAliveRequest.app_name)
}
inline void AppNotAliveRequest::set_app_name(const char* value, size_t size) {
  
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.AppNotAliveRequest.app_name)
}
inline ::std::string* AppNotAliveRequest::mutable_app_name() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb2.AppNotAliveRequest.app_name)
  return app_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppNotAliveRequest::release_app_name() {
  // @@protoc_insertion_point(field_release:alarmpb2.AppNotAliveRequest.app_name)
  
  return app_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppNotAliveRequest::set_allocated_app_name(::std::string* app_name) {
  if (app_name != NULL) {
    
  } else {
    
  }
  app_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_name);
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.AppNotAliveRequest.app_name)
}

// string alive_check_time = 2;
inline void AppNotAliveRequest::clear_alive_check_time() {
  alive_check_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AppNotAliveRequest::alive_check_time() const {
  // @@protoc_insertion_point(field_get:alarmpb2.AppNotAliveRequest.alive_check_time)
  return alive_check_time_.GetNoArena();
}
inline void AppNotAliveRequest::set_alive_check_time(const ::std::string& value) {
  
  alive_check_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb2.AppNotAliveRequest.alive_check_time)
}
#if LANG_CXX11
inline void AppNotAliveRequest::set_alive_check_time(::std::string&& value) {
  
  alive_check_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb2.AppNotAliveRequest.alive_check_time)
}
#endif
inline void AppNotAliveRequest::set_alive_check_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  alive_check_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb2.AppNotAliveRequest.alive_check_time)
}
inline void AppNotAliveRequest::set_alive_check_time(const char* value, size_t size) {
  
  alive_check_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.AppNotAliveRequest.alive_check_time)
}
inline ::std::string* AppNotAliveRequest::mutable_alive_check_time() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb2.AppNotAliveRequest.alive_check_time)
  return alive_check_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppNotAliveRequest::release_alive_check_time() {
  // @@protoc_insertion_point(field_release:alarmpb2.AppNotAliveRequest.alive_check_time)
  
  return alive_check_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppNotAliveRequest::set_allocated_alive_check_time(::std::string* alive_check_time) {
  if (alive_check_time != NULL) {
    
  } else {
    
  }
  alive_check_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alive_check_time);
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.AppNotAliveRequest.alive_check_time)
}

// -------------------------------------------------------------------

// GatewaySlowLogRequest

// repeated string slow_log = 1;
inline int GatewaySlowLogRequest::slow_log_size() const {
  return slow_log_.size();
}
inline void GatewaySlowLogRequest::clear_slow_log() {
  slow_log_.Clear();
}
inline const ::std::string& GatewaySlowLogRequest::slow_log(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb2.GatewaySlowLogRequest.slow_log)
  return slow_log_.Get(index);
}
inline ::std::string* GatewaySlowLogRequest::mutable_slow_log(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb2.GatewaySlowLogRequest.slow_log)
  return slow_log_.Mutable(index);
}
inline void GatewaySlowLogRequest::set_slow_log(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb2.GatewaySlowLogRequest.slow_log)
  slow_log_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GatewaySlowLogRequest::set_slow_log(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb2.GatewaySlowLogRequest.slow_log)
  slow_log_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GatewaySlowLogRequest::set_slow_log(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  slow_log_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb2.GatewaySlowLogRequest.slow_log)
}
inline void GatewaySlowLogRequest::set_slow_log(int index, const char* value, size_t size) {
  slow_log_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.GatewaySlowLogRequest.slow_log)
}
inline ::std::string* GatewaySlowLogRequest::add_slow_log() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb2.GatewaySlowLogRequest.slow_log)
  return slow_log_.Add();
}
inline void GatewaySlowLogRequest::add_slow_log(const ::std::string& value) {
  slow_log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb2.GatewaySlowLogRequest.slow_log)
}
#if LANG_CXX11
inline void GatewaySlowLogRequest::add_slow_log(::std::string&& value) {
  slow_log_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb2.GatewaySlowLogRequest.slow_log)
}
#endif
inline void GatewaySlowLogRequest::add_slow_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  slow_log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb2.GatewaySlowLogRequest.slow_log)
}
inline void GatewaySlowLogRequest::add_slow_log(const char* value, size_t size) {
  slow_log_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb2.GatewaySlowLogRequest.slow_log)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GatewaySlowLogRequest::slow_log() const {
  // @@protoc_insertion_point(field_list:alarmpb2.GatewaySlowLogRequest.slow_log)
  return slow_log_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GatewaySlowLogRequest::mutable_slow_log() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb2.GatewaySlowLogRequest.slow_log)
  return &slow_log_;
}

// -------------------------------------------------------------------

// GatewayErrorLogRequest

// repeated string error_log = 1;
inline int GatewayErrorLogRequest::error_log_size() const {
  return error_log_.size();
}
inline void GatewayErrorLogRequest::clear_error_log() {
  error_log_.Clear();
}
inline const ::std::string& GatewayErrorLogRequest::error_log(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb2.GatewayErrorLogRequest.error_log)
  return error_log_.Get(index);
}
inline ::std::string* GatewayErrorLogRequest::mutable_error_log(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb2.GatewayErrorLogRequest.error_log)
  return error_log_.Mutable(index);
}
inline void GatewayErrorLogRequest::set_error_log(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb2.GatewayErrorLogRequest.error_log)
  error_log_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GatewayErrorLogRequest::set_error_log(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb2.GatewayErrorLogRequest.error_log)
  error_log_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GatewayErrorLogRequest::set_error_log(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  error_log_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb2.GatewayErrorLogRequest.error_log)
}
inline void GatewayErrorLogRequest::set_error_log(int index, const char* value, size_t size) {
  error_log_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.GatewayErrorLogRequest.error_log)
}
inline ::std::string* GatewayErrorLogRequest::add_error_log() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb2.GatewayErrorLogRequest.error_log)
  return error_log_.Add();
}
inline void GatewayErrorLogRequest::add_error_log(const ::std::string& value) {
  error_log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb2.GatewayErrorLogRequest.error_log)
}
#if LANG_CXX11
inline void GatewayErrorLogRequest::add_error_log(::std::string&& value) {
  error_log_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb2.GatewayErrorLogRequest.error_log)
}
#endif
inline void GatewayErrorLogRequest::add_error_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  error_log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb2.GatewayErrorLogRequest.error_log)
}
inline void GatewayErrorLogRequest::add_error_log(const char* value, size_t size) {
  error_log_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb2.GatewayErrorLogRequest.error_log)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GatewayErrorLogRequest::error_log() const {
  // @@protoc_insertion_point(field_list:alarmpb2.GatewayErrorLogRequest.error_log)
  return error_log_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GatewayErrorLogRequest::mutable_error_log() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb2.GatewayErrorLogRequest.error_log)
  return &error_log_;
}

// -------------------------------------------------------------------

// GatewayInputOpsRequest

// double alarm_value = 1;
inline void GatewayInputOpsRequest::clear_alarm_value() {
  alarm_value_ = 0;
}
inline double GatewayInputOpsRequest::alarm_value() const {
  // @@protoc_insertion_point(field_get:alarmpb2.GatewayInputOpsRequest.alarm_value)
  return alarm_value_;
}
inline void GatewayInputOpsRequest::set_alarm_value(double value) {
  
  alarm_value_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.GatewayInputOpsRequest.alarm_value)
}

// .alarmpb2.AlarmValueCompareType cmp_type = 2;
inline void GatewayInputOpsRequest::clear_cmp_type() {
  cmp_type_ = 0;
}
inline ::alarmpb2::AlarmValueCompareType GatewayInputOpsRequest::cmp_type() const {
  // @@protoc_insertion_point(field_get:alarmpb2.GatewayInputOpsRequest.cmp_type)
  return static_cast< ::alarmpb2::AlarmValueCompareType >(cmp_type_);
}
inline void GatewayInputOpsRequest::set_cmp_type(::alarmpb2::AlarmValueCompareType value) {
  
  cmp_type_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.GatewayInputOpsRequest.cmp_type)
}

// -------------------------------------------------------------------

// AlarmResponse

// .alarmpb2.ResponseHeader header = 1;
inline bool AlarmResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AlarmResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::alarmpb2::ResponseHeader& AlarmResponse::header() const {
  const ::alarmpb2::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:alarmpb2.AlarmResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb2::ResponseHeader*>(
      &::alarmpb2::_ResponseHeader_default_instance_);
}
inline ::alarmpb2::ResponseHeader* AlarmResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::alarmpb2::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb2.AlarmResponse.header)
  return header_;
}
inline ::alarmpb2::ResponseHeader* AlarmResponse::release_header() {
  // @@protoc_insertion_point(field_release:alarmpb2.AlarmResponse.header)
  
  ::alarmpb2::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AlarmResponse::set_allocated_header(::alarmpb2::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.AlarmResponse.header)
}

// -------------------------------------------------------------------

// ResponseHeader

// .alarmpb2.AlarmResponseCode code = 1;
inline void ResponseHeader::clear_code() {
  code_ = 0;
}
inline ::alarmpb2::AlarmResponseCode ResponseHeader::code() const {
  // @@protoc_insertion_point(field_get:alarmpb2.ResponseHeader.code)
  return static_cast< ::alarmpb2::AlarmResponseCode >(code_);
}
inline void ResponseHeader::set_code(::alarmpb2::AlarmResponseCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:alarmpb2.ResponseHeader.code)
}

// string error = 2;
inline void ResponseHeader::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseHeader::error() const {
  // @@protoc_insertion_point(field_get:alarmpb2.ResponseHeader.error)
  return error_.GetNoArena();
}
inline void ResponseHeader::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb2.ResponseHeader.error)
}
#if LANG_CXX11
inline void ResponseHeader::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb2.ResponseHeader.error)
}
#endif
inline void ResponseHeader::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb2.ResponseHeader.error)
}
inline void ResponseHeader::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb2.ResponseHeader.error)
}
inline ::std::string* ResponseHeader::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb2.ResponseHeader.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:alarmpb2.ResponseHeader.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseHeader::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:alarmpb2.ResponseHeader.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace alarmpb2

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::alarmpb2::AlarmResponseCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::alarmpb2::AlarmResponseCode>() {
  return ::alarmpb2::AlarmResponseCode_descriptor();
}
template <> struct is_proto_enum< ::alarmpb2::AlarmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::alarmpb2::AlarmType>() {
  return ::alarmpb2::AlarmType_descriptor();
}
template <> struct is_proto_enum< ::alarmpb2::AlarmValueCompareType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::alarmpb2::AlarmValueCompareType>() {
  return ::alarmpb2::AlarmValueCompareType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_alarmpb2_2eproto__INCLUDED
