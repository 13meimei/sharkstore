// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mspb.proto

#ifndef PROTOBUF_mspb_2eproto__INCLUDED
#define PROTOBUF_mspb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "taskpb.pb.h"
// @@protoc_insertion_point(includes)
namespace mspb {
class AddColumnRequest;
class AddColumnRequestDefaultTypeInternal;
extern AddColumnRequestDefaultTypeInternal _AddColumnRequest_default_instance_;
class AddColumnResponse;
class AddColumnResponseDefaultTypeInternal;
extern AddColumnResponseDefaultTypeInternal _AddColumnResponse_default_instance_;
class AskSplitRequest;
class AskSplitRequestDefaultTypeInternal;
extern AskSplitRequestDefaultTypeInternal _AskSplitRequest_default_instance_;
class AskSplitResponse;
class AskSplitResponseDefaultTypeInternal;
extern AskSplitResponseDefaultTypeInternal _AskSplitResponse_default_instance_;
class CreateDatabaseRequest;
class CreateDatabaseRequestDefaultTypeInternal;
extern CreateDatabaseRequestDefaultTypeInternal _CreateDatabaseRequest_default_instance_;
class CreateDatabaseResponse;
class CreateDatabaseResponseDefaultTypeInternal;
extern CreateDatabaseResponseDefaultTypeInternal _CreateDatabaseResponse_default_instance_;
class CreateTableRequest;
class CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class CreateTableResponse;
class CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GetAutoIncIdRequest;
class GetAutoIncIdRequestDefaultTypeInternal;
extern GetAutoIncIdRequestDefaultTypeInternal _GetAutoIncIdRequest_default_instance_;
class GetAutoIncIdResponse;
class GetAutoIncIdResponseDefaultTypeInternal;
extern GetAutoIncIdResponseDefaultTypeInternal _GetAutoIncIdResponse_default_instance_;
class GetColumnByIdRequest;
class GetColumnByIdRequestDefaultTypeInternal;
extern GetColumnByIdRequestDefaultTypeInternal _GetColumnByIdRequest_default_instance_;
class GetColumnByIdResponse;
class GetColumnByIdResponseDefaultTypeInternal;
extern GetColumnByIdResponseDefaultTypeInternal _GetColumnByIdResponse_default_instance_;
class GetColumnByNameRequest;
class GetColumnByNameRequestDefaultTypeInternal;
extern GetColumnByNameRequestDefaultTypeInternal _GetColumnByNameRequest_default_instance_;
class GetColumnByNameResponse;
class GetColumnByNameResponseDefaultTypeInternal;
extern GetColumnByNameResponseDefaultTypeInternal _GetColumnByNameResponse_default_instance_;
class GetColumnsRequest;
class GetColumnsRequestDefaultTypeInternal;
extern GetColumnsRequestDefaultTypeInternal _GetColumnsRequest_default_instance_;
class GetColumnsResponse;
class GetColumnsResponseDefaultTypeInternal;
extern GetColumnsResponseDefaultTypeInternal _GetColumnsResponse_default_instance_;
class GetDBRequest;
class GetDBRequestDefaultTypeInternal;
extern GetDBRequestDefaultTypeInternal _GetDBRequest_default_instance_;
class GetDBResponse;
class GetDBResponseDefaultTypeInternal;
extern GetDBResponseDefaultTypeInternal _GetDBResponse_default_instance_;
class GetMSLeaderRequest;
class GetMSLeaderRequestDefaultTypeInternal;
extern GetMSLeaderRequestDefaultTypeInternal _GetMSLeaderRequest_default_instance_;
class GetMSLeaderResponse;
class GetMSLeaderResponseDefaultTypeInternal;
extern GetMSLeaderResponseDefaultTypeInternal _GetMSLeaderResponse_default_instance_;
class GetNodeIdRequest;
class GetNodeIdRequestDefaultTypeInternal;
extern GetNodeIdRequestDefaultTypeInternal _GetNodeIdRequest_default_instance_;
class GetNodeIdResponse;
class GetNodeIdResponseDefaultTypeInternal;
extern GetNodeIdResponseDefaultTypeInternal _GetNodeIdResponse_default_instance_;
class GetNodeRequest;
class GetNodeRequestDefaultTypeInternal;
extern GetNodeRequestDefaultTypeInternal _GetNodeRequest_default_instance_;
class GetNodeResponse;
class GetNodeResponseDefaultTypeInternal;
extern GetNodeResponseDefaultTypeInternal _GetNodeResponse_default_instance_;
class GetRouteRequest;
class GetRouteRequestDefaultTypeInternal;
extern GetRouteRequestDefaultTypeInternal _GetRouteRequest_default_instance_;
class GetRouteResponse;
class GetRouteResponseDefaultTypeInternal;
extern GetRouteResponseDefaultTypeInternal _GetRouteResponse_default_instance_;
class GetTableByIdRequest;
class GetTableByIdRequestDefaultTypeInternal;
extern GetTableByIdRequestDefaultTypeInternal _GetTableByIdRequest_default_instance_;
class GetTableByIdResponse;
class GetTableByIdResponseDefaultTypeInternal;
extern GetTableByIdResponseDefaultTypeInternal _GetTableByIdResponse_default_instance_;
class GetTableRequest;
class GetTableRequestDefaultTypeInternal;
extern GetTableRequestDefaultTypeInternal _GetTableRequest_default_instance_;
class GetTableResponse;
class GetTableResponseDefaultTypeInternal;
extern GetTableResponseDefaultTypeInternal _GetTableResponse_default_instance_;
class LeaderHint;
class LeaderHintDefaultTypeInternal;
extern LeaderHintDefaultTypeInternal _LeaderHint_default_instance_;
class MSLeader;
class MSLeaderDefaultTypeInternal;
extern MSLeaderDefaultTypeInternal _MSLeader_default_instance_;
class NoLeader;
class NoLeaderDefaultTypeInternal;
extern NoLeaderDefaultTypeInternal _NoLeader_default_instance_;
class NodeHeartbeatRequest;
class NodeHeartbeatRequestDefaultTypeInternal;
extern NodeHeartbeatRequestDefaultTypeInternal _NodeHeartbeatRequest_default_instance_;
class NodeHeartbeatResponse;
class NodeHeartbeatResponseDefaultTypeInternal;
extern NodeHeartbeatResponseDefaultTypeInternal _NodeHeartbeatResponse_default_instance_;
class NodeLoginRequest;
class NodeLoginRequestDefaultTypeInternal;
extern NodeLoginRequestDefaultTypeInternal _NodeLoginRequest_default_instance_;
class NodeLoginResponse;
class NodeLoginResponseDefaultTypeInternal;
extern NodeLoginResponseDefaultTypeInternal _NodeLoginResponse_default_instance_;
class NodeStats;
class NodeStatsDefaultTypeInternal;
extern NodeStatsDefaultTypeInternal _NodeStats_default_instance_;
class RangeHeartbeatRequest;
class RangeHeartbeatRequestDefaultTypeInternal;
extern RangeHeartbeatRequestDefaultTypeInternal _RangeHeartbeatRequest_default_instance_;
class RangeHeartbeatResponse;
class RangeHeartbeatResponseDefaultTypeInternal;
extern RangeHeartbeatResponseDefaultTypeInternal _RangeHeartbeatResponse_default_instance_;
class RangeStats;
class RangeStatsDefaultTypeInternal;
extern RangeStatsDefaultTypeInternal _RangeStats_default_instance_;
class ReportSplitRequest;
class ReportSplitRequestDefaultTypeInternal;
extern ReportSplitRequestDefaultTypeInternal _ReportSplitRequest_default_instance_;
class ReportSplitResponse;
class ReportSplitResponseDefaultTypeInternal;
extern ReportSplitResponseDefaultTypeInternal _ReportSplitResponse_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class TruncateTableRequest;
class TruncateTableRequestDefaultTypeInternal;
extern TruncateTableRequestDefaultTypeInternal _TruncateTableRequest_default_instance_;
class TruncateTableResponse;
class TruncateTableResponseDefaultTypeInternal;
extern TruncateTableResponseDefaultTypeInternal _TruncateTableResponse_default_instance_;
}  // namespace mspb

namespace mspb {

namespace protobuf_mspb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mspb_2eproto

// ===================================================================

class MSLeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.MSLeader) */ {
 public:
  MSLeader();
  virtual ~MSLeader();

  MSLeader(const MSLeader& from);

  inline MSLeader& operator=(const MSLeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MSLeader(MSLeader&& from) noexcept
    : MSLeader() {
    *this = ::std::move(from);
  }

  inline MSLeader& operator=(MSLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSLeader& default_instance();

  static inline const MSLeader* internal_default_instance() {
    return reinterpret_cast<const MSLeader*>(
               &_MSLeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MSLeader* other);
  friend void swap(MSLeader& a, MSLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MSLeader* New() const PROTOBUF_FINAL { return New(NULL); }

  MSLeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MSLeader& from);
  void MergeFrom(const MSLeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MSLeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // uint64 term = 3;
  void clear_term();
  static const int kTermFieldNumber = 3;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.MSLeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 term_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMSLeaderRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetMSLeaderRequest) */ {
 public:
  GetMSLeaderRequest();
  virtual ~GetMSLeaderRequest();

  GetMSLeaderRequest(const GetMSLeaderRequest& from);

  inline GetMSLeaderRequest& operator=(const GetMSLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMSLeaderRequest(GetMSLeaderRequest&& from) noexcept
    : GetMSLeaderRequest() {
    *this = ::std::move(from);
  }

  inline GetMSLeaderRequest& operator=(GetMSLeaderRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMSLeaderRequest& default_instance();

  static inline const GetMSLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const GetMSLeaderRequest*>(
               &_GetMSLeaderRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GetMSLeaderRequest* other);
  friend void swap(GetMSLeaderRequest& a, GetMSLeaderRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMSLeaderRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetMSLeaderRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetMSLeaderRequest& from);
  void MergeFrom(const GetMSLeaderRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetMSLeaderRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetMSLeaderRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMSLeaderResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetMSLeaderResponse) */ {
 public:
  GetMSLeaderResponse();
  virtual ~GetMSLeaderResponse();

  GetMSLeaderResponse(const GetMSLeaderResponse& from);

  inline GetMSLeaderResponse& operator=(const GetMSLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMSLeaderResponse(GetMSLeaderResponse&& from) noexcept
    : GetMSLeaderResponse() {
    *this = ::std::move(from);
  }

  inline GetMSLeaderResponse& operator=(GetMSLeaderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMSLeaderResponse& default_instance();

  static inline const GetMSLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const GetMSLeaderResponse*>(
               &_GetMSLeaderResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetMSLeaderResponse* other);
  friend void swap(GetMSLeaderResponse& a, GetMSLeaderResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMSLeaderResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetMSLeaderResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetMSLeaderResponse& from);
  void MergeFrom(const GetMSLeaderResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetMSLeaderResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .mspb.MSLeader leader = 2;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 2;
  const ::mspb::MSLeader& leader() const;
  ::mspb::MSLeader* mutable_leader();
  ::mspb::MSLeader* release_leader();
  void set_allocated_leader(::mspb::MSLeader* leader);

  // @@protoc_insertion_point(class_scope:mspb.GetMSLeaderResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::mspb::MSLeader* leader_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RangeStats) */ {
 public:
  RangeStats();
  virtual ~RangeStats();

  RangeStats(const RangeStats& from);

  inline RangeStats& operator=(const RangeStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeStats(RangeStats&& from) noexcept
    : RangeStats() {
    *this = ::std::move(from);
  }

  inline RangeStats& operator=(RangeStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeStats& default_instance();

  static inline const RangeStats* internal_default_instance() {
    return reinterpret_cast<const RangeStats*>(
               &_RangeStats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RangeStats* other);
  friend void swap(RangeStats& a, RangeStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeStats* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeStats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeStats& from);
  void MergeFrom(const RangeStats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 bytes_written = 1;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 1;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // uint64 bytes_read = 2;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 2;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // uint64 keys_written = 3;
  void clear_keys_written();
  static const int kKeysWrittenFieldNumber = 3;
  ::google::protobuf::uint64 keys_written() const;
  void set_keys_written(::google::protobuf::uint64 value);

  // uint64 keys_read = 4;
  void clear_keys_read();
  static const int kKeysReadFieldNumber = 4;
  ::google::protobuf::uint64 keys_read() const;
  void set_keys_read(::google::protobuf::uint64 value);

  // uint64 approximate_size = 5;
  void clear_approximate_size();
  static const int kApproximateSizeFieldNumber = 5;
  ::google::protobuf::uint64 approximate_size() const;
  void set_approximate_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RangeStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 keys_written_;
  ::google::protobuf::uint64 keys_read_;
  ::google::protobuf::uint64 approximate_size_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RangeHeartbeatRequest) */ {
 public:
  RangeHeartbeatRequest();
  virtual ~RangeHeartbeatRequest();

  RangeHeartbeatRequest(const RangeHeartbeatRequest& from);

  inline RangeHeartbeatRequest& operator=(const RangeHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeHeartbeatRequest(RangeHeartbeatRequest&& from) noexcept
    : RangeHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline RangeHeartbeatRequest& operator=(RangeHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeHeartbeatRequest& default_instance();

  static inline const RangeHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const RangeHeartbeatRequest*>(
               &_RangeHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RangeHeartbeatRequest* other);
  friend void swap(RangeHeartbeatRequest& a, RangeHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeHeartbeatRequest& from);
  void MergeFrom(const RangeHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.PeerStatus peers_status = 8;
  int peers_status_size() const;
  void clear_peers_status();
  static const int kPeersStatusFieldNumber = 8;
  const ::metapb::PeerStatus& peers_status(int index) const;
  ::metapb::PeerStatus* mutable_peers_status(int index);
  ::metapb::PeerStatus* add_peers_status();
  ::google::protobuf::RepeatedPtrField< ::metapb::PeerStatus >*
      mutable_peers_status();
  const ::google::protobuf::RepeatedPtrField< ::metapb::PeerStatus >&
      peers_status() const;

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // .metapb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // .metapb.Peer leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* mutable_leader();
  ::metapb::Peer* release_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // .mspb.RangeStats stats = 6;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 6;
  const ::mspb::RangeStats& stats() const;
  ::mspb::RangeStats* mutable_stats();
  ::mspb::RangeStats* release_stats();
  void set_allocated_stats(::mspb::RangeStats* stats);

  // uint64 term = 7;
  void clear_term();
  static const int kTermFieldNumber = 7;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RangeHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::PeerStatus > peers_status_;
  ::mspb::RequestHeader* header_;
  ::metapb::Range* range_;
  ::metapb::Peer* leader_;
  ::mspb::RangeStats* stats_;
  ::google::protobuf::uint64 term_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RangeHeartbeatResponse) */ {
 public:
  RangeHeartbeatResponse();
  virtual ~RangeHeartbeatResponse();

  RangeHeartbeatResponse(const RangeHeartbeatResponse& from);

  inline RangeHeartbeatResponse& operator=(const RangeHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeHeartbeatResponse(RangeHeartbeatResponse&& from) noexcept
    : RangeHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline RangeHeartbeatResponse& operator=(RangeHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeHeartbeatResponse& default_instance();

  static inline const RangeHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const RangeHeartbeatResponse*>(
               &_RangeHeartbeatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RangeHeartbeatResponse* other);
  friend void swap(RangeHeartbeatResponse& a, RangeHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeHeartbeatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeHeartbeatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeHeartbeatResponse& from);
  void MergeFrom(const RangeHeartbeatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.RangeEpoch epoch = 3;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 3;
  const ::metapb::RangeEpoch& epoch() const;
  ::metapb::RangeEpoch* mutable_epoch();
  ::metapb::RangeEpoch* release_epoch();
  void set_allocated_epoch(::metapb::RangeEpoch* epoch);

  // .metapb.Peer target_peer = 4;
  bool has_target_peer() const;
  void clear_target_peer();
  static const int kTargetPeerFieldNumber = 4;
  const ::metapb::Peer& target_peer() const;
  ::metapb::Peer* mutable_target_peer();
  ::metapb::Peer* release_target_peer();
  void set_allocated_target_peer(::metapb::Peer* target_peer);

  // .taskpb.Task task = 5;
  bool has_task() const;
  void clear_task();
  static const int kTaskFieldNumber = 5;
  const ::taskpb::Task& task() const;
  ::taskpb::Task* mutable_task();
  ::taskpb::Task* release_task();
  void set_allocated_task(::taskpb::Task* task);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RangeHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::RangeEpoch* epoch_;
  ::metapb::Peer* target_peer_;
  ::taskpb::Task* task_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeStats) */ {
 public:
  NodeStats();
  virtual ~NodeStats();

  NodeStats(const NodeStats& from);

  inline NodeStats& operator=(const NodeStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeStats(NodeStats&& from) noexcept
    : NodeStats() {
    *this = ::std::move(from);
  }

  inline NodeStats& operator=(NodeStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStats& default_instance();

  static inline const NodeStats* internal_default_instance() {
    return reinterpret_cast<const NodeStats*>(
               &_NodeStats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(NodeStats* other);
  friend void swap(NodeStats& a, NodeStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeStats* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeStats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeStats& from);
  void MergeFrom(const NodeStats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 range_count = 1;
  void clear_range_count();
  static const int kRangeCountFieldNumber = 1;
  ::google::protobuf::uint32 range_count() const;
  void set_range_count(::google::protobuf::uint32 value);

  // uint32 range_split_count = 2;
  void clear_range_split_count();
  static const int kRangeSplitCountFieldNumber = 2;
  ::google::protobuf::uint32 range_split_count() const;
  void set_range_split_count(::google::protobuf::uint32 value);

  // uint32 sending_snap_count = 3;
  void clear_sending_snap_count();
  static const int kSendingSnapCountFieldNumber = 3;
  ::google::protobuf::uint32 sending_snap_count() const;
  void set_sending_snap_count(::google::protobuf::uint32 value);

  // uint32 receiving_snap_count = 4;
  void clear_receiving_snap_count();
  static const int kReceivingSnapCountFieldNumber = 4;
  ::google::protobuf::uint32 receiving_snap_count() const;
  void set_receiving_snap_count(::google::protobuf::uint32 value);

  // uint32 applying_snap_count = 5;
  void clear_applying_snap_count();
  static const int kApplyingSnapCountFieldNumber = 5;
  ::google::protobuf::uint32 applying_snap_count() const;
  void set_applying_snap_count(::google::protobuf::uint32 value);

  // uint32 range_leader_count = 6;
  void clear_range_leader_count();
  static const int kRangeLeaderCountFieldNumber = 6;
  ::google::protobuf::uint32 range_leader_count() const;
  void set_range_leader_count(::google::protobuf::uint32 value);

  // uint64 capacity = 7;
  void clear_capacity();
  static const int kCapacityFieldNumber = 7;
  ::google::protobuf::uint64 capacity() const;
  void set_capacity(::google::protobuf::uint64 value);

  // uint64 used_size = 8;
  void clear_used_size();
  static const int kUsedSizeFieldNumber = 8;
  ::google::protobuf::uint64 used_size() const;
  void set_used_size(::google::protobuf::uint64 value);

  // uint64 available = 9;
  void clear_available();
  static const int kAvailableFieldNumber = 9;
  ::google::protobuf::uint64 available() const;
  void set_available(::google::protobuf::uint64 value);

  // uint64 bytes_written = 10;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 10;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // uint64 keys_written = 11;
  void clear_keys_written();
  static const int kKeysWrittenFieldNumber = 11;
  ::google::protobuf::uint64 keys_written() const;
  void set_keys_written(::google::protobuf::uint64 value);

  // uint64 bytes_read = 12;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 12;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // uint64 keys_read = 13;
  void clear_keys_read();
  static const int kKeysReadFieldNumber = 13;
  ::google::protobuf::uint64 keys_read() const;
  void set_keys_read(::google::protobuf::uint64 value);

  // bool is_busy = 14;
  void clear_is_busy();
  static const int kIsBusyFieldNumber = 14;
  bool is_busy() const;
  void set_is_busy(bool value);

  // uint32 start = 15;
  void clear_start();
  static const int kStartFieldNumber = 15;
  ::google::protobuf::uint32 start() const;
  void set_start(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.NodeStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 range_count_;
  ::google::protobuf::uint32 range_split_count_;
  ::google::protobuf::uint32 sending_snap_count_;
  ::google::protobuf::uint32 receiving_snap_count_;
  ::google::protobuf::uint32 applying_snap_count_;
  ::google::protobuf::uint32 range_leader_count_;
  ::google::protobuf::uint64 capacity_;
  ::google::protobuf::uint64 used_size_;
  ::google::protobuf::uint64 available_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 keys_written_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 keys_read_;
  bool is_busy_;
  ::google::protobuf::uint32 start_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeHeartbeatRequest) */ {
 public:
  NodeHeartbeatRequest();
  virtual ~NodeHeartbeatRequest();

  NodeHeartbeatRequest(const NodeHeartbeatRequest& from);

  inline NodeHeartbeatRequest& operator=(const NodeHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeHeartbeatRequest(NodeHeartbeatRequest&& from) noexcept
    : NodeHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline NodeHeartbeatRequest& operator=(NodeHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeHeartbeatRequest& default_instance();

  static inline const NodeHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const NodeHeartbeatRequest*>(
               &_NodeHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(NodeHeartbeatRequest* other);
  friend void swap(NodeHeartbeatRequest& a, NodeHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeHeartbeatRequest& from);
  void MergeFrom(const NodeHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 isolated_replicas = 4;
  int isolated_replicas_size() const;
  void clear_isolated_replicas();
  static const int kIsolatedReplicasFieldNumber = 4;
  ::google::protobuf::uint64 isolated_replicas(int index) const;
  void set_isolated_replicas(int index, ::google::protobuf::uint64 value);
  void add_isolated_replicas(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      isolated_replicas() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_isolated_replicas();

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // .mspb.NodeStats stats = 3;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 3;
  const ::mspb::NodeStats& stats() const;
  ::mspb::NodeStats* mutable_stats();
  ::mspb::NodeStats* release_stats();
  void set_allocated_stats(::mspb::NodeStats* stats);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.NodeHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > isolated_replicas_;
  mutable int _isolated_replicas_cached_byte_size_;
  ::mspb::RequestHeader* header_;
  ::mspb::NodeStats* stats_;
  ::google::protobuf::uint64 node_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeHeartbeatResponse) */ {
 public:
  NodeHeartbeatResponse();
  virtual ~NodeHeartbeatResponse();

  NodeHeartbeatResponse(const NodeHeartbeatResponse& from);

  inline NodeHeartbeatResponse& operator=(const NodeHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeHeartbeatResponse(NodeHeartbeatResponse&& from) noexcept
    : NodeHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline NodeHeartbeatResponse& operator=(NodeHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeHeartbeatResponse& default_instance();

  static inline const NodeHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const NodeHeartbeatResponse*>(
               &_NodeHeartbeatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(NodeHeartbeatResponse* other);
  friend void swap(NodeHeartbeatResponse& a, NodeHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeHeartbeatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeHeartbeatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeHeartbeatResponse& from);
  void MergeFrom(const NodeHeartbeatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 delete_replicas = 3;
  int delete_replicas_size() const;
  void clear_delete_replicas();
  static const int kDeleteReplicasFieldNumber = 3;
  ::google::protobuf::uint64 delete_replicas(int index) const;
  void set_delete_replicas(int index, ::google::protobuf::uint64 value);
  void add_delete_replicas(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      delete_replicas() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_delete_replicas();

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.NodeHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > delete_replicas_;
  mutable int _delete_replicas_cached_byte_size_;
  ::mspb::ResponseHeader* header_;
  ::google::protobuf::uint64 node_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.AskSplitRequest) */ {
 public:
  AskSplitRequest();
  virtual ~AskSplitRequest();

  AskSplitRequest(const AskSplitRequest& from);

  inline AskSplitRequest& operator=(const AskSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskSplitRequest(AskSplitRequest&& from) noexcept
    : AskSplitRequest() {
    *this = ::std::move(from);
  }

  inline AskSplitRequest& operator=(AskSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskSplitRequest& default_instance();

  static inline const AskSplitRequest* internal_default_instance() {
    return reinterpret_cast<const AskSplitRequest*>(
               &_AskSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(AskSplitRequest* other);
  friend void swap(AskSplitRequest& a, AskSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AskSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskSplitRequest& from);
  void MergeFrom(const AskSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes split_key = 3;
  void clear_split_key();
  static const int kSplitKeyFieldNumber = 3;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  #if LANG_CXX11
  void set_split_key(::std::string&& value);
  #endif
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // .metapb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // bool force = 4;
  void clear_force();
  static const int kForceFieldNumber = 4;
  bool force() const;
  void set_force(bool value);

  // @@protoc_insertion_point(class_scope:mspb.AskSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  ::mspb::RequestHeader* header_;
  ::metapb::Range* range_;
  bool force_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.AskSplitResponse) */ {
 public:
  AskSplitResponse();
  virtual ~AskSplitResponse();

  AskSplitResponse(const AskSplitResponse& from);

  inline AskSplitResponse& operator=(const AskSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskSplitResponse(AskSplitResponse&& from) noexcept
    : AskSplitResponse() {
    *this = ::std::move(from);
  }

  inline AskSplitResponse& operator=(AskSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskSplitResponse& default_instance();

  static inline const AskSplitResponse* internal_default_instance() {
    return reinterpret_cast<const AskSplitResponse*>(
               &_AskSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AskSplitResponse* other);
  friend void swap(AskSplitResponse& a, AskSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AskSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskSplitResponse& from);
  void MergeFrom(const AskSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 new_peer_ids = 4;
  int new_peer_ids_size() const;
  void clear_new_peer_ids();
  static const int kNewPeerIdsFieldNumber = 4;
  ::google::protobuf::uint64 new_peer_ids(int index) const;
  void set_new_peer_ids(int index, ::google::protobuf::uint64 value);
  void add_new_peer_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      new_peer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_new_peer_ids();

  // bytes split_key = 5;
  void clear_split_key();
  static const int kSplitKeyFieldNumber = 5;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  #if LANG_CXX11
  void set_split_key(::std::string&& value);
  #endif
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // uint64 new_range_id = 3;
  void clear_new_range_id();
  static const int kNewRangeIdFieldNumber = 3;
  ::google::protobuf::uint64 new_range_id() const;
  void set_new_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.AskSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > new_peer_ids_;
  mutable int _new_peer_ids_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  ::mspb::ResponseHeader* header_;
  ::metapb::Range* range_;
  ::google::protobuf::uint64 new_range_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.ReportSplitRequest) */ {
 public:
  ReportSplitRequest();
  virtual ~ReportSplitRequest();

  ReportSplitRequest(const ReportSplitRequest& from);

  inline ReportSplitRequest& operator=(const ReportSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportSplitRequest(ReportSplitRequest&& from) noexcept
    : ReportSplitRequest() {
    *this = ::std::move(from);
  }

  inline ReportSplitRequest& operator=(ReportSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportSplitRequest& default_instance();

  static inline const ReportSplitRequest* internal_default_instance() {
    return reinterpret_cast<const ReportSplitRequest*>(
               &_ReportSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ReportSplitRequest* other);
  friend void swap(ReportSplitRequest& a, ReportSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportSplitRequest& from);
  void MergeFrom(const ReportSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // .metapb.Range left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  const ::metapb::Range& left() const;
  ::metapb::Range* mutable_left();
  ::metapb::Range* release_left();
  void set_allocated_left(::metapb::Range* left);

  // .metapb.Range right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  const ::metapb::Range& right() const;
  ::metapb::Range* mutable_right();
  ::metapb::Range* release_right();
  void set_allocated_right(::metapb::Range* right);

  // @@protoc_insertion_point(class_scope:mspb.ReportSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::metapb::Range* left_;
  ::metapb::Range* right_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.ReportSplitResponse) */ {
 public:
  ReportSplitResponse();
  virtual ~ReportSplitResponse();

  ReportSplitResponse(const ReportSplitResponse& from);

  inline ReportSplitResponse& operator=(const ReportSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportSplitResponse(ReportSplitResponse&& from) noexcept
    : ReportSplitResponse() {
    *this = ::std::move(from);
  }

  inline ReportSplitResponse& operator=(ReportSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportSplitResponse& default_instance();

  static inline const ReportSplitResponse* internal_default_instance() {
    return reinterpret_cast<const ReportSplitResponse*>(
               &_ReportSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ReportSplitResponse* other);
  friend void swap(ReportSplitResponse& a, ReportSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportSplitResponse& from);
  void MergeFrom(const ReportSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.ReportSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeLoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeLoginRequest) */ {
 public:
  NodeLoginRequest();
  virtual ~NodeLoginRequest();

  NodeLoginRequest(const NodeLoginRequest& from);

  inline NodeLoginRequest& operator=(const NodeLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeLoginRequest(NodeLoginRequest&& from) noexcept
    : NodeLoginRequest() {
    *this = ::std::move(from);
  }

  inline NodeLoginRequest& operator=(NodeLoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeLoginRequest& default_instance();

  static inline const NodeLoginRequest* internal_default_instance() {
    return reinterpret_cast<const NodeLoginRequest*>(
               &_NodeLoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(NodeLoginRequest* other);
  friend void swap(NodeLoginRequest& a, NodeLoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeLoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeLoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeLoginRequest& from);
  void MergeFrom(const NodeLoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeLoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.NodeLoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 node_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeLoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeLoginResponse) */ {
 public:
  NodeLoginResponse();
  virtual ~NodeLoginResponse();

  NodeLoginResponse(const NodeLoginResponse& from);

  inline NodeLoginResponse& operator=(const NodeLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeLoginResponse(NodeLoginResponse&& from) noexcept
    : NodeLoginResponse() {
    *this = ::std::move(from);
  }

  inline NodeLoginResponse& operator=(NodeLoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeLoginResponse& default_instance();

  static inline const NodeLoginResponse* internal_default_instance() {
    return reinterpret_cast<const NodeLoginResponse*>(
               &_NodeLoginResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(NodeLoginResponse* other);
  friend void swap(NodeLoginResponse& a, NodeLoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeLoginResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeLoginResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeLoginResponse& from);
  void MergeFrom(const NodeLoginResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeLoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.NodeLoginResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeIdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeIdRequest) */ {
 public:
  GetNodeIdRequest();
  virtual ~GetNodeIdRequest();

  GetNodeIdRequest(const GetNodeIdRequest& from);

  inline GetNodeIdRequest& operator=(const GetNodeIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeIdRequest(GetNodeIdRequest&& from) noexcept
    : GetNodeIdRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeIdRequest& operator=(GetNodeIdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeIdRequest& default_instance();

  static inline const GetNodeIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeIdRequest*>(
               &_GetNodeIdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GetNodeIdRequest* other);
  friend void swap(GetNodeIdRequest& a, GetNodeIdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeIdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeIdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeIdRequest& from);
  void MergeFrom(const GetNodeIdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint32 server_port = 2;
  void clear_server_port();
  static const int kServerPortFieldNumber = 2;
  ::google::protobuf::uint32 server_port() const;
  void set_server_port(::google::protobuf::uint32 value);

  // uint32 raft_port = 3;
  void clear_raft_port();
  static const int kRaftPortFieldNumber = 3;
  ::google::protobuf::uint32 raft_port() const;
  void set_raft_port(::google::protobuf::uint32 value);

  // uint32 admin_port = 4;
  void clear_admin_port();
  static const int kAdminPortFieldNumber = 4;
  ::google::protobuf::uint32 admin_port() const;
  void set_admin_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeIdRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint32 server_port_;
  ::google::protobuf::uint32 raft_port_;
  ::google::protobuf::uint32 admin_port_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeIdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeIdResponse) */ {
 public:
  GetNodeIdResponse();
  virtual ~GetNodeIdResponse();

  GetNodeIdResponse(const GetNodeIdResponse& from);

  inline GetNodeIdResponse& operator=(const GetNodeIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeIdResponse(GetNodeIdResponse&& from) noexcept
    : GetNodeIdResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeIdResponse& operator=(GetNodeIdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeIdResponse& default_instance();

  static inline const GetNodeIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeIdResponse*>(
               &_GetNodeIdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetNodeIdResponse* other);
  friend void swap(GetNodeIdResponse& a, GetNodeIdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeIdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeIdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeIdResponse& from);
  void MergeFrom(const GetNodeIdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // bool clearup = 3;
  void clear_clearup();
  static const int kClearupFieldNumber = 3;
  bool clearup() const;
  void set_clearup(bool value);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeIdResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::google::protobuf::uint64 node_id_;
  bool clearup_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRouteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetRouteRequest) */ {
 public:
  GetRouteRequest();
  virtual ~GetRouteRequest();

  GetRouteRequest(const GetRouteRequest& from);

  inline GetRouteRequest& operator=(const GetRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRouteRequest(GetRouteRequest&& from) noexcept
    : GetRouteRequest() {
    *this = ::std::move(from);
  }

  inline GetRouteRequest& operator=(GetRouteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRouteRequest& default_instance();

  static inline const GetRouteRequest* internal_default_instance() {
    return reinterpret_cast<const GetRouteRequest*>(
               &_GetRouteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(GetRouteRequest* other);
  friend void swap(GetRouteRequest& a, GetRouteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRouteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRouteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRouteRequest& from);
  void MergeFrom(const GetRouteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRouteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 4;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetRouteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRouteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetRouteResponse) */ {
 public:
  GetRouteResponse();
  virtual ~GetRouteResponse();

  GetRouteResponse(const GetRouteResponse& from);

  inline GetRouteResponse& operator=(const GetRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRouteResponse(GetRouteResponse&& from) noexcept
    : GetRouteResponse() {
    *this = ::std::move(from);
  }

  inline GetRouteResponse& operator=(GetRouteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRouteResponse& default_instance();

  static inline const GetRouteResponse* internal_default_instance() {
    return reinterpret_cast<const GetRouteResponse*>(
               &_GetRouteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(GetRouteResponse* other);
  friend void swap(GetRouteResponse& a, GetRouteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRouteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRouteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRouteResponse& from);
  void MergeFrom(const GetRouteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRouteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Route routes = 2;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 2;
  const ::metapb::Route& routes(int index) const;
  ::metapb::Route* mutable_routes(int index);
  ::metapb::Route* add_routes();
  ::google::protobuf::RepeatedPtrField< ::metapb::Route >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Route >&
      routes() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetRouteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Route > routes_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeRequest) */ {
 public:
  GetNodeRequest();
  virtual ~GetNodeRequest();

  GetNodeRequest(const GetNodeRequest& from);

  inline GetNodeRequest& operator=(const GetNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeRequest(GetNodeRequest&& from) noexcept
    : GetNodeRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeRequest& operator=(GetNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeRequest& default_instance();

  static inline const GetNodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeRequest*>(
               &_GetNodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(GetNodeRequest* other);
  friend void swap(GetNodeRequest& a, GetNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeRequest& from);
  void MergeFrom(const GetNodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeResponse) */ {
 public:
  GetNodeResponse();
  virtual ~GetNodeResponse();

  GetNodeResponse(const GetNodeResponse& from);

  inline GetNodeResponse& operator=(const GetNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeResponse(GetNodeResponse&& from) noexcept
    : GetNodeResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeResponse& operator=(GetNodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeResponse& default_instance();

  static inline const GetNodeResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeResponse*>(
               &_GetNodeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(GetNodeResponse* other);
  friend void swap(GetNodeResponse& a, GetNodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeResponse& from);
  void MergeFrom(const GetNodeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::metapb::Node& node() const;
  ::metapb::Node* mutable_node();
  ::metapb::Node* release_node();
  void set_allocated_node(::metapb::Node* node);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::Node* node_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDBRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetDBRequest) */ {
 public:
  GetDBRequest();
  virtual ~GetDBRequest();

  GetDBRequest(const GetDBRequest& from);

  inline GetDBRequest& operator=(const GetDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDBRequest(GetDBRequest&& from) noexcept
    : GetDBRequest() {
    *this = ::std::move(from);
  }

  inline GetDBRequest& operator=(GetDBRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDBRequest& default_instance();

  static inline const GetDBRequest* internal_default_instance() {
    return reinterpret_cast<const GetDBRequest*>(
               &_GetDBRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(GetDBRequest* other);
  friend void swap(GetDBRequest& a, GetDBRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDBRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetDBRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetDBRequest& from);
  void MergeFrom(const GetDBRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetDBRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetDBRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDBResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetDBResponse) */ {
 public:
  GetDBResponse();
  virtual ~GetDBResponse();

  GetDBResponse(const GetDBResponse& from);

  inline GetDBResponse& operator=(const GetDBResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDBResponse(GetDBResponse&& from) noexcept
    : GetDBResponse() {
    *this = ::std::move(from);
  }

  inline GetDBResponse& operator=(GetDBResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDBResponse& default_instance();

  static inline const GetDBResponse* internal_default_instance() {
    return reinterpret_cast<const GetDBResponse*>(
               &_GetDBResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(GetDBResponse* other);
  friend void swap(GetDBResponse& a, GetDBResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDBResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetDBResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetDBResponse& from);
  void MergeFrom(const GetDBResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetDBResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.DataBase db = 2;
  bool has_db() const;
  void clear_db();
  static const int kDbFieldNumber = 2;
  const ::metapb::DataBase& db() const;
  ::metapb::DataBase* mutable_db();
  ::metapb::DataBase* release_db();
  void set_allocated_db(::metapb::DataBase* db);

  // @@protoc_insertion_point(class_scope:mspb.GetDBResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::DataBase* db_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTableRequest) */ {
 public:
  GetTableRequest();
  virtual ~GetTableRequest();

  GetTableRequest(const GetTableRequest& from);

  inline GetTableRequest& operator=(const GetTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTableRequest(GetTableRequest&& from) noexcept
    : GetTableRequest() {
    *this = ::std::move(from);
  }

  inline GetTableRequest& operator=(GetTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTableRequest& default_instance();

  static inline const GetTableRequest* internal_default_instance() {
    return reinterpret_cast<const GetTableRequest*>(
               &_GetTableRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(GetTableRequest* other);
  friend void swap(GetTableRequest& a, GetTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTableRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTableRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTableRequest& from);
  void MergeFrom(const GetTableRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 2;
  void clear_db_name();
  static const int kDbNameFieldNumber = 2;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string table_name = 3;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTableByIdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTableByIdRequest) */ {
 public:
  GetTableByIdRequest();
  virtual ~GetTableByIdRequest();

  GetTableByIdRequest(const GetTableByIdRequest& from);

  inline GetTableByIdRequest& operator=(const GetTableByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTableByIdRequest(GetTableByIdRequest&& from) noexcept
    : GetTableByIdRequest() {
    *this = ::std::move(from);
  }

  inline GetTableByIdRequest& operator=(GetTableByIdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTableByIdRequest& default_instance();

  static inline const GetTableByIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetTableByIdRequest*>(
               &_GetTableByIdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(GetTableByIdRequest* other);
  friend void swap(GetTableByIdRequest& a, GetTableByIdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTableByIdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTableByIdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTableByIdRequest& from);
  void MergeFrom(const GetTableByIdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTableByIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetTableByIdRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTableResponse) */ {
 public:
  GetTableResponse();
  virtual ~GetTableResponse();

  GetTableResponse(const GetTableResponse& from);

  inline GetTableResponse& operator=(const GetTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTableResponse(GetTableResponse&& from) noexcept
    : GetTableResponse() {
    *this = ::std::move(from);
  }

  inline GetTableResponse& operator=(GetTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTableResponse& default_instance();

  static inline const GetTableResponse* internal_default_instance() {
    return reinterpret_cast<const GetTableResponse*>(
               &_GetTableResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(GetTableResponse* other);
  friend void swap(GetTableResponse& a, GetTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTableResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTableResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTableResponse& from);
  void MergeFrom(const GetTableResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.Table table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  const ::metapb::Table& table() const;
  ::metapb::Table* mutable_table();
  ::metapb::Table* release_table();
  void set_allocated_table(::metapb::Table* table);

  // @@protoc_insertion_point(class_scope:mspb.GetTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::Table* table_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTableByIdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTableByIdResponse) */ {
 public:
  GetTableByIdResponse();
  virtual ~GetTableByIdResponse();

  GetTableByIdResponse(const GetTableByIdResponse& from);

  inline GetTableByIdResponse& operator=(const GetTableByIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTableByIdResponse(GetTableByIdResponse&& from) noexcept
    : GetTableByIdResponse() {
    *this = ::std::move(from);
  }

  inline GetTableByIdResponse& operator=(GetTableByIdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTableByIdResponse& default_instance();

  static inline const GetTableByIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetTableByIdResponse*>(
               &_GetTableByIdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(GetTableByIdResponse* other);
  friend void swap(GetTableByIdResponse& a, GetTableByIdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTableByIdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTableByIdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTableByIdResponse& from);
  void MergeFrom(const GetTableByIdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTableByIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.Table table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  const ::metapb::Table& table() const;
  ::metapb::Table* mutable_table();
  ::metapb::Table* release_table();
  void set_allocated_table(::metapb::Table* table);

  // @@protoc_insertion_point(class_scope:mspb.GetTableByIdResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::Table* table_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnsRequest) */ {
 public:
  GetColumnsRequest();
  virtual ~GetColumnsRequest();

  GetColumnsRequest(const GetColumnsRequest& from);

  inline GetColumnsRequest& operator=(const GetColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnsRequest(GetColumnsRequest&& from) noexcept
    : GetColumnsRequest() {
    *this = ::std::move(from);
  }

  inline GetColumnsRequest& operator=(GetColumnsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsRequest& default_instance();

  static inline const GetColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const GetColumnsRequest*>(
               &_GetColumnsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(GetColumnsRequest* other);
  friend void swap(GetColumnsRequest& a, GetColumnsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnsRequest& from);
  void MergeFrom(const GetColumnsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnsResponse) */ {
 public:
  GetColumnsResponse();
  virtual ~GetColumnsResponse();

  GetColumnsResponse(const GetColumnsResponse& from);

  inline GetColumnsResponse& operator=(const GetColumnsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnsResponse(GetColumnsResponse&& from) noexcept
    : GetColumnsResponse() {
    *this = ::std::move(from);
  }

  inline GetColumnsResponse& operator=(GetColumnsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsResponse& default_instance();

  static inline const GetColumnsResponse* internal_default_instance() {
    return reinterpret_cast<const GetColumnsResponse*>(
               &_GetColumnsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(GetColumnsResponse* other);
  friend void swap(GetColumnsResponse& a, GetColumnsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnsResponse& from);
  void MergeFrom(const GetColumnsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Column columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::metapb::Column& columns(int index) const;
  ::metapb::Column* mutable_columns(int index);
  ::metapb::Column* add_columns();
  ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
      columns() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Column > columns_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnByNameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnByNameRequest) */ {
 public:
  GetColumnByNameRequest();
  virtual ~GetColumnByNameRequest();

  GetColumnByNameRequest(const GetColumnByNameRequest& from);

  inline GetColumnByNameRequest& operator=(const GetColumnByNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnByNameRequest(GetColumnByNameRequest&& from) noexcept
    : GetColumnByNameRequest() {
    *this = ::std::move(from);
  }

  inline GetColumnByNameRequest& operator=(GetColumnByNameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnByNameRequest& default_instance();

  static inline const GetColumnByNameRequest* internal_default_instance() {
    return reinterpret_cast<const GetColumnByNameRequest*>(
               &_GetColumnByNameRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(GetColumnByNameRequest* other);
  friend void swap(GetColumnByNameRequest& a, GetColumnByNameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnByNameRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnByNameRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnByNameRequest& from);
  void MergeFrom(const GetColumnByNameRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnByNameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string col_name = 4;
  void clear_col_name();
  static const int kColNameFieldNumber = 4;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnByNameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnByNameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnByNameResponse) */ {
 public:
  GetColumnByNameResponse();
  virtual ~GetColumnByNameResponse();

  GetColumnByNameResponse(const GetColumnByNameResponse& from);

  inline GetColumnByNameResponse& operator=(const GetColumnByNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnByNameResponse(GetColumnByNameResponse&& from) noexcept
    : GetColumnByNameResponse() {
    *this = ::std::move(from);
  }

  inline GetColumnByNameResponse& operator=(GetColumnByNameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnByNameResponse& default_instance();

  static inline const GetColumnByNameResponse* internal_default_instance() {
    return reinterpret_cast<const GetColumnByNameResponse*>(
               &_GetColumnByNameResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(GetColumnByNameResponse* other);
  friend void swap(GetColumnByNameResponse& a, GetColumnByNameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnByNameResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnByNameResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnByNameResponse& from);
  void MergeFrom(const GetColumnByNameResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnByNameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.Column column = 2;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 2;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnByNameResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::Column* column_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnByIdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnByIdRequest) */ {
 public:
  GetColumnByIdRequest();
  virtual ~GetColumnByIdRequest();

  GetColumnByIdRequest(const GetColumnByIdRequest& from);

  inline GetColumnByIdRequest& operator=(const GetColumnByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnByIdRequest(GetColumnByIdRequest&& from) noexcept
    : GetColumnByIdRequest() {
    *this = ::std::move(from);
  }

  inline GetColumnByIdRequest& operator=(GetColumnByIdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnByIdRequest& default_instance();

  static inline const GetColumnByIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetColumnByIdRequest*>(
               &_GetColumnByIdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(GetColumnByIdRequest* other);
  friend void swap(GetColumnByIdRequest& a, GetColumnByIdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnByIdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnByIdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnByIdRequest& from);
  void MergeFrom(const GetColumnByIdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnByIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // uint64 col_id = 4;
  void clear_col_id();
  static const int kColIdFieldNumber = 4;
  ::google::protobuf::uint64 col_id() const;
  void set_col_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnByIdRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  ::google::protobuf::uint64 col_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnByIdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnByIdResponse) */ {
 public:
  GetColumnByIdResponse();
  virtual ~GetColumnByIdResponse();

  GetColumnByIdResponse(const GetColumnByIdResponse& from);

  inline GetColumnByIdResponse& operator=(const GetColumnByIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnByIdResponse(GetColumnByIdResponse&& from) noexcept
    : GetColumnByIdResponse() {
    *this = ::std::move(from);
  }

  inline GetColumnByIdResponse& operator=(GetColumnByIdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnByIdResponse& default_instance();

  static inline const GetColumnByIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetColumnByIdResponse*>(
               &_GetColumnByIdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(GetColumnByIdResponse* other);
  friend void swap(GetColumnByIdResponse& a, GetColumnByIdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnByIdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnByIdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnByIdResponse& from);
  void MergeFrom(const GetColumnByIdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnByIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .metapb.Column column = 2;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 2;
  const ::metapb::Column& column() const;
  ::metapb::Column* mutable_column();
  ::metapb::Column* release_column();
  void set_allocated_column(::metapb::Column* column);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnByIdResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::metapb::Column* column_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddColumnRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.AddColumnRequest) */ {
 public:
  AddColumnRequest();
  virtual ~AddColumnRequest();

  AddColumnRequest(const AddColumnRequest& from);

  inline AddColumnRequest& operator=(const AddColumnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddColumnRequest(AddColumnRequest&& from) noexcept
    : AddColumnRequest() {
    *this = ::std::move(from);
  }

  inline AddColumnRequest& operator=(AddColumnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddColumnRequest& default_instance();

  static inline const AddColumnRequest* internal_default_instance() {
    return reinterpret_cast<const AddColumnRequest*>(
               &_AddColumnRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(AddColumnRequest* other);
  friend void swap(AddColumnRequest& a, AddColumnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddColumnRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddColumnRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddColumnRequest& from);
  void MergeFrom(const AddColumnRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddColumnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Column columns = 4;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 4;
  const ::metapb::Column& columns(int index) const;
  ::metapb::Column* mutable_columns(int index);
  ::metapb::Column* add_columns();
  ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
      columns() const;

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.AddColumnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Column > columns_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddColumnResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.AddColumnResponse) */ {
 public:
  AddColumnResponse();
  virtual ~AddColumnResponse();

  AddColumnResponse(const AddColumnResponse& from);

  inline AddColumnResponse& operator=(const AddColumnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddColumnResponse(AddColumnResponse&& from) noexcept
    : AddColumnResponse() {
    *this = ::std::move(from);
  }

  inline AddColumnResponse& operator=(AddColumnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddColumnResponse& default_instance();

  static inline const AddColumnResponse* internal_default_instance() {
    return reinterpret_cast<const AddColumnResponse*>(
               &_AddColumnResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(AddColumnResponse* other);
  friend void swap(AddColumnResponse& a, AddColumnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddColumnResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AddColumnResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddColumnResponse& from);
  void MergeFrom(const AddColumnResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddColumnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Column columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::metapb::Column& columns(int index) const;
  ::metapb::Column* mutable_columns(int index);
  ::metapb::Column* add_columns();
  ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
      columns() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.AddColumnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Column > columns_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TruncateTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.TruncateTableRequest) */ {
 public:
  TruncateTableRequest();
  virtual ~TruncateTableRequest();

  TruncateTableRequest(const TruncateTableRequest& from);

  inline TruncateTableRequest& operator=(const TruncateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TruncateTableRequest(TruncateTableRequest&& from) noexcept
    : TruncateTableRequest() {
    *this = ::std::move(from);
  }

  inline TruncateTableRequest& operator=(TruncateTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateTableRequest& default_instance();

  static inline const TruncateTableRequest* internal_default_instance() {
    return reinterpret_cast<const TruncateTableRequest*>(
               &_TruncateTableRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(TruncateTableRequest* other);
  friend void swap(TruncateTableRequest& a, TruncateTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TruncateTableRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TruncateTableRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TruncateTableRequest& from);
  void MergeFrom(const TruncateTableRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TruncateTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.TruncateTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TruncateTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.TruncateTableResponse) */ {
 public:
  TruncateTableResponse();
  virtual ~TruncateTableResponse();

  TruncateTableResponse(const TruncateTableResponse& from);

  inline TruncateTableResponse& operator=(const TruncateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TruncateTableResponse(TruncateTableResponse&& from) noexcept
    : TruncateTableResponse() {
    *this = ::std::move(from);
  }

  inline TruncateTableResponse& operator=(TruncateTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateTableResponse& default_instance();

  static inline const TruncateTableResponse* internal_default_instance() {
    return reinterpret_cast<const TruncateTableResponse*>(
               &_TruncateTableResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(TruncateTableResponse* other);
  friend void swap(TruncateTableResponse& a, TruncateTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TruncateTableResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TruncateTableResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TruncateTableResponse& from);
  void MergeFrom(const TruncateTableResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TruncateTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.TruncateTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateDatabaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateDatabaseRequest) */ {
 public:
  CreateDatabaseRequest();
  virtual ~CreateDatabaseRequest();

  CreateDatabaseRequest(const CreateDatabaseRequest& from);

  inline CreateDatabaseRequest& operator=(const CreateDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateDatabaseRequest(CreateDatabaseRequest&& from) noexcept
    : CreateDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseRequest& operator=(CreateDatabaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDatabaseRequest& default_instance();

  static inline const CreateDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseRequest*>(
               &_CreateDatabaseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(CreateDatabaseRequest* other);
  friend void swap(CreateDatabaseRequest& a, CreateDatabaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateDatabaseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateDatabaseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateDatabaseRequest& from);
  void MergeFrom(const CreateDatabaseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateDatabaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 2;
  void clear_db_name();
  static const int kDbNameFieldNumber = 2;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.CreateDatabaseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateDatabaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateDatabaseResponse) */ {
 public:
  CreateDatabaseResponse();
  virtual ~CreateDatabaseResponse();

  CreateDatabaseResponse(const CreateDatabaseResponse& from);

  inline CreateDatabaseResponse& operator=(const CreateDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateDatabaseResponse(CreateDatabaseResponse&& from) noexcept
    : CreateDatabaseResponse() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseResponse& operator=(CreateDatabaseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDatabaseResponse& default_instance();

  static inline const CreateDatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseResponse*>(
               &_CreateDatabaseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(CreateDatabaseResponse* other);
  friend void swap(CreateDatabaseResponse& a, CreateDatabaseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateDatabaseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateDatabaseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateDatabaseResponse& from);
  void MergeFrom(const CreateDatabaseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateDatabaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.CreateDatabaseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateTableRequest) */ {
 public:
  CreateTableRequest();
  virtual ~CreateTableRequest();

  CreateTableRequest(const CreateTableRequest& from);

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableRequest& default_instance();

  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(CreateTableRequest* other);
  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTableRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateTableRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateTableRequest& from);
  void MergeFrom(const CreateTableRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 2;
  void clear_db_name();
  static const int kDbNameFieldNumber = 2;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string table_name = 3;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // string properties = 4;
  void clear_properties();
  static const int kPropertiesFieldNumber = 4;
  const ::std::string& properties() const;
  void set_properties(const ::std::string& value);
  #if LANG_CXX11
  void set_properties(::std::string&& value);
  #endif
  void set_properties(const char* value);
  void set_properties(const char* value, size_t size);
  ::std::string* mutable_properties();
  ::std::string* release_properties();
  void set_allocated_properties(::std::string* properties);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.CreateTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr properties_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateTableResponse) */ {
 public:
  CreateTableResponse();
  virtual ~CreateTableResponse();

  CreateTableResponse(const CreateTableResponse& from);

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableResponse& default_instance();

  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(CreateTableResponse* other);
  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTableResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateTableResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateTableResponse& from);
  void MergeFrom(const CreateTableResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.CreateTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAutoIncIdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetAutoIncIdRequest) */ {
 public:
  GetAutoIncIdRequest();
  virtual ~GetAutoIncIdRequest();

  GetAutoIncIdRequest(const GetAutoIncIdRequest& from);

  inline GetAutoIncIdRequest& operator=(const GetAutoIncIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAutoIncIdRequest(GetAutoIncIdRequest&& from) noexcept
    : GetAutoIncIdRequest() {
    *this = ::std::move(from);
  }

  inline GetAutoIncIdRequest& operator=(GetAutoIncIdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAutoIncIdRequest& default_instance();

  static inline const GetAutoIncIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetAutoIncIdRequest*>(
               &_GetAutoIncIdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(GetAutoIncIdRequest* other);
  friend void swap(GetAutoIncIdRequest& a, GetAutoIncIdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAutoIncIdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAutoIncIdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAutoIncIdRequest& from);
  void MergeFrom(const GetAutoIncIdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAutoIncIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // uint32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.GetAutoIncIdRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  ::google::protobuf::uint32 size_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAutoIncIdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetAutoIncIdResponse) */ {
 public:
  GetAutoIncIdResponse();
  virtual ~GetAutoIncIdResponse();

  GetAutoIncIdResponse(const GetAutoIncIdResponse& from);

  inline GetAutoIncIdResponse& operator=(const GetAutoIncIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAutoIncIdResponse(GetAutoIncIdResponse&& from) noexcept
    : GetAutoIncIdResponse() {
    *this = ::std::move(from);
  }

  inline GetAutoIncIdResponse& operator=(GetAutoIncIdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAutoIncIdResponse& default_instance();

  static inline const GetAutoIncIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetAutoIncIdResponse*>(
               &_GetAutoIncIdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(GetAutoIncIdResponse* other);
  friend void swap(GetAutoIncIdResponse& a, GetAutoIncIdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAutoIncIdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAutoIncIdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAutoIncIdResponse& from);
  void MergeFrom(const GetAutoIncIdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAutoIncIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 ids = 2;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 2;
  ::google::protobuf::uint64 ids(int index) const;
  void set_ids(int index, ::google::protobuf::uint64 value);
  void add_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_ids();

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetAutoIncIdResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > ids_;
  mutable int _ids_cached_byte_size_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::mspb::Error& error() const;
  ::mspb::Error* mutable_error();
  ::mspb::Error* release_error();
  void set_allocated_error(::mspb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaderHint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.LeaderHint) */ {
 public:
  LeaderHint();
  virtual ~LeaderHint();

  LeaderHint(const LeaderHint& from);

  inline LeaderHint& operator=(const LeaderHint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaderHint(LeaderHint&& from) noexcept
    : LeaderHint() {
    *this = ::std::move(from);
  }

  inline LeaderHint& operator=(LeaderHint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderHint& default_instance();

  static inline const LeaderHint* internal_default_instance() {
    return reinterpret_cast<const LeaderHint*>(
               &_LeaderHint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(LeaderHint* other);
  friend void swap(LeaderHint& a, LeaderHint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaderHint* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaderHint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaderHint& from);
  void MergeFrom(const LeaderHint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaderHint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 term = 2;
  void clear_term();
  static const int kTermFieldNumber = 2;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.LeaderHint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 term_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NoLeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NoLeader) */ {
 public:
  NoLeader();
  virtual ~NoLeader();

  NoLeader(const NoLeader& from);

  inline NoLeader& operator=(const NoLeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NoLeader(NoLeader&& from) noexcept
    : NoLeader() {
    *this = ::std::move(from);
  }

  inline NoLeader& operator=(NoLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoLeader& default_instance();

  static inline const NoLeader* internal_default_instance() {
    return reinterpret_cast<const NoLeader*>(
               &_NoLeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(NoLeader* other);
  friend void swap(NoLeader& a, NoLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NoLeader* New() const PROTOBUF_FINAL { return New(NULL); }

  NoLeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NoLeader& from);
  void MergeFrom(const NoLeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NoLeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mspb.NoLeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.LeaderHint new_leader = 2;
  bool has_new_leader() const;
  void clear_new_leader();
  static const int kNewLeaderFieldNumber = 2;
  const ::mspb::LeaderHint& new_leader() const;
  ::mspb::LeaderHint* mutable_new_leader();
  ::mspb::LeaderHint* release_new_leader();
  void set_allocated_new_leader(::mspb::LeaderHint* new_leader);

  // .mspb.NoLeader no_leader = 3;
  bool has_no_leader() const;
  void clear_no_leader();
  static const int kNoLeaderFieldNumber = 3;
  const ::mspb::NoLeader& no_leader() const;
  ::mspb::NoLeader* mutable_no_leader();
  ::mspb::NoLeader* release_no_leader();
  void set_allocated_no_leader(::mspb::NoLeader* no_leader);

  // @@protoc_insertion_point(class_scope:mspb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::LeaderHint* new_leader_;
  ::mspb::NoLeader* no_leader_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MSLeader

// uint64 id = 1;
inline void MSLeader::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MSLeader::id() const {
  // @@protoc_insertion_point(field_get:mspb.MSLeader.id)
  return id_;
}
inline void MSLeader::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:mspb.MSLeader.id)
}

// string address = 2;
inline void MSLeader::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MSLeader::address() const {
  // @@protoc_insertion_point(field_get:mspb.MSLeader.address)
  return address_.GetNoArena();
}
inline void MSLeader::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.MSLeader.address)
}
#if LANG_CXX11
inline void MSLeader::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.MSLeader.address)
}
#endif
inline void MSLeader::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.MSLeader.address)
}
inline void MSLeader::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.MSLeader.address)
}
inline ::std::string* MSLeader::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:mspb.MSLeader.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MSLeader::release_address() {
  // @@protoc_insertion_point(field_release:mspb.MSLeader.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MSLeader::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:mspb.MSLeader.address)
}

// uint64 term = 3;
inline void MSLeader::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MSLeader::term() const {
  // @@protoc_insertion_point(field_get:mspb.MSLeader.term)
  return term_;
}
inline void MSLeader::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:mspb.MSLeader.term)
}

// -------------------------------------------------------------------

// GetMSLeaderRequest

// .mspb.RequestHeader header = 1;
inline bool GetMSLeaderRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetMSLeaderRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetMSLeaderRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetMSLeaderRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetMSLeaderRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetMSLeaderRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetMSLeaderRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetMSLeaderRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetMSLeaderRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetMSLeaderRequest.header)
}

// -------------------------------------------------------------------

// GetMSLeaderResponse

// .mspb.ResponseHeader header = 1;
inline bool GetMSLeaderResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetMSLeaderResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetMSLeaderResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetMSLeaderResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetMSLeaderResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetMSLeaderResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetMSLeaderResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetMSLeaderResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetMSLeaderResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetMSLeaderResponse.header)
}

// .mspb.MSLeader leader = 2;
inline bool GetMSLeaderResponse::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void GetMSLeaderResponse::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) delete leader_;
  leader_ = NULL;
}
inline const ::mspb::MSLeader& GetMSLeaderResponse::leader() const {
  const ::mspb::MSLeader* p = leader_;
  // @@protoc_insertion_point(field_get:mspb.GetMSLeaderResponse.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::MSLeader*>(
      &::mspb::_MSLeader_default_instance_);
}
inline ::mspb::MSLeader* GetMSLeaderResponse::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::mspb::MSLeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetMSLeaderResponse.leader)
  return leader_;
}
inline ::mspb::MSLeader* GetMSLeaderResponse::release_leader() {
  // @@protoc_insertion_point(field_release:mspb.GetMSLeaderResponse.leader)
  
  ::mspb::MSLeader* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline void GetMSLeaderResponse::set_allocated_leader(::mspb::MSLeader* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetMSLeaderResponse.leader)
}

// -------------------------------------------------------------------

// RangeStats

// uint64 bytes_written = 1;
inline void RangeStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:mspb.RangeStats.bytes_written)
  return bytes_written_;
}
inline void RangeStats::set_bytes_written(::google::protobuf::uint64 value) {
  
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeStats.bytes_written)
}

// uint64 bytes_read = 2;
inline void RangeStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:mspb.RangeStats.bytes_read)
  return bytes_read_;
}
inline void RangeStats::set_bytes_read(::google::protobuf::uint64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeStats.bytes_read)
}

// uint64 keys_written = 3;
inline void RangeStats::clear_keys_written() {
  keys_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeStats::keys_written() const {
  // @@protoc_insertion_point(field_get:mspb.RangeStats.keys_written)
  return keys_written_;
}
inline void RangeStats::set_keys_written(::google::protobuf::uint64 value) {
  
  keys_written_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeStats.keys_written)
}

// uint64 keys_read = 4;
inline void RangeStats::clear_keys_read() {
  keys_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeStats::keys_read() const {
  // @@protoc_insertion_point(field_get:mspb.RangeStats.keys_read)
  return keys_read_;
}
inline void RangeStats::set_keys_read(::google::protobuf::uint64 value) {
  
  keys_read_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeStats.keys_read)
}

// uint64 approximate_size = 5;
inline void RangeStats::clear_approximate_size() {
  approximate_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeStats::approximate_size() const {
  // @@protoc_insertion_point(field_get:mspb.RangeStats.approximate_size)
  return approximate_size_;
}
inline void RangeStats::set_approximate_size(::google::protobuf::uint64 value) {
  
  approximate_size_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeStats.approximate_size)
}

// -------------------------------------------------------------------

// RangeHeartbeatRequest

// .mspb.RequestHeader header = 1;
inline bool RangeHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& RangeHeartbeatRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* RangeHeartbeatRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* RangeHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeHeartbeatRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatRequest.header)
}

// .metapb.Range range = 2;
inline bool RangeHeartbeatRequest::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void RangeHeartbeatRequest::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& RangeHeartbeatRequest::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* RangeHeartbeatRequest::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.range)
  return range_;
}
inline ::metapb::Range* RangeHeartbeatRequest::release_range() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatRequest.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void RangeHeartbeatRequest::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatRequest.range)
}

// .metapb.Peer leader = 3;
inline bool RangeHeartbeatRequest::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void RangeHeartbeatRequest::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) delete leader_;
  leader_ = NULL;
}
inline const ::metapb::Peer& RangeHeartbeatRequest::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* RangeHeartbeatRequest::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.leader)
  return leader_;
}
inline ::metapb::Peer* RangeHeartbeatRequest::release_leader() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatRequest.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline void RangeHeartbeatRequest::set_allocated_leader(::metapb::Peer* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatRequest.leader)
}

// .mspb.RangeStats stats = 6;
inline bool RangeHeartbeatRequest::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void RangeHeartbeatRequest::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) delete stats_;
  stats_ = NULL;
}
inline const ::mspb::RangeStats& RangeHeartbeatRequest::stats() const {
  const ::mspb::RangeStats* p = stats_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RangeStats*>(
      &::mspb::_RangeStats_default_instance_);
}
inline ::mspb::RangeStats* RangeHeartbeatRequest::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::mspb::RangeStats;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.stats)
  return stats_;
}
inline ::mspb::RangeStats* RangeHeartbeatRequest::release_stats() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatRequest.stats)
  
  ::mspb::RangeStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void RangeHeartbeatRequest::set_allocated_stats(::mspb::RangeStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatRequest.stats)
}

// uint64 term = 7;
inline void RangeHeartbeatRequest::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeHeartbeatRequest::term() const {
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.term)
  return term_;
}
inline void RangeHeartbeatRequest::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeHeartbeatRequest.term)
}

// repeated .metapb.PeerStatus peers_status = 8;
inline int RangeHeartbeatRequest::peers_status_size() const {
  return peers_status_.size();
}
inline void RangeHeartbeatRequest::clear_peers_status() {
  peers_status_.Clear();
}
inline const ::metapb::PeerStatus& RangeHeartbeatRequest::peers_status(int index) const {
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_.Get(index);
}
inline ::metapb::PeerStatus* RangeHeartbeatRequest::mutable_peers_status(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_.Mutable(index);
}
inline ::metapb::PeerStatus* RangeHeartbeatRequest::add_peers_status() {
  // @@protoc_insertion_point(field_add:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::PeerStatus >*
RangeHeartbeatRequest::mutable_peers_status() {
  // @@protoc_insertion_point(field_mutable_list:mspb.RangeHeartbeatRequest.peers_status)
  return &peers_status_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::PeerStatus >&
RangeHeartbeatRequest::peers_status() const {
  // @@protoc_insertion_point(field_list:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_;
}

// -------------------------------------------------------------------

// RangeHeartbeatResponse

// .mspb.ResponseHeader header = 1;
inline bool RangeHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& RangeHeartbeatResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* RangeHeartbeatResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* RangeHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeHeartbeatResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatResponse.header)
}

// uint64 range_id = 2;
inline void RangeHeartbeatResponse::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeHeartbeatResponse::range_id() const {
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.range_id)
  return range_id_;
}
inline void RangeHeartbeatResponse::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeHeartbeatResponse.range_id)
}

// .metapb.RangeEpoch epoch = 3;
inline bool RangeHeartbeatResponse::has_epoch() const {
  return this != internal_default_instance() && epoch_ != NULL;
}
inline void RangeHeartbeatResponse::clear_epoch() {
  if (GetArenaNoVirtual() == NULL && epoch_ != NULL) delete epoch_;
  epoch_ = NULL;
}
inline const ::metapb::RangeEpoch& RangeHeartbeatResponse::epoch() const {
  const ::metapb::RangeEpoch* p = epoch_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::RangeEpoch*>(
      &::metapb::_RangeEpoch_default_instance_);
}
inline ::metapb::RangeEpoch* RangeHeartbeatResponse::mutable_epoch() {
  
  if (epoch_ == NULL) {
    epoch_ = new ::metapb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatResponse.epoch)
  return epoch_;
}
inline ::metapb::RangeEpoch* RangeHeartbeatResponse::release_epoch() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatResponse.epoch)
  
  ::metapb::RangeEpoch* temp = epoch_;
  epoch_ = NULL;
  return temp;
}
inline void RangeHeartbeatResponse::set_allocated_epoch(::metapb::RangeEpoch* epoch) {
  delete epoch_;
  epoch_ = epoch;
  if (epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatResponse.epoch)
}

// .metapb.Peer target_peer = 4;
inline bool RangeHeartbeatResponse::has_target_peer() const {
  return this != internal_default_instance() && target_peer_ != NULL;
}
inline void RangeHeartbeatResponse::clear_target_peer() {
  if (GetArenaNoVirtual() == NULL && target_peer_ != NULL) delete target_peer_;
  target_peer_ = NULL;
}
inline const ::metapb::Peer& RangeHeartbeatResponse::target_peer() const {
  const ::metapb::Peer* p = target_peer_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.target_peer)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* RangeHeartbeatResponse::mutable_target_peer() {
  
  if (target_peer_ == NULL) {
    target_peer_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatResponse.target_peer)
  return target_peer_;
}
inline ::metapb::Peer* RangeHeartbeatResponse::release_target_peer() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatResponse.target_peer)
  
  ::metapb::Peer* temp = target_peer_;
  target_peer_ = NULL;
  return temp;
}
inline void RangeHeartbeatResponse::set_allocated_target_peer(::metapb::Peer* target_peer) {
  delete target_peer_;
  target_peer_ = target_peer;
  if (target_peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatResponse.target_peer)
}

// .taskpb.Task task = 5;
inline bool RangeHeartbeatResponse::has_task() const {
  return this != internal_default_instance() && task_ != NULL;
}
inline void RangeHeartbeatResponse::clear_task() {
  if (GetArenaNoVirtual() == NULL && task_ != NULL) delete task_;
  task_ = NULL;
}
inline const ::taskpb::Task& RangeHeartbeatResponse::task() const {
  const ::taskpb::Task* p = task_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.task)
  return p != NULL ? *p : *reinterpret_cast<const ::taskpb::Task*>(
      &::taskpb::_Task_default_instance_);
}
inline ::taskpb::Task* RangeHeartbeatResponse::mutable_task() {
  
  if (task_ == NULL) {
    task_ = new ::taskpb::Task;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatResponse.task)
  return task_;
}
inline ::taskpb::Task* RangeHeartbeatResponse::release_task() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatResponse.task)
  
  ::taskpb::Task* temp = task_;
  task_ = NULL;
  return temp;
}
inline void RangeHeartbeatResponse::set_allocated_task(::taskpb::Task* task) {
  delete task_;
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatResponse.task)
}

// -------------------------------------------------------------------

// NodeStats

// uint32 range_count = 1;
inline void NodeStats::clear_range_count() {
  range_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::range_count() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.range_count)
  return range_count_;
}
inline void NodeStats::set_range_count(::google::protobuf::uint32 value) {
  
  range_count_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.range_count)
}

// uint32 range_split_count = 2;
inline void NodeStats::clear_range_split_count() {
  range_split_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::range_split_count() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.range_split_count)
  return range_split_count_;
}
inline void NodeStats::set_range_split_count(::google::protobuf::uint32 value) {
  
  range_split_count_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.range_split_count)
}

// uint32 sending_snap_count = 3;
inline void NodeStats::clear_sending_snap_count() {
  sending_snap_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::sending_snap_count() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.sending_snap_count)
  return sending_snap_count_;
}
inline void NodeStats::set_sending_snap_count(::google::protobuf::uint32 value) {
  
  sending_snap_count_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.sending_snap_count)
}

// uint32 receiving_snap_count = 4;
inline void NodeStats::clear_receiving_snap_count() {
  receiving_snap_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::receiving_snap_count() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.receiving_snap_count)
  return receiving_snap_count_;
}
inline void NodeStats::set_receiving_snap_count(::google::protobuf::uint32 value) {
  
  receiving_snap_count_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.receiving_snap_count)
}

// uint32 applying_snap_count = 5;
inline void NodeStats::clear_applying_snap_count() {
  applying_snap_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::applying_snap_count() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.applying_snap_count)
  return applying_snap_count_;
}
inline void NodeStats::set_applying_snap_count(::google::protobuf::uint32 value) {
  
  applying_snap_count_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.applying_snap_count)
}

// uint32 range_leader_count = 6;
inline void NodeStats::clear_range_leader_count() {
  range_leader_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::range_leader_count() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.range_leader_count)
  return range_leader_count_;
}
inline void NodeStats::set_range_leader_count(::google::protobuf::uint32 value) {
  
  range_leader_count_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.range_leader_count)
}

// uint64 capacity = 7;
inline void NodeStats::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::capacity() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.capacity)
  return capacity_;
}
inline void NodeStats::set_capacity(::google::protobuf::uint64 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.capacity)
}

// uint64 used_size = 8;
inline void NodeStats::clear_used_size() {
  used_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::used_size() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.used_size)
  return used_size_;
}
inline void NodeStats::set_used_size(::google::protobuf::uint64 value) {
  
  used_size_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.used_size)
}

// uint64 available = 9;
inline void NodeStats::clear_available() {
  available_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::available() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.available)
  return available_;
}
inline void NodeStats::set_available(::google::protobuf::uint64 value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.available)
}

// uint64 bytes_written = 10;
inline void NodeStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.bytes_written)
  return bytes_written_;
}
inline void NodeStats::set_bytes_written(::google::protobuf::uint64 value) {
  
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.bytes_written)
}

// uint64 keys_written = 11;
inline void NodeStats::clear_keys_written() {
  keys_written_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::keys_written() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.keys_written)
  return keys_written_;
}
inline void NodeStats::set_keys_written(::google::protobuf::uint64 value) {
  
  keys_written_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.keys_written)
}

// uint64 bytes_read = 12;
inline void NodeStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.bytes_read)
  return bytes_read_;
}
inline void NodeStats::set_bytes_read(::google::protobuf::uint64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.bytes_read)
}

// uint64 keys_read = 13;
inline void NodeStats::clear_keys_read() {
  keys_read_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeStats::keys_read() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.keys_read)
  return keys_read_;
}
inline void NodeStats::set_keys_read(::google::protobuf::uint64 value) {
  
  keys_read_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.keys_read)
}

// bool is_busy = 14;
inline void NodeStats::clear_is_busy() {
  is_busy_ = false;
}
inline bool NodeStats::is_busy() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.is_busy)
  return is_busy_;
}
inline void NodeStats::set_is_busy(bool value) {
  
  is_busy_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.is_busy)
}

// uint32 start = 15;
inline void NodeStats::clear_start() {
  start_ = 0u;
}
inline ::google::protobuf::uint32 NodeStats::start() const {
  // @@protoc_insertion_point(field_get:mspb.NodeStats.start)
  return start_;
}
inline void NodeStats::set_start(::google::protobuf::uint32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeStats.start)
}

// -------------------------------------------------------------------

// NodeHeartbeatRequest

// .mspb.RequestHeader header = 1;
inline bool NodeHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NodeHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& NodeHeartbeatRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* NodeHeartbeatRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeHeartbeatRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* NodeHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.NodeHeartbeatRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NodeHeartbeatRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeHeartbeatRequest.header)
}

// uint64 node_id = 2;
inline void NodeHeartbeatRequest::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeHeartbeatRequest::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatRequest.node_id)
  return node_id_;
}
inline void NodeHeartbeatRequest::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeHeartbeatRequest.node_id)
}

// .mspb.NodeStats stats = 3;
inline bool NodeHeartbeatRequest::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void NodeHeartbeatRequest::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) delete stats_;
  stats_ = NULL;
}
inline const ::mspb::NodeStats& NodeHeartbeatRequest::stats() const {
  const ::mspb::NodeStats* p = stats_;
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatRequest.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::NodeStats*>(
      &::mspb::_NodeStats_default_instance_);
}
inline ::mspb::NodeStats* NodeHeartbeatRequest::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::mspb::NodeStats;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeHeartbeatRequest.stats)
  return stats_;
}
inline ::mspb::NodeStats* NodeHeartbeatRequest::release_stats() {
  // @@protoc_insertion_point(field_release:mspb.NodeHeartbeatRequest.stats)
  
  ::mspb::NodeStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void NodeHeartbeatRequest::set_allocated_stats(::mspb::NodeStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeHeartbeatRequest.stats)
}

// repeated uint64 isolated_replicas = 4;
inline int NodeHeartbeatRequest::isolated_replicas_size() const {
  return isolated_replicas_.size();
}
inline void NodeHeartbeatRequest::clear_isolated_replicas() {
  isolated_replicas_.Clear();
}
inline ::google::protobuf::uint64 NodeHeartbeatRequest::isolated_replicas(int index) const {
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatRequest.isolated_replicas)
  return isolated_replicas_.Get(index);
}
inline void NodeHeartbeatRequest::set_isolated_replicas(int index, ::google::protobuf::uint64 value) {
  isolated_replicas_.Set(index, value);
  // @@protoc_insertion_point(field_set:mspb.NodeHeartbeatRequest.isolated_replicas)
}
inline void NodeHeartbeatRequest::add_isolated_replicas(::google::protobuf::uint64 value) {
  isolated_replicas_.Add(value);
  // @@protoc_insertion_point(field_add:mspb.NodeHeartbeatRequest.isolated_replicas)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
NodeHeartbeatRequest::isolated_replicas() const {
  // @@protoc_insertion_point(field_list:mspb.NodeHeartbeatRequest.isolated_replicas)
  return isolated_replicas_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
NodeHeartbeatRequest::mutable_isolated_replicas() {
  // @@protoc_insertion_point(field_mutable_list:mspb.NodeHeartbeatRequest.isolated_replicas)
  return &isolated_replicas_;
}

// -------------------------------------------------------------------

// NodeHeartbeatResponse

// .mspb.ResponseHeader header = 1;
inline bool NodeHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NodeHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& NodeHeartbeatResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* NodeHeartbeatResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeHeartbeatResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* NodeHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.NodeHeartbeatResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NodeHeartbeatResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeHeartbeatResponse.header)
}

// uint64 node_id = 2;
inline void NodeHeartbeatResponse::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeHeartbeatResponse::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatResponse.node_id)
  return node_id_;
}
inline void NodeHeartbeatResponse::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeHeartbeatResponse.node_id)
}

// repeated uint64 delete_replicas = 3;
inline int NodeHeartbeatResponse::delete_replicas_size() const {
  return delete_replicas_.size();
}
inline void NodeHeartbeatResponse::clear_delete_replicas() {
  delete_replicas_.Clear();
}
inline ::google::protobuf::uint64 NodeHeartbeatResponse::delete_replicas(int index) const {
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatResponse.delete_replicas)
  return delete_replicas_.Get(index);
}
inline void NodeHeartbeatResponse::set_delete_replicas(int index, ::google::protobuf::uint64 value) {
  delete_replicas_.Set(index, value);
  // @@protoc_insertion_point(field_set:mspb.NodeHeartbeatResponse.delete_replicas)
}
inline void NodeHeartbeatResponse::add_delete_replicas(::google::protobuf::uint64 value) {
  delete_replicas_.Add(value);
  // @@protoc_insertion_point(field_add:mspb.NodeHeartbeatResponse.delete_replicas)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
NodeHeartbeatResponse::delete_replicas() const {
  // @@protoc_insertion_point(field_list:mspb.NodeHeartbeatResponse.delete_replicas)
  return delete_replicas_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
NodeHeartbeatResponse::mutable_delete_replicas() {
  // @@protoc_insertion_point(field_mutable_list:mspb.NodeHeartbeatResponse.delete_replicas)
  return &delete_replicas_;
}

// -------------------------------------------------------------------

// AskSplitRequest

// .mspb.RequestHeader header = 1;
inline bool AskSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& AskSplitRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* AskSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* AskSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AskSplitRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitRequest.header)
}

// .metapb.Range range = 2;
inline bool AskSplitRequest::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void AskSplitRequest::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& AskSplitRequest::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* AskSplitRequest::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitRequest.range)
  return range_;
}
inline ::metapb::Range* AskSplitRequest::release_range() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitRequest.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void AskSplitRequest::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitRequest.range)
}

// bytes split_key = 3;
inline void AskSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AskSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.split_key)
  return split_key_.GetNoArena();
}
inline void AskSplitRequest::set_split_key(const ::std::string& value) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.AskSplitRequest.split_key)
}
#if LANG_CXX11
inline void AskSplitRequest::set_split_key(::std::string&& value) {
  
  split_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.AskSplitRequest.split_key)
}
#endif
inline void AskSplitRequest::set_split_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.AskSplitRequest.split_key)
}
inline void AskSplitRequest::set_split_key(const void* value, size_t size) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.AskSplitRequest.split_key)
}
inline ::std::string* AskSplitRequest::mutable_split_key() {
  
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskSplitRequest::release_split_key() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitRequest.split_key)
  
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    
  } else {
    
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitRequest.split_key)
}

// bool force = 4;
inline void AskSplitRequest::clear_force() {
  force_ = false;
}
inline bool AskSplitRequest::force() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.force)
  return force_;
}
inline void AskSplitRequest::set_force(bool value) {
  
  force_ = value;
  // @@protoc_insertion_point(field_set:mspb.AskSplitRequest.force)
}

// -------------------------------------------------------------------

// AskSplitResponse

// .mspb.ResponseHeader header = 1;
inline bool AskSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& AskSplitResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* AskSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* AskSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AskSplitResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitResponse.header)
}

// .metapb.Range range = 2;
inline bool AskSplitResponse::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void AskSplitResponse::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& AskSplitResponse::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* AskSplitResponse::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitResponse.range)
  return range_;
}
inline ::metapb::Range* AskSplitResponse::release_range() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitResponse.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void AskSplitResponse::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitResponse.range)
}

// uint64 new_range_id = 3;
inline void AskSplitResponse::clear_new_range_id() {
  new_range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AskSplitResponse::new_range_id() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.new_range_id)
  return new_range_id_;
}
inline void AskSplitResponse::set_new_range_id(::google::protobuf::uint64 value) {
  
  new_range_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.AskSplitResponse.new_range_id)
}

// repeated uint64 new_peer_ids = 4;
inline int AskSplitResponse::new_peer_ids_size() const {
  return new_peer_ids_.size();
}
inline void AskSplitResponse::clear_new_peer_ids() {
  new_peer_ids_.Clear();
}
inline ::google::protobuf::uint64 AskSplitResponse::new_peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_.Get(index);
}
inline void AskSplitResponse::set_new_peer_ids(int index, ::google::protobuf::uint64 value) {
  new_peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mspb.AskSplitResponse.new_peer_ids)
}
inline void AskSplitResponse::add_new_peer_ids(::google::protobuf::uint64 value) {
  new_peer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mspb.AskSplitResponse.new_peer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AskSplitResponse::new_peer_ids() const {
  // @@protoc_insertion_point(field_list:mspb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AskSplitResponse::mutable_new_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mspb.AskSplitResponse.new_peer_ids)
  return &new_peer_ids_;
}

// bytes split_key = 5;
inline void AskSplitResponse::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AskSplitResponse::split_key() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.split_key)
  return split_key_.GetNoArena();
}
inline void AskSplitResponse::set_split_key(const ::std::string& value) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.AskSplitResponse.split_key)
}
#if LANG_CXX11
inline void AskSplitResponse::set_split_key(::std::string&& value) {
  
  split_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.AskSplitResponse.split_key)
}
#endif
inline void AskSplitResponse::set_split_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.AskSplitResponse.split_key)
}
inline void AskSplitResponse::set_split_key(const void* value, size_t size) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.AskSplitResponse.split_key)
}
inline ::std::string* AskSplitResponse::mutable_split_key() {
  
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitResponse.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskSplitResponse::release_split_key() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitResponse.split_key)
  
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskSplitResponse::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    
  } else {
    
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitResponse.split_key)
}

// -------------------------------------------------------------------

// ReportSplitRequest

// .mspb.RequestHeader header = 1;
inline bool ReportSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReportSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& ReportSplitRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.ReportSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* ReportSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.ReportSplitRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* ReportSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.ReportSplitRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReportSplitRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.ReportSplitRequest.header)
}

// .metapb.Range left = 2;
inline bool ReportSplitRequest::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void ReportSplitRequest::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) delete left_;
  left_ = NULL;
}
inline const ::metapb::Range& ReportSplitRequest::left() const {
  const ::metapb::Range* p = left_;
  // @@protoc_insertion_point(field_get:mspb.ReportSplitRequest.left)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* ReportSplitRequest::mutable_left() {
  
  if (left_ == NULL) {
    left_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.ReportSplitRequest.left)
  return left_;
}
inline ::metapb::Range* ReportSplitRequest::release_left() {
  // @@protoc_insertion_point(field_release:mspb.ReportSplitRequest.left)
  
  ::metapb::Range* temp = left_;
  left_ = NULL;
  return temp;
}
inline void ReportSplitRequest::set_allocated_left(::metapb::Range* left) {
  delete left_;
  left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.ReportSplitRequest.left)
}

// .metapb.Range right = 3;
inline bool ReportSplitRequest::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void ReportSplitRequest::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) delete right_;
  right_ = NULL;
}
inline const ::metapb::Range& ReportSplitRequest::right() const {
  const ::metapb::Range* p = right_;
  // @@protoc_insertion_point(field_get:mspb.ReportSplitRequest.right)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* ReportSplitRequest::mutable_right() {
  
  if (right_ == NULL) {
    right_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.ReportSplitRequest.right)
  return right_;
}
inline ::metapb::Range* ReportSplitRequest::release_right() {
  // @@protoc_insertion_point(field_release:mspb.ReportSplitRequest.right)
  
  ::metapb::Range* temp = right_;
  right_ = NULL;
  return temp;
}
inline void ReportSplitRequest::set_allocated_right(::metapb::Range* right) {
  delete right_;
  right_ = right;
  if (right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.ReportSplitRequest.right)
}

// -------------------------------------------------------------------

// ReportSplitResponse

// .mspb.ResponseHeader header = 1;
inline bool ReportSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ReportSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& ReportSplitResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.ReportSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* ReportSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.ReportSplitResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* ReportSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.ReportSplitResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReportSplitResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.ReportSplitResponse.header)
}

// -------------------------------------------------------------------

// NodeLoginRequest

// .mspb.RequestHeader header = 1;
inline bool NodeLoginRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NodeLoginRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& NodeLoginRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.NodeLoginRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* NodeLoginRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeLoginRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* NodeLoginRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.NodeLoginRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NodeLoginRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeLoginRequest.header)
}

// uint64 node_id = 2;
inline void NodeLoginRequest::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeLoginRequest::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.NodeLoginRequest.node_id)
  return node_id_;
}
inline void NodeLoginRequest::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeLoginRequest.node_id)
}

// -------------------------------------------------------------------

// NodeLoginResponse

// .mspb.ResponseHeader header = 1;
inline bool NodeLoginResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NodeLoginResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& NodeLoginResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.NodeLoginResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* NodeLoginResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeLoginResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* NodeLoginResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.NodeLoginResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NodeLoginResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeLoginResponse.header)
}

// -------------------------------------------------------------------

// GetNodeIdRequest

// .mspb.RequestHeader header = 1;
inline bool GetNodeIdRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeIdRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetNodeIdRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetNodeIdRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeIdRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetNodeIdRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeIdRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeIdRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeIdRequest.header)
}

// uint32 server_port = 2;
inline void GetNodeIdRequest::clear_server_port() {
  server_port_ = 0u;
}
inline ::google::protobuf::uint32 GetNodeIdRequest::server_port() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdRequest.server_port)
  return server_port_;
}
inline void GetNodeIdRequest::set_server_port(::google::protobuf::uint32 value) {
  
  server_port_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeIdRequest.server_port)
}

// uint32 raft_port = 3;
inline void GetNodeIdRequest::clear_raft_port() {
  raft_port_ = 0u;
}
inline ::google::protobuf::uint32 GetNodeIdRequest::raft_port() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdRequest.raft_port)
  return raft_port_;
}
inline void GetNodeIdRequest::set_raft_port(::google::protobuf::uint32 value) {
  
  raft_port_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeIdRequest.raft_port)
}

// uint32 admin_port = 4;
inline void GetNodeIdRequest::clear_admin_port() {
  admin_port_ = 0u;
}
inline ::google::protobuf::uint32 GetNodeIdRequest::admin_port() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdRequest.admin_port)
  return admin_port_;
}
inline void GetNodeIdRequest::set_admin_port(::google::protobuf::uint32 value) {
  
  admin_port_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeIdRequest.admin_port)
}

// string version = 5;
inline void GetNodeIdRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNodeIdRequest::version() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdRequest.version)
  return version_.GetNoArena();
}
inline void GetNodeIdRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetNodeIdRequest.version)
}
#if LANG_CXX11
inline void GetNodeIdRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetNodeIdRequest.version)
}
#endif
inline void GetNodeIdRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetNodeIdRequest.version)
}
inline void GetNodeIdRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetNodeIdRequest.version)
}
inline ::std::string* GetNodeIdRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeIdRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNodeIdRequest::release_version() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeIdRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNodeIdRequest::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeIdRequest.version)
}

// -------------------------------------------------------------------

// GetNodeIdResponse

// .mspb.ResponseHeader header = 1;
inline bool GetNodeIdResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeIdResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetNodeIdResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetNodeIdResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeIdResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetNodeIdResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeIdResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeIdResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeIdResponse.header)
}

// uint64 node_id = 2;
inline void GetNodeIdResponse::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetNodeIdResponse::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdResponse.node_id)
  return node_id_;
}
inline void GetNodeIdResponse::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeIdResponse.node_id)
}

// bool clearup = 3;
inline void GetNodeIdResponse::clear_clearup() {
  clearup_ = false;
}
inline bool GetNodeIdResponse::clearup() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeIdResponse.clearup)
  return clearup_;
}
inline void GetNodeIdResponse::set_clearup(bool value) {
  
  clearup_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeIdResponse.clearup)
}

// -------------------------------------------------------------------

// GetRouteRequest

// .mspb.RequestHeader header = 1;
inline bool GetRouteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRouteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetRouteRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetRouteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetRouteRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetRouteRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetRouteRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetRouteRequest.header)
}

// uint64 db_id = 2;
inline void GetRouteRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetRouteRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.db_id)
  return db_id_;
}
inline void GetRouteRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.db_id)
}

// uint64 table_id = 3;
inline void GetRouteRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetRouteRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.table_id)
  return table_id_;
}
inline void GetRouteRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.table_id)
}

// bytes key = 4;
inline void GetRouteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRouteRequest::key() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.key)
  return key_.GetNoArena();
}
inline void GetRouteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.key)
}
#if LANG_CXX11
inline void GetRouteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetRouteRequest.key)
}
#endif
inline void GetRouteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetRouteRequest.key)
}
inline void GetRouteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetRouteRequest.key)
}
inline ::std::string* GetRouteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRouteRequest::release_key() {
  // @@protoc_insertion_point(field_release:mspb.GetRouteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRouteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetRouteRequest.key)
}

// -------------------------------------------------------------------

// GetRouteResponse

// .mspb.ResponseHeader header = 1;
inline bool GetRouteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRouteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetRouteResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetRouteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetRouteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetRouteResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetRouteResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetRouteResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetRouteResponse.header)
}

// repeated .metapb.Route routes = 2;
inline int GetRouteResponse::routes_size() const {
  return routes_.size();
}
inline void GetRouteResponse::clear_routes() {
  routes_.Clear();
}
inline const ::metapb::Route& GetRouteResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteResponse.routes)
  return routes_.Get(index);
}
inline ::metapb::Route* GetRouteResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteResponse.routes)
  return routes_.Mutable(index);
}
inline ::metapb::Route* GetRouteResponse::add_routes() {
  // @@protoc_insertion_point(field_add:mspb.GetRouteResponse.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Route >*
GetRouteResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetRouteResponse.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Route >&
GetRouteResponse::routes() const {
  // @@protoc_insertion_point(field_list:mspb.GetRouteResponse.routes)
  return routes_;
}

// -------------------------------------------------------------------

// GetNodeRequest

// .mspb.RequestHeader header = 1;
inline bool GetNodeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetNodeRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetNodeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetNodeRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeRequest.header)
}

// uint64 id = 2;
inline void GetNodeRequest::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetNodeRequest::id() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeRequest.id)
  return id_;
}
inline void GetNodeRequest::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeRequest.id)
}

// -------------------------------------------------------------------

// GetNodeResponse

// .mspb.ResponseHeader header = 1;
inline bool GetNodeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetNodeResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetNodeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetNodeResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeResponse.header)
}

// .metapb.Node node = 2;
inline bool GetNodeResponse::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void GetNodeResponse::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::metapb::Node& GetNodeResponse::node() const {
  const ::metapb::Node* p = node_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeResponse.node)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Node*>(
      &::metapb::_Node_default_instance_);
}
inline ::metapb::Node* GetNodeResponse::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::metapb::Node;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeResponse.node)
  return node_;
}
inline ::metapb::Node* GetNodeResponse::release_node() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeResponse.node)
  
  ::metapb::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void GetNodeResponse::set_allocated_node(::metapb::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeResponse.node)
}

// -------------------------------------------------------------------

// GetDBRequest

// .mspb.RequestHeader header = 1;
inline bool GetDBRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetDBRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetDBRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetDBRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetDBRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetDBRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetDBRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetDBRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBRequest.header)
}

// string name = 2;
inline void GetDBRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetDBRequest::name() const {
  // @@protoc_insertion_point(field_get:mspb.GetDBRequest.name)
  return name_.GetNoArena();
}
inline void GetDBRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetDBRequest.name)
}
#if LANG_CXX11
inline void GetDBRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetDBRequest.name)
}
#endif
inline void GetDBRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetDBRequest.name)
}
inline void GetDBRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetDBRequest.name)
}
inline ::std::string* GetDBRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetDBRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetDBRequest::release_name() {
  // @@protoc_insertion_point(field_release:mspb.GetDBRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetDBRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBRequest.name)
}

// -------------------------------------------------------------------

// GetDBResponse

// .mspb.ResponseHeader header = 1;
inline bool GetDBResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetDBResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetDBResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetDBResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetDBResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetDBResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetDBResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetDBResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBResponse.header)
}

// .metapb.DataBase db = 2;
inline bool GetDBResponse::has_db() const {
  return this != internal_default_instance() && db_ != NULL;
}
inline void GetDBResponse::clear_db() {
  if (GetArenaNoVirtual() == NULL && db_ != NULL) delete db_;
  db_ = NULL;
}
inline const ::metapb::DataBase& GetDBResponse::db() const {
  const ::metapb::DataBase* p = db_;
  // @@protoc_insertion_point(field_get:mspb.GetDBResponse.db)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::DataBase*>(
      &::metapb::_DataBase_default_instance_);
}
inline ::metapb::DataBase* GetDBResponse::mutable_db() {
  
  if (db_ == NULL) {
    db_ = new ::metapb::DataBase;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBResponse.db)
  return db_;
}
inline ::metapb::DataBase* GetDBResponse::release_db() {
  // @@protoc_insertion_point(field_release:mspb.GetDBResponse.db)
  
  ::metapb::DataBase* temp = db_;
  db_ = NULL;
  return temp;
}
inline void GetDBResponse::set_allocated_db(::metapb::DataBase* db) {
  delete db_;
  db_ = db;
  if (db) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBResponse.db)
}

// -------------------------------------------------------------------

// GetTableRequest

// .mspb.RequestHeader header = 1;
inline bool GetTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetTableRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTableRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTableRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableRequest.header)
}

// string db_name = 2;
inline void GetTableRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.db_name)
  return db_name_.GetNoArena();
}
inline void GetTableRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetTableRequest.db_name)
}
#if LANG_CXX11
inline void GetTableRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetTableRequest.db_name)
}
#endif
inline void GetTableRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetTableRequest.db_name)
}
inline void GetTableRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetTableRequest.db_name)
}
inline ::std::string* GetTableRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetTableRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.GetTableRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTableRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableRequest.db_name)
}

// string table_name = 3;
inline void GetTableRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.table_name)
  return table_name_.GetNoArena();
}
inline void GetTableRequest::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetTableRequest.table_name)
}
#if LANG_CXX11
inline void GetTableRequest::set_table_name(::std::string&& value) {
  
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetTableRequest.table_name)
}
#endif
inline void GetTableRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetTableRequest.table_name)
}
inline void GetTableRequest::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetTableRequest.table_name)
}
inline ::std::string* GetTableRequest::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetTableRequest.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:mspb.GetTableRequest.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTableRequest::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableRequest.table_name)
}

// -------------------------------------------------------------------

// GetTableByIdRequest

// .mspb.RequestHeader header = 1;
inline bool GetTableByIdRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTableByIdRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetTableByIdRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTableByIdRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetTableByIdRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableByIdRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetTableByIdRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTableByIdRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTableByIdRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableByIdRequest.header)
}

// uint64 db_id = 2;
inline void GetTableByIdRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetTableByIdRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableByIdRequest.db_id)
  return db_id_;
}
inline void GetTableByIdRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetTableByIdRequest.db_id)
}

// uint64 table_id = 3;
inline void GetTableByIdRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetTableByIdRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableByIdRequest.table_id)
  return table_id_;
}
inline void GetTableByIdRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetTableByIdRequest.table_id)
}

// -------------------------------------------------------------------

// GetTableResponse

// .mspb.ResponseHeader header = 1;
inline bool GetTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetTableResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTableResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTableResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableResponse.header)
}

// .metapb.Table table = 2;
inline bool GetTableResponse::has_table() const {
  return this != internal_default_instance() && table_ != NULL;
}
inline void GetTableResponse::clear_table() {
  if (GetArenaNoVirtual() == NULL && table_ != NULL) delete table_;
  table_ = NULL;
}
inline const ::metapb::Table& GetTableResponse::table() const {
  const ::metapb::Table* p = table_;
  // @@protoc_insertion_point(field_get:mspb.GetTableResponse.table)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Table*>(
      &::metapb::_Table_default_instance_);
}
inline ::metapb::Table* GetTableResponse::mutable_table() {
  
  if (table_ == NULL) {
    table_ = new ::metapb::Table;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableResponse.table)
  return table_;
}
inline ::metapb::Table* GetTableResponse::release_table() {
  // @@protoc_insertion_point(field_release:mspb.GetTableResponse.table)
  
  ::metapb::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void GetTableResponse::set_allocated_table(::metapb::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableResponse.table)
}

// -------------------------------------------------------------------

// GetTableByIdResponse

// .mspb.ResponseHeader header = 1;
inline bool GetTableByIdResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTableByIdResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetTableByIdResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTableByIdResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetTableByIdResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableByIdResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetTableByIdResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTableByIdResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTableByIdResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableByIdResponse.header)
}

// .metapb.Table table = 2;
inline bool GetTableByIdResponse::has_table() const {
  return this != internal_default_instance() && table_ != NULL;
}
inline void GetTableByIdResponse::clear_table() {
  if (GetArenaNoVirtual() == NULL && table_ != NULL) delete table_;
  table_ = NULL;
}
inline const ::metapb::Table& GetTableByIdResponse::table() const {
  const ::metapb::Table* p = table_;
  // @@protoc_insertion_point(field_get:mspb.GetTableByIdResponse.table)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Table*>(
      &::metapb::_Table_default_instance_);
}
inline ::metapb::Table* GetTableByIdResponse::mutable_table() {
  
  if (table_ == NULL) {
    table_ = new ::metapb::Table;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableByIdResponse.table)
  return table_;
}
inline ::metapb::Table* GetTableByIdResponse::release_table() {
  // @@protoc_insertion_point(field_release:mspb.GetTableByIdResponse.table)
  
  ::metapb::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void GetTableByIdResponse::set_allocated_table(::metapb::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableByIdResponse.table)
}

// -------------------------------------------------------------------

// GetColumnsRequest

// .mspb.RequestHeader header = 1;
inline bool GetColumnsRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnsRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetColumnsRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnsRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetColumnsRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnsRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetColumnsRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnsRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnsRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnsRequest.header)
}

// uint64 db_id = 2;
inline void GetColumnsRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnsRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnsRequest.db_id)
  return db_id_;
}
inline void GetColumnsRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnsRequest.db_id)
}

// uint64 table_id = 3;
inline void GetColumnsRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnsRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnsRequest.table_id)
  return table_id_;
}
inline void GetColumnsRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnsRequest.table_id)
}

// -------------------------------------------------------------------

// GetColumnsResponse

// .mspb.ResponseHeader header = 1;
inline bool GetColumnsResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnsResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetColumnsResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnsResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetColumnsResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnsResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetColumnsResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnsResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnsResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnsResponse.header)
}

// repeated .metapb.Column columns = 2;
inline int GetColumnsResponse::columns_size() const {
  return columns_.size();
}
inline void GetColumnsResponse::clear_columns() {
  columns_.Clear();
}
inline const ::metapb::Column& GetColumnsResponse::columns(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnsResponse.columns)
  return columns_.Get(index);
}
inline ::metapb::Column* GetColumnsResponse::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnsResponse.columns)
  return columns_.Mutable(index);
}
inline ::metapb::Column* GetColumnsResponse::add_columns() {
  // @@protoc_insertion_point(field_add:mspb.GetColumnsResponse.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
GetColumnsResponse::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetColumnsResponse.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
GetColumnsResponse::columns() const {
  // @@protoc_insertion_point(field_list:mspb.GetColumnsResponse.columns)
  return columns_;
}

// -------------------------------------------------------------------

// GetColumnByNameRequest

// .mspb.RequestHeader header = 1;
inline bool GetColumnByNameRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnByNameRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetColumnByNameRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnByNameRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetColumnByNameRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByNameRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetColumnByNameRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByNameRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnByNameRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByNameRequest.header)
}

// uint64 db_id = 2;
inline void GetColumnByNameRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnByNameRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnByNameRequest.db_id)
  return db_id_;
}
inline void GetColumnByNameRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnByNameRequest.db_id)
}

// uint64 table_id = 3;
inline void GetColumnByNameRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnByNameRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnByNameRequest.table_id)
  return table_id_;
}
inline void GetColumnByNameRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnByNameRequest.table_id)
}

// string col_name = 4;
inline void GetColumnByNameRequest::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetColumnByNameRequest::col_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnByNameRequest.col_name)
  return col_name_.GetNoArena();
}
inline void GetColumnByNameRequest::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetColumnByNameRequest.col_name)
}
#if LANG_CXX11
inline void GetColumnByNameRequest::set_col_name(::std::string&& value) {
  
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetColumnByNameRequest.col_name)
}
#endif
inline void GetColumnByNameRequest::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetColumnByNameRequest.col_name)
}
inline void GetColumnByNameRequest::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetColumnByNameRequest.col_name)
}
inline ::std::string* GetColumnByNameRequest::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByNameRequest.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetColumnByNameRequest::release_col_name() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByNameRequest.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetColumnByNameRequest::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByNameRequest.col_name)
}

// -------------------------------------------------------------------

// GetColumnByNameResponse

// .mspb.ResponseHeader header = 1;
inline bool GetColumnByNameResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnByNameResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetColumnByNameResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnByNameResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetColumnByNameResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByNameResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetColumnByNameResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByNameResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnByNameResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByNameResponse.header)
}

// .metapb.Column column = 2;
inline bool GetColumnByNameResponse::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void GetColumnByNameResponse::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& GetColumnByNameResponse::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnByNameResponse.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* GetColumnByNameResponse::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByNameResponse.column)
  return column_;
}
inline ::metapb::Column* GetColumnByNameResponse::release_column() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByNameResponse.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void GetColumnByNameResponse::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByNameResponse.column)
}

// -------------------------------------------------------------------

// GetColumnByIdRequest

// .mspb.RequestHeader header = 1;
inline bool GetColumnByIdRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnByIdRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetColumnByIdRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnByIdRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetColumnByIdRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByIdRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetColumnByIdRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByIdRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnByIdRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByIdRequest.header)
}

// uint64 db_id = 2;
inline void GetColumnByIdRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnByIdRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnByIdRequest.db_id)
  return db_id_;
}
inline void GetColumnByIdRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnByIdRequest.db_id)
}

// uint64 table_id = 3;
inline void GetColumnByIdRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnByIdRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnByIdRequest.table_id)
  return table_id_;
}
inline void GetColumnByIdRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnByIdRequest.table_id)
}

// uint64 col_id = 4;
inline void GetColumnByIdRequest::clear_col_id() {
  col_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnByIdRequest::col_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnByIdRequest.col_id)
  return col_id_;
}
inline void GetColumnByIdRequest::set_col_id(::google::protobuf::uint64 value) {
  
  col_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnByIdRequest.col_id)
}

// -------------------------------------------------------------------

// GetColumnByIdResponse

// .mspb.ResponseHeader header = 1;
inline bool GetColumnByIdResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnByIdResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetColumnByIdResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnByIdResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetColumnByIdResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByIdResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetColumnByIdResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByIdResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnByIdResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByIdResponse.header)
}

// .metapb.Column column = 2;
inline bool GetColumnByIdResponse::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void GetColumnByIdResponse::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::metapb::Column& GetColumnByIdResponse::column() const {
  const ::metapb::Column* p = column_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnByIdResponse.column)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Column*>(
      &::metapb::_Column_default_instance_);
}
inline ::metapb::Column* GetColumnByIdResponse::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::metapb::Column;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnByIdResponse.column)
  return column_;
}
inline ::metapb::Column* GetColumnByIdResponse::release_column() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnByIdResponse.column)
  
  ::metapb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void GetColumnByIdResponse::set_allocated_column(::metapb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnByIdResponse.column)
}

// -------------------------------------------------------------------

// AddColumnRequest

// .mspb.RequestHeader header = 1;
inline bool AddColumnRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AddColumnRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& AddColumnRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.AddColumnRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* AddColumnRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AddColumnRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* AddColumnRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.AddColumnRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AddColumnRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AddColumnRequest.header)
}

// uint64 db_id = 2;
inline void AddColumnRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AddColumnRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.AddColumnRequest.db_id)
  return db_id_;
}
inline void AddColumnRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.AddColumnRequest.db_id)
}

// uint64 table_id = 3;
inline void AddColumnRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AddColumnRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.AddColumnRequest.table_id)
  return table_id_;
}
inline void AddColumnRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.AddColumnRequest.table_id)
}

// repeated .metapb.Column columns = 4;
inline int AddColumnRequest::columns_size() const {
  return columns_.size();
}
inline void AddColumnRequest::clear_columns() {
  columns_.Clear();
}
inline const ::metapb::Column& AddColumnRequest::columns(int index) const {
  // @@protoc_insertion_point(field_get:mspb.AddColumnRequest.columns)
  return columns_.Get(index);
}
inline ::metapb::Column* AddColumnRequest::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.AddColumnRequest.columns)
  return columns_.Mutable(index);
}
inline ::metapb::Column* AddColumnRequest::add_columns() {
  // @@protoc_insertion_point(field_add:mspb.AddColumnRequest.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
AddColumnRequest::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:mspb.AddColumnRequest.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
AddColumnRequest::columns() const {
  // @@protoc_insertion_point(field_list:mspb.AddColumnRequest.columns)
  return columns_;
}

// -------------------------------------------------------------------

// AddColumnResponse

// .mspb.ResponseHeader header = 1;
inline bool AddColumnResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AddColumnResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& AddColumnResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.AddColumnResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* AddColumnResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AddColumnResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* AddColumnResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.AddColumnResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AddColumnResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AddColumnResponse.header)
}

// repeated .metapb.Column columns = 2;
inline int AddColumnResponse::columns_size() const {
  return columns_.size();
}
inline void AddColumnResponse::clear_columns() {
  columns_.Clear();
}
inline const ::metapb::Column& AddColumnResponse::columns(int index) const {
  // @@protoc_insertion_point(field_get:mspb.AddColumnResponse.columns)
  return columns_.Get(index);
}
inline ::metapb::Column* AddColumnResponse::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.AddColumnResponse.columns)
  return columns_.Mutable(index);
}
inline ::metapb::Column* AddColumnResponse::add_columns() {
  // @@protoc_insertion_point(field_add:mspb.AddColumnResponse.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
AddColumnResponse::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:mspb.AddColumnResponse.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
AddColumnResponse::columns() const {
  // @@protoc_insertion_point(field_list:mspb.AddColumnResponse.columns)
  return columns_;
}

// -------------------------------------------------------------------

// TruncateTableRequest

// .mspb.RequestHeader header = 1;
inline bool TruncateTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TruncateTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& TruncateTableRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.TruncateTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* TruncateTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.TruncateTableRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* TruncateTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.TruncateTableRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TruncateTableRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.TruncateTableRequest.header)
}

// uint64 db_id = 2;
inline void TruncateTableRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TruncateTableRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.TruncateTableRequest.db_id)
  return db_id_;
}
inline void TruncateTableRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.TruncateTableRequest.db_id)
}

// uint64 table_id = 3;
inline void TruncateTableRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TruncateTableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.TruncateTableRequest.table_id)
  return table_id_;
}
inline void TruncateTableRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.TruncateTableRequest.table_id)
}

// -------------------------------------------------------------------

// TruncateTableResponse

// .mspb.ResponseHeader header = 1;
inline bool TruncateTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TruncateTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& TruncateTableResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.TruncateTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* TruncateTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.TruncateTableResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* TruncateTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.TruncateTableResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TruncateTableResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.TruncateTableResponse.header)
}

// -------------------------------------------------------------------

// CreateDatabaseRequest

// .mspb.RequestHeader header = 1;
inline bool CreateDatabaseRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateDatabaseRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& CreateDatabaseRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* CreateDatabaseRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* CreateDatabaseRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateDatabaseRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseRequest.header)
}

// string db_name = 2;
inline void CreateDatabaseRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateDatabaseRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseRequest.db_name)
  return db_name_.GetNoArena();
}
inline void CreateDatabaseRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateDatabaseRequest.db_name)
}
#if LANG_CXX11
inline void CreateDatabaseRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateDatabaseRequest.db_name)
}
#endif
inline void CreateDatabaseRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateDatabaseRequest.db_name)
}
inline void CreateDatabaseRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateDatabaseRequest.db_name)
}
inline ::std::string* CreateDatabaseRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateDatabaseRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateDatabaseRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseRequest.db_name)
}

// -------------------------------------------------------------------

// CreateDatabaseResponse

// .mspb.ResponseHeader header = 1;
inline bool CreateDatabaseResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateDatabaseResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& CreateDatabaseResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* CreateDatabaseResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* CreateDatabaseResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateDatabaseResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseResponse.header)
}

// -------------------------------------------------------------------

// CreateTableRequest

// .mspb.RequestHeader header = 1;
inline bool CreateTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& CreateTableRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* CreateTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* CreateTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.header)
}

// string db_name = 2;
inline void CreateTableRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.db_name)
  return db_name_.GetNoArena();
}
inline void CreateTableRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.db_name)
}
#if LANG_CXX11
inline void CreateTableRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateTableRequest.db_name)
}
#endif
inline void CreateTableRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.db_name)
}
inline void CreateTableRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.db_name)
}
inline ::std::string* CreateTableRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.db_name)
}

// string table_name = 3;
inline void CreateTableRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.table_name)
  return table_name_.GetNoArena();
}
inline void CreateTableRequest::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.table_name)
}
#if LANG_CXX11
inline void CreateTableRequest::set_table_name(::std::string&& value) {
  
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateTableRequest.table_name)
}
#endif
inline void CreateTableRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.table_name)
}
inline void CreateTableRequest::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.table_name)
}
inline ::std::string* CreateTableRequest::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.table_name)
}

// string properties = 4;
inline void CreateTableRequest::clear_properties() {
  properties_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTableRequest::properties() const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.properties)
  return properties_.GetNoArena();
}
inline void CreateTableRequest::set_properties(const ::std::string& value) {
  
  properties_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.properties)
}
#if LANG_CXX11
inline void CreateTableRequest::set_properties(::std::string&& value) {
  
  properties_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateTableRequest.properties)
}
#endif
inline void CreateTableRequest::set_properties(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  properties_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.properties)
}
inline void CreateTableRequest::set_properties(const char* value, size_t size) {
  
  properties_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.properties)
}
inline ::std::string* CreateTableRequest::mutable_properties() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.properties)
  return properties_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTableRequest::release_properties() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.properties)
  
  return properties_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_properties(::std::string* properties) {
  if (properties != NULL) {
    
  } else {
    
  }
  properties_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), properties);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.properties)
}

// -------------------------------------------------------------------

// CreateTableResponse

// .mspb.ResponseHeader header = 1;
inline bool CreateTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& CreateTableResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* CreateTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* CreateTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateTableResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableResponse.header)
}

// -------------------------------------------------------------------

// GetAutoIncIdRequest

// .mspb.RequestHeader header = 1;
inline bool GetAutoIncIdRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetAutoIncIdRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetAutoIncIdRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetAutoIncIdRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetAutoIncIdRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetAutoIncIdRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetAutoIncIdRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetAutoIncIdRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetAutoIncIdRequest.header)
}

// uint64 db_id = 2;
inline void GetAutoIncIdRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetAutoIncIdRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.db_id)
  return db_id_;
}
inline void GetAutoIncIdRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdRequest.db_id)
}

// uint64 table_id = 3;
inline void GetAutoIncIdRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetAutoIncIdRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.table_id)
  return table_id_;
}
inline void GetAutoIncIdRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdRequest.table_id)
}

// uint32 size = 4;
inline void GetAutoIncIdRequest::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 GetAutoIncIdRequest::size() const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.size)
  return size_;
}
inline void GetAutoIncIdRequest::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdRequest.size)
}

// -------------------------------------------------------------------

// GetAutoIncIdResponse

// .mspb.ResponseHeader header = 1;
inline bool GetAutoIncIdResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetAutoIncIdResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetAutoIncIdResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetAutoIncIdResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetAutoIncIdResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetAutoIncIdResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetAutoIncIdResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetAutoIncIdResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetAutoIncIdResponse.header)
}

// repeated uint64 ids = 2;
inline int GetAutoIncIdResponse::ids_size() const {
  return ids_.size();
}
inline void GetAutoIncIdResponse::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint64 GetAutoIncIdResponse::ids(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdResponse.ids)
  return ids_.Get(index);
}
inline void GetAutoIncIdResponse::set_ids(int index, ::google::protobuf::uint64 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdResponse.ids)
}
inline void GetAutoIncIdResponse::add_ids(::google::protobuf::uint64 value) {
  ids_.Add(value);
  // @@protoc_insertion_point(field_add:mspb.GetAutoIncIdResponse.ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAutoIncIdResponse::ids() const {
  // @@protoc_insertion_point(field_list:mspb.GetAutoIncIdResponse.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAutoIncIdResponse::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetAutoIncIdResponse.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:mspb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.RequestHeader.cluster_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:mspb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.ResponseHeader.cluster_id)
}

// .mspb.Error error = 2;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::mspb::Error& ResponseHeader::error() const {
  const ::mspb::Error* p = error_;
  // @@protoc_insertion_point(field_get:mspb.ResponseHeader.error)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::Error*>(
      &::mspb::_Error_default_instance_);
}
inline ::mspb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::mspb::Error;
  }
  // @@protoc_insertion_point(field_mutable:mspb.ResponseHeader.error)
  return error_;
}
inline ::mspb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:mspb.ResponseHeader.error)
  
  ::mspb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_error(::mspb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// LeaderHint

// string address = 1;
inline void LeaderHint::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaderHint::address() const {
  // @@protoc_insertion_point(field_get:mspb.LeaderHint.address)
  return address_.GetNoArena();
}
inline void LeaderHint::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.LeaderHint.address)
}
#if LANG_CXX11
inline void LeaderHint::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.LeaderHint.address)
}
#endif
inline void LeaderHint::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.LeaderHint.address)
}
inline void LeaderHint::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.LeaderHint.address)
}
inline ::std::string* LeaderHint::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:mspb.LeaderHint.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaderHint::release_address() {
  // @@protoc_insertion_point(field_release:mspb.LeaderHint.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaderHint::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:mspb.LeaderHint.address)
}

// uint64 term = 2;
inline void LeaderHint::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LeaderHint::term() const {
  // @@protoc_insertion_point(field_get:mspb.LeaderHint.term)
  return term_;
}
inline void LeaderHint::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:mspb.LeaderHint.term)
}

// -------------------------------------------------------------------

// NoLeader

// -------------------------------------------------------------------

// Error

// .mspb.LeaderHint new_leader = 2;
inline bool Error::has_new_leader() const {
  return this != internal_default_instance() && new_leader_ != NULL;
}
inline void Error::clear_new_leader() {
  if (GetArenaNoVirtual() == NULL && new_leader_ != NULL) delete new_leader_;
  new_leader_ = NULL;
}
inline const ::mspb::LeaderHint& Error::new_leader() const {
  const ::mspb::LeaderHint* p = new_leader_;
  // @@protoc_insertion_point(field_get:mspb.Error.new_leader)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::LeaderHint*>(
      &::mspb::_LeaderHint_default_instance_);
}
inline ::mspb::LeaderHint* Error::mutable_new_leader() {
  
  if (new_leader_ == NULL) {
    new_leader_ = new ::mspb::LeaderHint;
  }
  // @@protoc_insertion_point(field_mutable:mspb.Error.new_leader)
  return new_leader_;
}
inline ::mspb::LeaderHint* Error::release_new_leader() {
  // @@protoc_insertion_point(field_release:mspb.Error.new_leader)
  
  ::mspb::LeaderHint* temp = new_leader_;
  new_leader_ = NULL;
  return temp;
}
inline void Error::set_allocated_new_leader(::mspb::LeaderHint* new_leader) {
  delete new_leader_;
  new_leader_ = new_leader;
  if (new_leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.Error.new_leader)
}

// .mspb.NoLeader no_leader = 3;
inline bool Error::has_no_leader() const {
  return this != internal_default_instance() && no_leader_ != NULL;
}
inline void Error::clear_no_leader() {
  if (GetArenaNoVirtual() == NULL && no_leader_ != NULL) delete no_leader_;
  no_leader_ = NULL;
}
inline const ::mspb::NoLeader& Error::no_leader() const {
  const ::mspb::NoLeader* p = no_leader_;
  // @@protoc_insertion_point(field_get:mspb.Error.no_leader)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::NoLeader*>(
      &::mspb::_NoLeader_default_instance_);
}
inline ::mspb::NoLeader* Error::mutable_no_leader() {
  
  if (no_leader_ == NULL) {
    no_leader_ = new ::mspb::NoLeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.Error.no_leader)
  return no_leader_;
}
inline ::mspb::NoLeader* Error::release_no_leader() {
  // @@protoc_insertion_point(field_release:mspb.Error.no_leader)
  
  ::mspb::NoLeader* temp = no_leader_;
  no_leader_ = NULL;
  return temp;
}
inline void Error::set_allocated_no_leader(::mspb::NoLeader* no_leader) {
  delete no_leader_;
  no_leader_ = no_leader;
  if (no_leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.Error.no_leader)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace mspb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mspb_2eproto__INCLUDED
