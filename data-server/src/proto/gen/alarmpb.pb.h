// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: alarmpb.proto

#ifndef PROTOBUF_alarmpb_2eproto__INCLUDED
#define PROTOBUF_alarmpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "taskpb.pb.h"
#include "metapb.pb.h"
// @@protoc_insertion_point(includes)
namespace alarmpb {
class AliveRequest;
class AliveRequestDefaultTypeInternal;
extern AliveRequestDefaultTypeInternal _AliveRequest_default_instance_;
class AliveResponse;
class AliveResponseDefaultTypeInternal;
extern AliveResponseDefaultTypeInternal _AliveResponse_default_instance_;
class NodeDiskSizeAlarm;
class NodeDiskSizeAlarmDefaultTypeInternal;
extern NodeDiskSizeAlarmDefaultTypeInternal _NodeDiskSizeAlarm_default_instance_;
class NodeLeaderCountAlarm;
class NodeLeaderCountAlarmDefaultTypeInternal;
extern NodeLeaderCountAlarmDefaultTypeInternal _NodeLeaderCountAlarm_default_instance_;
class NodeNoHeartbeatAlarm;
class NodeNoHeartbeatAlarmDefaultTypeInternal;
extern NodeNoHeartbeatAlarmDefaultTypeInternal _NodeNoHeartbeatAlarm_default_instance_;
class NodeRangeAlarmRequest;
class NodeRangeAlarmRequestDefaultTypeInternal;
extern NodeRangeAlarmRequestDefaultTypeInternal _NodeRangeAlarmRequest_default_instance_;
class NodeRangeAlarmResponse;
class NodeRangeAlarmResponseDefaultTypeInternal;
extern NodeRangeAlarmResponseDefaultTypeInternal _NodeRangeAlarmResponse_default_instance_;
class RangeNoHeartbeatAlarm;
class RangeNoHeartbeatAlarmDefaultTypeInternal;
extern RangeNoHeartbeatAlarmDefaultTypeInternal _RangeNoHeartbeatAlarm_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class SimpleAlarmRequest;
class SimpleAlarmRequestDefaultTypeInternal;
extern SimpleAlarmRequestDefaultTypeInternal _SimpleAlarmRequest_default_instance_;
class SimpleAlarmResponse;
class SimpleAlarmResponseDefaultTypeInternal;
extern SimpleAlarmResponseDefaultTypeInternal _SimpleAlarmResponse_default_instance_;
class SimpleRequest;
class SimpleRequestDefaultTypeInternal;
extern SimpleRequestDefaultTypeInternal _SimpleRequest_default_instance_;
class SimpleResponse;
class SimpleResponseDefaultTypeInternal;
extern SimpleResponseDefaultTypeInternal _SimpleResponse_default_instance_;
class TaskAlarmRequest;
class TaskAlarmRequestDefaultTypeInternal;
extern TaskAlarmRequestDefaultTypeInternal _TaskAlarmRequest_default_instance_;
class TaskAlarmResponse;
class TaskAlarmResponseDefaultTypeInternal;
extern TaskAlarmResponseDefaultTypeInternal _TaskAlarmResponse_default_instance_;
class TaskLongTimeRunning;
class TaskLongTimeRunningDefaultTypeInternal;
extern TaskLongTimeRunningDefaultTypeInternal _TaskLongTimeRunning_default_instance_;
class TaskTimeout;
class TaskTimeoutDefaultTypeInternal;
extern TaskTimeoutDefaultTypeInternal _TaskTimeout_default_instance_;
}  // namespace alarmpb

namespace alarmpb {

namespace protobuf_alarmpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_alarmpb_2eproto

enum TaskAlarmType {
  TIMEOUT = 0,
  LONG_TIME_RUNNING = 1,
  TaskAlarmType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskAlarmType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskAlarmType_IsValid(int value);
const TaskAlarmType TaskAlarmType_MIN = TIMEOUT;
const TaskAlarmType TaskAlarmType_MAX = LONG_TIME_RUNNING;
const int TaskAlarmType_ARRAYSIZE = TaskAlarmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskAlarmType_descriptor();
inline const ::std::string& TaskAlarmType_Name(TaskAlarmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskAlarmType_descriptor(), value);
}
inline bool TaskAlarmType_Parse(
    const ::std::string& name, TaskAlarmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskAlarmType>(
    TaskAlarmType_descriptor(), name, value);
}
enum NodeRangeAlarmType {
  RANGE_NO_HEARTBEAT = 0,
  NODE_NO_HEARTBEAT = 1,
  NODE_DISK_SIZE = 2,
  NODE_LEADER_COUNT = 3,
  NodeRangeAlarmType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NodeRangeAlarmType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NodeRangeAlarmType_IsValid(int value);
const NodeRangeAlarmType NodeRangeAlarmType_MIN = RANGE_NO_HEARTBEAT;
const NodeRangeAlarmType NodeRangeAlarmType_MAX = NODE_LEADER_COUNT;
const int NodeRangeAlarmType_ARRAYSIZE = NodeRangeAlarmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeRangeAlarmType_descriptor();
inline const ::std::string& NodeRangeAlarmType_Name(NodeRangeAlarmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeRangeAlarmType_descriptor(), value);
}
inline bool NodeRangeAlarmType_Parse(
    const ::std::string& name, NodeRangeAlarmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeRangeAlarmType>(
    NodeRangeAlarmType_descriptor(), name, value);
}
// ===================================================================

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::int64 cluster_id() const;
  void set_cluster_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:alarmpb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:alarmpb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimpleAlarmRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.SimpleAlarmRequest) */ {
 public:
  SimpleAlarmRequest();
  virtual ~SimpleAlarmRequest();

  SimpleAlarmRequest(const SimpleAlarmRequest& from);

  inline SimpleAlarmRequest& operator=(const SimpleAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimpleAlarmRequest(SimpleAlarmRequest&& from) noexcept
    : SimpleAlarmRequest() {
    *this = ::std::move(from);
  }

  inline SimpleAlarmRequest& operator=(SimpleAlarmRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleAlarmRequest& default_instance();

  static inline const SimpleAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const SimpleAlarmRequest*>(
               &_SimpleAlarmRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SimpleAlarmRequest* other);
  friend void swap(SimpleAlarmRequest& a, SimpleAlarmRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimpleAlarmRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SimpleAlarmRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimpleAlarmRequest& from);
  void MergeFrom(const SimpleAlarmRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimpleAlarmRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Describe = 2;
  void clear_describe();
  static const int kDescribeFieldNumber = 2;
  const ::std::string& describe() const;
  void set_describe(const ::std::string& value);
  #if LANG_CXX11
  void set_describe(::std::string&& value);
  #endif
  void set_describe(const char* value);
  void set_describe(const char* value, size_t size);
  ::std::string* mutable_describe();
  ::std::string* release_describe();
  void set_allocated_describe(::std::string* describe);

  // .alarmpb.RequestHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::RequestHeader& head() const;
  ::alarmpb::RequestHeader* mutable_head();
  ::alarmpb::RequestHeader* release_head();
  void set_allocated_head(::alarmpb::RequestHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.SimpleAlarmRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr describe_;
  ::alarmpb::RequestHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimpleAlarmResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.SimpleAlarmResponse) */ {
 public:
  SimpleAlarmResponse();
  virtual ~SimpleAlarmResponse();

  SimpleAlarmResponse(const SimpleAlarmResponse& from);

  inline SimpleAlarmResponse& operator=(const SimpleAlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimpleAlarmResponse(SimpleAlarmResponse&& from) noexcept
    : SimpleAlarmResponse() {
    *this = ::std::move(from);
  }

  inline SimpleAlarmResponse& operator=(SimpleAlarmResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleAlarmResponse& default_instance();

  static inline const SimpleAlarmResponse* internal_default_instance() {
    return reinterpret_cast<const SimpleAlarmResponse*>(
               &_SimpleAlarmResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SimpleAlarmResponse* other);
  friend void swap(SimpleAlarmResponse& a, SimpleAlarmResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimpleAlarmResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SimpleAlarmResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimpleAlarmResponse& from);
  void MergeFrom(const SimpleAlarmResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimpleAlarmResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb.ResponseHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::ResponseHeader& head() const;
  ::alarmpb::ResponseHeader* mutable_head();
  ::alarmpb::ResponseHeader* release_head();
  void set_allocated_head(::alarmpb::ResponseHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.SimpleAlarmResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb::ResponseHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskAlarmRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.TaskAlarmRequest) */ {
 public:
  TaskAlarmRequest();
  virtual ~TaskAlarmRequest();

  TaskAlarmRequest(const TaskAlarmRequest& from);

  inline TaskAlarmRequest& operator=(const TaskAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskAlarmRequest(TaskAlarmRequest&& from) noexcept
    : TaskAlarmRequest() {
    *this = ::std::move(from);
  }

  inline TaskAlarmRequest& operator=(TaskAlarmRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskAlarmRequest& default_instance();

  static inline const TaskAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const TaskAlarmRequest*>(
               &_TaskAlarmRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TaskAlarmRequest* other);
  friend void swap(TaskAlarmRequest& a, TaskAlarmRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskAlarmRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskAlarmRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskAlarmRequest& from);
  void MergeFrom(const TaskAlarmRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskAlarmRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sample_json = 10;
  int sample_json_size() const;
  void clear_sample_json();
  static const int kSampleJsonFieldNumber = 10;
  const ::std::string& sample_json(int index) const;
  ::std::string* mutable_sample_json(int index);
  void set_sample_json(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sample_json(int index, ::std::string&& value);
  #endif
  void set_sample_json(int index, const char* value);
  void set_sample_json(int index, const char* value, size_t size);
  ::std::string* add_sample_json();
  void add_sample_json(const ::std::string& value);
  #if LANG_CXX11
  void add_sample_json(::std::string&& value);
  #endif
  void add_sample_json(const char* value);
  void add_sample_json(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sample_json() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sample_json();

  // string Describe = 6;
  void clear_describe();
  static const int kDescribeFieldNumber = 6;
  const ::std::string& describe() const;
  void set_describe(const ::std::string& value);
  #if LANG_CXX11
  void set_describe(::std::string&& value);
  #endif
  void set_describe(const char* value);
  void set_describe(const char* value, size_t size);
  ::std::string* mutable_describe();
  ::std::string* release_describe();
  void set_allocated_describe(::std::string* describe);

  // .alarmpb.RequestHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::RequestHeader& head() const;
  ::alarmpb::RequestHeader* mutable_head();
  ::alarmpb::RequestHeader* release_head();
  void set_allocated_head(::alarmpb::RequestHeader* head);

  // .taskpb.Task task = 3;
  bool has_task() const;
  void clear_task();
  static const int kTaskFieldNumber = 3;
  const ::taskpb::Task& task() const;
  ::taskpb::Task* mutable_task();
  ::taskpb::Task* release_task();
  void set_allocated_task(::taskpb::Task* task);

  // .alarmpb.TaskTimeout task_timeout_alarm = 4;
  bool has_task_timeout_alarm() const;
  void clear_task_timeout_alarm();
  static const int kTaskTimeoutAlarmFieldNumber = 4;
  const ::alarmpb::TaskTimeout& task_timeout_alarm() const;
  ::alarmpb::TaskTimeout* mutable_task_timeout_alarm();
  ::alarmpb::TaskTimeout* release_task_timeout_alarm();
  void set_allocated_task_timeout_alarm(::alarmpb::TaskTimeout* task_timeout_alarm);

  // .alarmpb.TaskLongTimeRunning task_long_time_running_alarm = 5;
  bool has_task_long_time_running_alarm() const;
  void clear_task_long_time_running_alarm();
  static const int kTaskLongTimeRunningAlarmFieldNumber = 5;
  const ::alarmpb::TaskLongTimeRunning& task_long_time_running_alarm() const;
  ::alarmpb::TaskLongTimeRunning* mutable_task_long_time_running_alarm();
  ::alarmpb::TaskLongTimeRunning* release_task_long_time_running_alarm();
  void set_allocated_task_long_time_running_alarm(::alarmpb::TaskLongTimeRunning* task_long_time_running_alarm);

  // .alarmpb.TaskAlarmType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::alarmpb::TaskAlarmType type() const;
  void set_type(::alarmpb::TaskAlarmType value);

  // @@protoc_insertion_point(class_scope:alarmpb.TaskAlarmRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sample_json_;
  ::google::protobuf::internal::ArenaStringPtr describe_;
  ::alarmpb::RequestHeader* head_;
  ::taskpb::Task* task_;
  ::alarmpb::TaskTimeout* task_timeout_alarm_;
  ::alarmpb::TaskLongTimeRunning* task_long_time_running_alarm_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskTimeout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.TaskTimeout) */ {
 public:
  TaskTimeout();
  virtual ~TaskTimeout();

  TaskTimeout(const TaskTimeout& from);

  inline TaskTimeout& operator=(const TaskTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskTimeout(TaskTimeout&& from) noexcept
    : TaskTimeout() {
    *this = ::std::move(from);
  }

  inline TaskTimeout& operator=(TaskTimeout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskTimeout& default_instance();

  static inline const TaskTimeout* internal_default_instance() {
    return reinterpret_cast<const TaskTimeout*>(
               &_TaskTimeout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TaskTimeout* other);
  friend void swap(TaskTimeout& a, TaskTimeout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskTimeout* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskTimeout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskTimeout& from);
  void MergeFrom(const TaskTimeout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskTimeout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const char* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // int64 takes = 3;
  void clear_takes();
  static const int kTakesFieldNumber = 3;
  ::google::protobuf::int64 takes() const;
  void set_takes(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:alarmpb.TaskTimeout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::int64 takes_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskLongTimeRunning : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.TaskLongTimeRunning) */ {
 public:
  TaskLongTimeRunning();
  virtual ~TaskLongTimeRunning();

  TaskLongTimeRunning(const TaskLongTimeRunning& from);

  inline TaskLongTimeRunning& operator=(const TaskLongTimeRunning& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskLongTimeRunning(TaskLongTimeRunning&& from) noexcept
    : TaskLongTimeRunning() {
    *this = ::std::move(from);
  }

  inline TaskLongTimeRunning& operator=(TaskLongTimeRunning&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskLongTimeRunning& default_instance();

  static inline const TaskLongTimeRunning* internal_default_instance() {
    return reinterpret_cast<const TaskLongTimeRunning*>(
               &_TaskLongTimeRunning_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TaskLongTimeRunning* other);
  friend void swap(TaskLongTimeRunning& a, TaskLongTimeRunning& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskLongTimeRunning* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskLongTimeRunning* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskLongTimeRunning& from);
  void MergeFrom(const TaskLongTimeRunning& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskLongTimeRunning* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const char* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // int64 takes = 3;
  void clear_takes();
  static const int kTakesFieldNumber = 3;
  ::google::protobuf::int64 takes() const;
  void set_takes(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:alarmpb.TaskLongTimeRunning)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::int64 takes_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskAlarmResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.TaskAlarmResponse) */ {
 public:
  TaskAlarmResponse();
  virtual ~TaskAlarmResponse();

  TaskAlarmResponse(const TaskAlarmResponse& from);

  inline TaskAlarmResponse& operator=(const TaskAlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskAlarmResponse(TaskAlarmResponse&& from) noexcept
    : TaskAlarmResponse() {
    *this = ::std::move(from);
  }

  inline TaskAlarmResponse& operator=(TaskAlarmResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskAlarmResponse& default_instance();

  static inline const TaskAlarmResponse* internal_default_instance() {
    return reinterpret_cast<const TaskAlarmResponse*>(
               &_TaskAlarmResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TaskAlarmResponse* other);
  friend void swap(TaskAlarmResponse& a, TaskAlarmResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskAlarmResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskAlarmResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskAlarmResponse& from);
  void MergeFrom(const TaskAlarmResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskAlarmResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb.ResponseHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::ResponseHeader& head() const;
  ::alarmpb::ResponseHeader* mutable_head();
  ::alarmpb::ResponseHeader* release_head();
  void set_allocated_head(::alarmpb::ResponseHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.TaskAlarmResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb::ResponseHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeRangeAlarmRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.NodeRangeAlarmRequest) */ {
 public:
  NodeRangeAlarmRequest();
  virtual ~NodeRangeAlarmRequest();

  NodeRangeAlarmRequest(const NodeRangeAlarmRequest& from);

  inline NodeRangeAlarmRequest& operator=(const NodeRangeAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeRangeAlarmRequest(NodeRangeAlarmRequest&& from) noexcept
    : NodeRangeAlarmRequest() {
    *this = ::std::move(from);
  }

  inline NodeRangeAlarmRequest& operator=(NodeRangeAlarmRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRangeAlarmRequest& default_instance();

  static inline const NodeRangeAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRangeAlarmRequest*>(
               &_NodeRangeAlarmRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(NodeRangeAlarmRequest* other);
  friend void swap(NodeRangeAlarmRequest& a, NodeRangeAlarmRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeRangeAlarmRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeRangeAlarmRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeRangeAlarmRequest& from);
  void MergeFrom(const NodeRangeAlarmRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeRangeAlarmRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sample_json = 10;
  int sample_json_size() const;
  void clear_sample_json();
  static const int kSampleJsonFieldNumber = 10;
  const ::std::string& sample_json(int index) const;
  ::std::string* mutable_sample_json(int index);
  void set_sample_json(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sample_json(int index, ::std::string&& value);
  #endif
  void set_sample_json(int index, const char* value);
  void set_sample_json(int index, const char* value, size_t size);
  ::std::string* add_sample_json();
  void add_sample_json(const ::std::string& value);
  #if LANG_CXX11
  void add_sample_json(::std::string&& value);
  #endif
  void add_sample_json(const char* value);
  void add_sample_json(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sample_json() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sample_json();

  // string Describe = 7;
  void clear_describe();
  static const int kDescribeFieldNumber = 7;
  const ::std::string& describe() const;
  void set_describe(const ::std::string& value);
  #if LANG_CXX11
  void set_describe(::std::string&& value);
  #endif
  void set_describe(const char* value);
  void set_describe(const char* value, size_t size);
  ::std::string* mutable_describe();
  ::std::string* release_describe();
  void set_allocated_describe(::std::string* describe);

  // .alarmpb.RequestHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::RequestHeader& head() const;
  ::alarmpb::RequestHeader* mutable_head();
  ::alarmpb::RequestHeader* release_head();
  void set_allocated_head(::alarmpb::RequestHeader* head);

  // .alarmpb.RangeNoHeartbeatAlarm range_no_hb_alarm = 3;
  bool has_range_no_hb_alarm() const;
  void clear_range_no_hb_alarm();
  static const int kRangeNoHbAlarmFieldNumber = 3;
  const ::alarmpb::RangeNoHeartbeatAlarm& range_no_hb_alarm() const;
  ::alarmpb::RangeNoHeartbeatAlarm* mutable_range_no_hb_alarm();
  ::alarmpb::RangeNoHeartbeatAlarm* release_range_no_hb_alarm();
  void set_allocated_range_no_hb_alarm(::alarmpb::RangeNoHeartbeatAlarm* range_no_hb_alarm);

  // .alarmpb.NodeNoHeartbeatAlarm node_no_hb_alarm = 4;
  bool has_node_no_hb_alarm() const;
  void clear_node_no_hb_alarm();
  static const int kNodeNoHbAlarmFieldNumber = 4;
  const ::alarmpb::NodeNoHeartbeatAlarm& node_no_hb_alarm() const;
  ::alarmpb::NodeNoHeartbeatAlarm* mutable_node_no_hb_alarm();
  ::alarmpb::NodeNoHeartbeatAlarm* release_node_no_hb_alarm();
  void set_allocated_node_no_hb_alarm(::alarmpb::NodeNoHeartbeatAlarm* node_no_hb_alarm);

  // .alarmpb.NodeDiskSizeAlarm node_disk_size_alarm = 5;
  bool has_node_disk_size_alarm() const;
  void clear_node_disk_size_alarm();
  static const int kNodeDiskSizeAlarmFieldNumber = 5;
  const ::alarmpb::NodeDiskSizeAlarm& node_disk_size_alarm() const;
  ::alarmpb::NodeDiskSizeAlarm* mutable_node_disk_size_alarm();
  ::alarmpb::NodeDiskSizeAlarm* release_node_disk_size_alarm();
  void set_allocated_node_disk_size_alarm(::alarmpb::NodeDiskSizeAlarm* node_disk_size_alarm);

  // .alarmpb.NodeLeaderCountAlarm node_leader_count_alarm = 6;
  bool has_node_leader_count_alarm() const;
  void clear_node_leader_count_alarm();
  static const int kNodeLeaderCountAlarmFieldNumber = 6;
  const ::alarmpb::NodeLeaderCountAlarm& node_leader_count_alarm() const;
  ::alarmpb::NodeLeaderCountAlarm* mutable_node_leader_count_alarm();
  ::alarmpb::NodeLeaderCountAlarm* release_node_leader_count_alarm();
  void set_allocated_node_leader_count_alarm(::alarmpb::NodeLeaderCountAlarm* node_leader_count_alarm);

  // .alarmpb.NodeRangeAlarmType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::alarmpb::NodeRangeAlarmType type() const;
  void set_type(::alarmpb::NodeRangeAlarmType value);

  // @@protoc_insertion_point(class_scope:alarmpb.NodeRangeAlarmRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sample_json_;
  ::google::protobuf::internal::ArenaStringPtr describe_;
  ::alarmpb::RequestHeader* head_;
  ::alarmpb::RangeNoHeartbeatAlarm* range_no_hb_alarm_;
  ::alarmpb::NodeNoHeartbeatAlarm* node_no_hb_alarm_;
  ::alarmpb::NodeDiskSizeAlarm* node_disk_size_alarm_;
  ::alarmpb::NodeLeaderCountAlarm* node_leader_count_alarm_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeNoHeartbeatAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.RangeNoHeartbeatAlarm) */ {
 public:
  RangeNoHeartbeatAlarm();
  virtual ~RangeNoHeartbeatAlarm();

  RangeNoHeartbeatAlarm(const RangeNoHeartbeatAlarm& from);

  inline RangeNoHeartbeatAlarm& operator=(const RangeNoHeartbeatAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeNoHeartbeatAlarm(RangeNoHeartbeatAlarm&& from) noexcept
    : RangeNoHeartbeatAlarm() {
    *this = ::std::move(from);
  }

  inline RangeNoHeartbeatAlarm& operator=(RangeNoHeartbeatAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeNoHeartbeatAlarm& default_instance();

  static inline const RangeNoHeartbeatAlarm* internal_default_instance() {
    return reinterpret_cast<const RangeNoHeartbeatAlarm*>(
               &_RangeNoHeartbeatAlarm_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RangeNoHeartbeatAlarm* other);
  friend void swap(RangeNoHeartbeatAlarm& a, RangeNoHeartbeatAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeNoHeartbeatAlarm* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeNoHeartbeatAlarm* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeNoHeartbeatAlarm& from);
  void MergeFrom(const RangeNoHeartbeatAlarm& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeNoHeartbeatAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string last_heartbeat_time = 2;
  void clear_last_heartbeat_time();
  static const int kLastHeartbeatTimeFieldNumber = 2;
  const ::std::string& last_heartbeat_time() const;
  void set_last_heartbeat_time(const ::std::string& value);
  #if LANG_CXX11
  void set_last_heartbeat_time(::std::string&& value);
  #endif
  void set_last_heartbeat_time(const char* value);
  void set_last_heartbeat_time(const char* value, size_t size);
  ::std::string* mutable_last_heartbeat_time();
  ::std::string* release_last_heartbeat_time();
  void set_allocated_last_heartbeat_time(::std::string* last_heartbeat_time);

  // .metapb.Range range = 1;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  const ::metapb::Range& range() const;
  ::metapb::Range* mutable_range();
  ::metapb::Range* release_range();
  void set_allocated_range(::metapb::Range* range);

  // @@protoc_insertion_point(class_scope:alarmpb.RangeNoHeartbeatAlarm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr last_heartbeat_time_;
  ::metapb::Range* range_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeNoHeartbeatAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.NodeNoHeartbeatAlarm) */ {
 public:
  NodeNoHeartbeatAlarm();
  virtual ~NodeNoHeartbeatAlarm();

  NodeNoHeartbeatAlarm(const NodeNoHeartbeatAlarm& from);

  inline NodeNoHeartbeatAlarm& operator=(const NodeNoHeartbeatAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeNoHeartbeatAlarm(NodeNoHeartbeatAlarm&& from) noexcept
    : NodeNoHeartbeatAlarm() {
    *this = ::std::move(from);
  }

  inline NodeNoHeartbeatAlarm& operator=(NodeNoHeartbeatAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeNoHeartbeatAlarm& default_instance();

  static inline const NodeNoHeartbeatAlarm* internal_default_instance() {
    return reinterpret_cast<const NodeNoHeartbeatAlarm*>(
               &_NodeNoHeartbeatAlarm_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(NodeNoHeartbeatAlarm* other);
  friend void swap(NodeNoHeartbeatAlarm& a, NodeNoHeartbeatAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeNoHeartbeatAlarm* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeNoHeartbeatAlarm* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeNoHeartbeatAlarm& from);
  void MergeFrom(const NodeNoHeartbeatAlarm& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeNoHeartbeatAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string last_heartbeat_time = 2;
  void clear_last_heartbeat_time();
  static const int kLastHeartbeatTimeFieldNumber = 2;
  const ::std::string& last_heartbeat_time() const;
  void set_last_heartbeat_time(const ::std::string& value);
  #if LANG_CXX11
  void set_last_heartbeat_time(::std::string&& value);
  #endif
  void set_last_heartbeat_time(const char* value);
  void set_last_heartbeat_time(const char* value, size_t size);
  ::std::string* mutable_last_heartbeat_time();
  ::std::string* release_last_heartbeat_time();
  void set_allocated_last_heartbeat_time(::std::string* last_heartbeat_time);

  // .metapb.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::metapb::Node& node() const;
  ::metapb::Node* mutable_node();
  ::metapb::Node* release_node();
  void set_allocated_node(::metapb::Node* node);

  // @@protoc_insertion_point(class_scope:alarmpb.NodeNoHeartbeatAlarm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr last_heartbeat_time_;
  ::metapb::Node* node_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeDiskSizeAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.NodeDiskSizeAlarm) */ {
 public:
  NodeDiskSizeAlarm();
  virtual ~NodeDiskSizeAlarm();

  NodeDiskSizeAlarm(const NodeDiskSizeAlarm& from);

  inline NodeDiskSizeAlarm& operator=(const NodeDiskSizeAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeDiskSizeAlarm(NodeDiskSizeAlarm&& from) noexcept
    : NodeDiskSizeAlarm() {
    *this = ::std::move(from);
  }

  inline NodeDiskSizeAlarm& operator=(NodeDiskSizeAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeDiskSizeAlarm& default_instance();

  static inline const NodeDiskSizeAlarm* internal_default_instance() {
    return reinterpret_cast<const NodeDiskSizeAlarm*>(
               &_NodeDiskSizeAlarm_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(NodeDiskSizeAlarm* other);
  friend void swap(NodeDiskSizeAlarm& a, NodeDiskSizeAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeDiskSizeAlarm* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeDiskSizeAlarm* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeDiskSizeAlarm& from);
  void MergeFrom(const NodeDiskSizeAlarm& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeDiskSizeAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::metapb::Node& node() const;
  ::metapb::Node* mutable_node();
  ::metapb::Node* release_node();
  void set_allocated_node(::metapb::Node* node);

  // int64 disk_size = 2;
  void clear_disk_size();
  static const int kDiskSizeFieldNumber = 2;
  ::google::protobuf::int64 disk_size() const;
  void set_disk_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:alarmpb.NodeDiskSizeAlarm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Node* node_;
  ::google::protobuf::int64 disk_size_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeLeaderCountAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.NodeLeaderCountAlarm) */ {
 public:
  NodeLeaderCountAlarm();
  virtual ~NodeLeaderCountAlarm();

  NodeLeaderCountAlarm(const NodeLeaderCountAlarm& from);

  inline NodeLeaderCountAlarm& operator=(const NodeLeaderCountAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeLeaderCountAlarm(NodeLeaderCountAlarm&& from) noexcept
    : NodeLeaderCountAlarm() {
    *this = ::std::move(from);
  }

  inline NodeLeaderCountAlarm& operator=(NodeLeaderCountAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeLeaderCountAlarm& default_instance();

  static inline const NodeLeaderCountAlarm* internal_default_instance() {
    return reinterpret_cast<const NodeLeaderCountAlarm*>(
               &_NodeLeaderCountAlarm_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(NodeLeaderCountAlarm* other);
  friend void swap(NodeLeaderCountAlarm& a, NodeLeaderCountAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeLeaderCountAlarm* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeLeaderCountAlarm* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeLeaderCountAlarm& from);
  void MergeFrom(const NodeLeaderCountAlarm& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeLeaderCountAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::metapb::Node& node() const;
  ::metapb::Node* mutable_node();
  ::metapb::Node* release_node();
  void set_allocated_node(::metapb::Node* node);

  // int64 leader_count = 2;
  void clear_leader_count();
  static const int kLeaderCountFieldNumber = 2;
  ::google::protobuf::int64 leader_count() const;
  void set_leader_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:alarmpb.NodeLeaderCountAlarm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Node* node_;
  ::google::protobuf::int64 leader_count_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeRangeAlarmResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.NodeRangeAlarmResponse) */ {
 public:
  NodeRangeAlarmResponse();
  virtual ~NodeRangeAlarmResponse();

  NodeRangeAlarmResponse(const NodeRangeAlarmResponse& from);

  inline NodeRangeAlarmResponse& operator=(const NodeRangeAlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeRangeAlarmResponse(NodeRangeAlarmResponse&& from) noexcept
    : NodeRangeAlarmResponse() {
    *this = ::std::move(from);
  }

  inline NodeRangeAlarmResponse& operator=(NodeRangeAlarmResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRangeAlarmResponse& default_instance();

  static inline const NodeRangeAlarmResponse* internal_default_instance() {
    return reinterpret_cast<const NodeRangeAlarmResponse*>(
               &_NodeRangeAlarmResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(NodeRangeAlarmResponse* other);
  friend void swap(NodeRangeAlarmResponse& a, NodeRangeAlarmResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeRangeAlarmResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeRangeAlarmResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeRangeAlarmResponse& from);
  void MergeFrom(const NodeRangeAlarmResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeRangeAlarmResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb.ResponseHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::ResponseHeader& head() const;
  ::alarmpb::ResponseHeader* mutable_head();
  ::alarmpb::ResponseHeader* release_head();
  void set_allocated_head(::alarmpb::ResponseHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.NodeRangeAlarmResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb::ResponseHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AliveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.AliveRequest) */ {
 public:
  AliveRequest();
  virtual ~AliveRequest();

  AliveRequest(const AliveRequest& from);

  inline AliveRequest& operator=(const AliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AliveRequest(AliveRequest&& from) noexcept
    : AliveRequest() {
    *this = ::std::move(from);
  }

  inline AliveRequest& operator=(AliveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AliveRequest& default_instance();

  static inline const AliveRequest* internal_default_instance() {
    return reinterpret_cast<const AliveRequest*>(
               &_AliveRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(AliveRequest* other);
  friend void swap(AliveRequest& a, AliveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AliveRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AliveRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AliveRequest& from);
  void MergeFrom(const AliveRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AliveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sample_json = 10;
  int sample_json_size() const;
  void clear_sample_json();
  static const int kSampleJsonFieldNumber = 10;
  const ::std::string& sample_json(int index) const;
  ::std::string* mutable_sample_json(int index);
  void set_sample_json(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sample_json(int index, ::std::string&& value);
  #endif
  void set_sample_json(int index, const char* value);
  void set_sample_json(int index, const char* value, size_t size);
  ::std::string* add_sample_json();
  void add_sample_json(const ::std::string& value);
  #if LANG_CXX11
  void add_sample_json(::std::string&& value);
  #endif
  void add_sample_json(const char* value);
  void add_sample_json(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sample_json() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sample_json();

  // .alarmpb.RequestHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::RequestHeader& head() const;
  ::alarmpb::RequestHeader* mutable_head();
  ::alarmpb::RequestHeader* release_head();
  void set_allocated_head(::alarmpb::RequestHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.AliveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sample_json_;
  ::alarmpb::RequestHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AliveResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.AliveResponse) */ {
 public:
  AliveResponse();
  virtual ~AliveResponse();

  AliveResponse(const AliveResponse& from);

  inline AliveResponse& operator=(const AliveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AliveResponse(AliveResponse&& from) noexcept
    : AliveResponse() {
    *this = ::std::move(from);
  }

  inline AliveResponse& operator=(AliveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AliveResponse& default_instance();

  static inline const AliveResponse* internal_default_instance() {
    return reinterpret_cast<const AliveResponse*>(
               &_AliveResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(AliveResponse* other);
  friend void swap(AliveResponse& a, AliveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AliveResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AliveResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AliveResponse& from);
  void MergeFrom(const AliveResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AliveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb.ResponseHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::ResponseHeader& head() const;
  ::alarmpb::ResponseHeader* mutable_head();
  ::alarmpb::ResponseHeader* release_head();
  void set_allocated_head(::alarmpb::ResponseHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.AliveResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb::ResponseHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimpleRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.SimpleRequest) */ {
 public:
  SimpleRequest();
  virtual ~SimpleRequest();

  SimpleRequest(const SimpleRequest& from);

  inline SimpleRequest& operator=(const SimpleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimpleRequest(SimpleRequest&& from) noexcept
    : SimpleRequest() {
    *this = ::std::move(from);
  }

  inline SimpleRequest& operator=(SimpleRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleRequest& default_instance();

  static inline const SimpleRequest* internal_default_instance() {
    return reinterpret_cast<const SimpleRequest*>(
               &_SimpleRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SimpleRequest* other);
  friend void swap(SimpleRequest& a, SimpleRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimpleRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SimpleRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimpleRequest& from);
  void MergeFrom(const SimpleRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimpleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sample_json = 10;
  int sample_json_size() const;
  void clear_sample_json();
  static const int kSampleJsonFieldNumber = 10;
  const ::std::string& sample_json(int index) const;
  ::std::string* mutable_sample_json(int index);
  void set_sample_json(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sample_json(int index, ::std::string&& value);
  #endif
  void set_sample_json(int index, const char* value);
  void set_sample_json(int index, const char* value, size_t size);
  ::std::string* add_sample_json();
  void add_sample_json(const ::std::string& value);
  #if LANG_CXX11
  void add_sample_json(::std::string&& value);
  #endif
  void add_sample_json(const char* value);
  void add_sample_json(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sample_json() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sample_json();

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string content = 3;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // .alarmpb.RequestHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::RequestHeader& head() const;
  ::alarmpb::RequestHeader* mutable_head();
  ::alarmpb::RequestHeader* release_head();
  void set_allocated_head(::alarmpb::RequestHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.SimpleRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sample_json_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::alarmpb::RequestHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimpleResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:alarmpb.SimpleResponse) */ {
 public:
  SimpleResponse();
  virtual ~SimpleResponse();

  SimpleResponse(const SimpleResponse& from);

  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimpleResponse(SimpleResponse&& from) noexcept
    : SimpleResponse() {
    *this = ::std::move(from);
  }

  inline SimpleResponse& operator=(SimpleResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleResponse& default_instance();

  static inline const SimpleResponse* internal_default_instance() {
    return reinterpret_cast<const SimpleResponse*>(
               &_SimpleResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(SimpleResponse* other);
  friend void swap(SimpleResponse& a, SimpleResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimpleResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SimpleResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimpleResponse& from);
  void MergeFrom(const SimpleResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimpleResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .alarmpb.ResponseHeader head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  const ::alarmpb::ResponseHeader& head() const;
  ::alarmpb::ResponseHeader* mutable_head();
  ::alarmpb::ResponseHeader* release_head();
  void set_allocated_head(::alarmpb::ResponseHeader* head);

  // @@protoc_insertion_point(class_scope:alarmpb.SimpleResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::alarmpb::ResponseHeader* head_;
  mutable int _cached_size_;
  friend struct protobuf_alarmpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// int64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:alarmpb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::int64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.RequestHeader.cluster_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// int32 code = 1;
inline void ResponseHeader::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ResponseHeader::code() const {
  // @@protoc_insertion_point(field_get:alarmpb.ResponseHeader.code)
  return code_;
}
inline void ResponseHeader::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.ResponseHeader.code)
}

// string error = 2;
inline void ResponseHeader::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseHeader::error() const {
  // @@protoc_insertion_point(field_get:alarmpb.ResponseHeader.error)
  return error_.GetNoArena();
}
inline void ResponseHeader::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.ResponseHeader.error)
}
#if LANG_CXX11
inline void ResponseHeader::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.ResponseHeader.error)
}
#endif
inline void ResponseHeader::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.ResponseHeader.error)
}
inline void ResponseHeader::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.ResponseHeader.error)
}
inline ::std::string* ResponseHeader::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.ResponseHeader.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:alarmpb.ResponseHeader.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseHeader::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// SimpleAlarmRequest

// .alarmpb.RequestHeader head = 1;
inline bool SimpleAlarmRequest::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void SimpleAlarmRequest::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::RequestHeader& SimpleAlarmRequest::head() const {
  const ::alarmpb::RequestHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.SimpleAlarmRequest.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::RequestHeader*>(
      &::alarmpb::_RequestHeader_default_instance_);
}
inline ::alarmpb::RequestHeader* SimpleAlarmRequest::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleAlarmRequest.head)
  return head_;
}
inline ::alarmpb::RequestHeader* SimpleAlarmRequest::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleAlarmRequest.head)
  
  ::alarmpb::RequestHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void SimpleAlarmRequest::set_allocated_head(::alarmpb::RequestHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleAlarmRequest.head)
}

// string Describe = 2;
inline void SimpleAlarmRequest::clear_describe() {
  describe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleAlarmRequest::describe() const {
  // @@protoc_insertion_point(field_get:alarmpb.SimpleAlarmRequest.Describe)
  return describe_.GetNoArena();
}
inline void SimpleAlarmRequest::set_describe(const ::std::string& value) {
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.SimpleAlarmRequest.Describe)
}
#if LANG_CXX11
inline void SimpleAlarmRequest::set_describe(::std::string&& value) {
  
  describe_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.SimpleAlarmRequest.Describe)
}
#endif
inline void SimpleAlarmRequest::set_describe(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.SimpleAlarmRequest.Describe)
}
inline void SimpleAlarmRequest::set_describe(const char* value, size_t size) {
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.SimpleAlarmRequest.Describe)
}
inline ::std::string* SimpleAlarmRequest::mutable_describe() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleAlarmRequest.Describe)
  return describe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleAlarmRequest::release_describe() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleAlarmRequest.Describe)
  
  return describe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAlarmRequest::set_allocated_describe(::std::string* describe) {
  if (describe != NULL) {
    
  } else {
    
  }
  describe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), describe);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleAlarmRequest.Describe)
}

// -------------------------------------------------------------------

// SimpleAlarmResponse

// .alarmpb.ResponseHeader head = 1;
inline bool SimpleAlarmResponse::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void SimpleAlarmResponse::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::ResponseHeader& SimpleAlarmResponse::head() const {
  const ::alarmpb::ResponseHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.SimpleAlarmResponse.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::ResponseHeader*>(
      &::alarmpb::_ResponseHeader_default_instance_);
}
inline ::alarmpb::ResponseHeader* SimpleAlarmResponse::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleAlarmResponse.head)
  return head_;
}
inline ::alarmpb::ResponseHeader* SimpleAlarmResponse::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleAlarmResponse.head)
  
  ::alarmpb::ResponseHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void SimpleAlarmResponse::set_allocated_head(::alarmpb::ResponseHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleAlarmResponse.head)
}

// -------------------------------------------------------------------

// TaskAlarmRequest

// .alarmpb.RequestHeader head = 1;
inline bool TaskAlarmRequest::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void TaskAlarmRequest::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::RequestHeader& TaskAlarmRequest::head() const {
  const ::alarmpb::RequestHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::RequestHeader*>(
      &::alarmpb::_RequestHeader_default_instance_);
}
inline ::alarmpb::RequestHeader* TaskAlarmRequest::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmRequest.head)
  return head_;
}
inline ::alarmpb::RequestHeader* TaskAlarmRequest::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskAlarmRequest.head)
  
  ::alarmpb::RequestHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void TaskAlarmRequest::set_allocated_head(::alarmpb::RequestHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskAlarmRequest.head)
}

// .alarmpb.TaskAlarmType type = 2;
inline void TaskAlarmRequest::clear_type() {
  type_ = 0;
}
inline ::alarmpb::TaskAlarmType TaskAlarmRequest::type() const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.type)
  return static_cast< ::alarmpb::TaskAlarmType >(type_);
}
inline void TaskAlarmRequest::set_type(::alarmpb::TaskAlarmType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.TaskAlarmRequest.type)
}

// .taskpb.Task task = 3;
inline bool TaskAlarmRequest::has_task() const {
  return this != internal_default_instance() && task_ != NULL;
}
inline void TaskAlarmRequest::clear_task() {
  if (GetArenaNoVirtual() == NULL && task_ != NULL) delete task_;
  task_ = NULL;
}
inline const ::taskpb::Task& TaskAlarmRequest::task() const {
  const ::taskpb::Task* p = task_;
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.task)
  return p != NULL ? *p : *reinterpret_cast<const ::taskpb::Task*>(
      &::taskpb::_Task_default_instance_);
}
inline ::taskpb::Task* TaskAlarmRequest::mutable_task() {
  
  if (task_ == NULL) {
    task_ = new ::taskpb::Task;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmRequest.task)
  return task_;
}
inline ::taskpb::Task* TaskAlarmRequest::release_task() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskAlarmRequest.task)
  
  ::taskpb::Task* temp = task_;
  task_ = NULL;
  return temp;
}
inline void TaskAlarmRequest::set_allocated_task(::taskpb::Task* task) {
  delete task_;
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskAlarmRequest.task)
}

// .alarmpb.TaskTimeout task_timeout_alarm = 4;
inline bool TaskAlarmRequest::has_task_timeout_alarm() const {
  return this != internal_default_instance() && task_timeout_alarm_ != NULL;
}
inline void TaskAlarmRequest::clear_task_timeout_alarm() {
  if (GetArenaNoVirtual() == NULL && task_timeout_alarm_ != NULL) delete task_timeout_alarm_;
  task_timeout_alarm_ = NULL;
}
inline const ::alarmpb::TaskTimeout& TaskAlarmRequest::task_timeout_alarm() const {
  const ::alarmpb::TaskTimeout* p = task_timeout_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.task_timeout_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::TaskTimeout*>(
      &::alarmpb::_TaskTimeout_default_instance_);
}
inline ::alarmpb::TaskTimeout* TaskAlarmRequest::mutable_task_timeout_alarm() {
  
  if (task_timeout_alarm_ == NULL) {
    task_timeout_alarm_ = new ::alarmpb::TaskTimeout;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmRequest.task_timeout_alarm)
  return task_timeout_alarm_;
}
inline ::alarmpb::TaskTimeout* TaskAlarmRequest::release_task_timeout_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskAlarmRequest.task_timeout_alarm)
  
  ::alarmpb::TaskTimeout* temp = task_timeout_alarm_;
  task_timeout_alarm_ = NULL;
  return temp;
}
inline void TaskAlarmRequest::set_allocated_task_timeout_alarm(::alarmpb::TaskTimeout* task_timeout_alarm) {
  delete task_timeout_alarm_;
  task_timeout_alarm_ = task_timeout_alarm;
  if (task_timeout_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskAlarmRequest.task_timeout_alarm)
}

// .alarmpb.TaskLongTimeRunning task_long_time_running_alarm = 5;
inline bool TaskAlarmRequest::has_task_long_time_running_alarm() const {
  return this != internal_default_instance() && task_long_time_running_alarm_ != NULL;
}
inline void TaskAlarmRequest::clear_task_long_time_running_alarm() {
  if (GetArenaNoVirtual() == NULL && task_long_time_running_alarm_ != NULL) delete task_long_time_running_alarm_;
  task_long_time_running_alarm_ = NULL;
}
inline const ::alarmpb::TaskLongTimeRunning& TaskAlarmRequest::task_long_time_running_alarm() const {
  const ::alarmpb::TaskLongTimeRunning* p = task_long_time_running_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.task_long_time_running_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::TaskLongTimeRunning*>(
      &::alarmpb::_TaskLongTimeRunning_default_instance_);
}
inline ::alarmpb::TaskLongTimeRunning* TaskAlarmRequest::mutable_task_long_time_running_alarm() {
  
  if (task_long_time_running_alarm_ == NULL) {
    task_long_time_running_alarm_ = new ::alarmpb::TaskLongTimeRunning;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmRequest.task_long_time_running_alarm)
  return task_long_time_running_alarm_;
}
inline ::alarmpb::TaskLongTimeRunning* TaskAlarmRequest::release_task_long_time_running_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskAlarmRequest.task_long_time_running_alarm)
  
  ::alarmpb::TaskLongTimeRunning* temp = task_long_time_running_alarm_;
  task_long_time_running_alarm_ = NULL;
  return temp;
}
inline void TaskAlarmRequest::set_allocated_task_long_time_running_alarm(::alarmpb::TaskLongTimeRunning* task_long_time_running_alarm) {
  delete task_long_time_running_alarm_;
  task_long_time_running_alarm_ = task_long_time_running_alarm;
  if (task_long_time_running_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskAlarmRequest.task_long_time_running_alarm)
}

// string Describe = 6;
inline void TaskAlarmRequest::clear_describe() {
  describe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskAlarmRequest::describe() const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.Describe)
  return describe_.GetNoArena();
}
inline void TaskAlarmRequest::set_describe(const ::std::string& value) {
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.TaskAlarmRequest.Describe)
}
#if LANG_CXX11
inline void TaskAlarmRequest::set_describe(::std::string&& value) {
  
  describe_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.TaskAlarmRequest.Describe)
}
#endif
inline void TaskAlarmRequest::set_describe(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.TaskAlarmRequest.Describe)
}
inline void TaskAlarmRequest::set_describe(const char* value, size_t size) {
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.TaskAlarmRequest.Describe)
}
inline ::std::string* TaskAlarmRequest::mutable_describe() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmRequest.Describe)
  return describe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskAlarmRequest::release_describe() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskAlarmRequest.Describe)
  
  return describe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskAlarmRequest::set_allocated_describe(::std::string* describe) {
  if (describe != NULL) {
    
  } else {
    
  }
  describe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), describe);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskAlarmRequest.Describe)
}

// repeated string sample_json = 10;
inline int TaskAlarmRequest::sample_json_size() const {
  return sample_json_.size();
}
inline void TaskAlarmRequest::clear_sample_json() {
  sample_json_.Clear();
}
inline const ::std::string& TaskAlarmRequest::sample_json(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmRequest.sample_json)
  return sample_json_.Get(index);
}
inline ::std::string* TaskAlarmRequest::mutable_sample_json(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmRequest.sample_json)
  return sample_json_.Mutable(index);
}
inline void TaskAlarmRequest::set_sample_json(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb.TaskAlarmRequest.sample_json)
  sample_json_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TaskAlarmRequest::set_sample_json(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb.TaskAlarmRequest.sample_json)
  sample_json_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TaskAlarmRequest::set_sample_json(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb.TaskAlarmRequest.sample_json)
}
inline void TaskAlarmRequest::set_sample_json(int index, const char* value, size_t size) {
  sample_json_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb.TaskAlarmRequest.sample_json)
}
inline ::std::string* TaskAlarmRequest::add_sample_json() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb.TaskAlarmRequest.sample_json)
  return sample_json_.Add();
}
inline void TaskAlarmRequest::add_sample_json(const ::std::string& value) {
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb.TaskAlarmRequest.sample_json)
}
#if LANG_CXX11
inline void TaskAlarmRequest::add_sample_json(::std::string&& value) {
  sample_json_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb.TaskAlarmRequest.sample_json)
}
#endif
inline void TaskAlarmRequest::add_sample_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb.TaskAlarmRequest.sample_json)
}
inline void TaskAlarmRequest::add_sample_json(const char* value, size_t size) {
  sample_json_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb.TaskAlarmRequest.sample_json)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskAlarmRequest::sample_json() const {
  // @@protoc_insertion_point(field_list:alarmpb.TaskAlarmRequest.sample_json)
  return sample_json_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskAlarmRequest::mutable_sample_json() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb.TaskAlarmRequest.sample_json)
  return &sample_json_;
}

// -------------------------------------------------------------------

// TaskTimeout

// string start = 2;
inline void TaskTimeout::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskTimeout::start() const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskTimeout.start)
  return start_.GetNoArena();
}
inline void TaskTimeout::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.TaskTimeout.start)
}
#if LANG_CXX11
inline void TaskTimeout::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.TaskTimeout.start)
}
#endif
inline void TaskTimeout::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.TaskTimeout.start)
}
inline void TaskTimeout::set_start(const char* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.TaskTimeout.start)
}
inline ::std::string* TaskTimeout::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskTimeout.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskTimeout::release_start() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskTimeout.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskTimeout::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskTimeout.start)
}

// int64 takes = 3;
inline void TaskTimeout::clear_takes() {
  takes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskTimeout::takes() const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskTimeout.takes)
  return takes_;
}
inline void TaskTimeout::set_takes(::google::protobuf::int64 value) {
  
  takes_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.TaskTimeout.takes)
}

// -------------------------------------------------------------------

// TaskLongTimeRunning

// string start = 2;
inline void TaskLongTimeRunning::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskLongTimeRunning::start() const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskLongTimeRunning.start)
  return start_.GetNoArena();
}
inline void TaskLongTimeRunning::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.TaskLongTimeRunning.start)
}
#if LANG_CXX11
inline void TaskLongTimeRunning::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.TaskLongTimeRunning.start)
}
#endif
inline void TaskLongTimeRunning::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.TaskLongTimeRunning.start)
}
inline void TaskLongTimeRunning::set_start(const char* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.TaskLongTimeRunning.start)
}
inline ::std::string* TaskLongTimeRunning::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskLongTimeRunning.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskLongTimeRunning::release_start() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskLongTimeRunning.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskLongTimeRunning::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskLongTimeRunning.start)
}

// int64 takes = 3;
inline void TaskLongTimeRunning::clear_takes() {
  takes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskLongTimeRunning::takes() const {
  // @@protoc_insertion_point(field_get:alarmpb.TaskLongTimeRunning.takes)
  return takes_;
}
inline void TaskLongTimeRunning::set_takes(::google::protobuf::int64 value) {
  
  takes_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.TaskLongTimeRunning.takes)
}

// -------------------------------------------------------------------

// TaskAlarmResponse

// .alarmpb.ResponseHeader head = 1;
inline bool TaskAlarmResponse::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void TaskAlarmResponse::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::ResponseHeader& TaskAlarmResponse::head() const {
  const ::alarmpb::ResponseHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.TaskAlarmResponse.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::ResponseHeader*>(
      &::alarmpb::_ResponseHeader_default_instance_);
}
inline ::alarmpb::ResponseHeader* TaskAlarmResponse::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.TaskAlarmResponse.head)
  return head_;
}
inline ::alarmpb::ResponseHeader* TaskAlarmResponse::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.TaskAlarmResponse.head)
  
  ::alarmpb::ResponseHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void TaskAlarmResponse::set_allocated_head(::alarmpb::ResponseHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.TaskAlarmResponse.head)
}

// -------------------------------------------------------------------

// NodeRangeAlarmRequest

// .alarmpb.RequestHeader head = 1;
inline bool NodeRangeAlarmRequest::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void NodeRangeAlarmRequest::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::RequestHeader& NodeRangeAlarmRequest::head() const {
  const ::alarmpb::RequestHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::RequestHeader*>(
      &::alarmpb::_RequestHeader_default_instance_);
}
inline ::alarmpb::RequestHeader* NodeRangeAlarmRequest::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.head)
  return head_;
}
inline ::alarmpb::RequestHeader* NodeRangeAlarmRequest::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmRequest.head)
  
  ::alarmpb::RequestHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void NodeRangeAlarmRequest::set_allocated_head(::alarmpb::RequestHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmRequest.head)
}

// .alarmpb.NodeRangeAlarmType type = 2;
inline void NodeRangeAlarmRequest::clear_type() {
  type_ = 0;
}
inline ::alarmpb::NodeRangeAlarmType NodeRangeAlarmRequest::type() const {
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.type)
  return static_cast< ::alarmpb::NodeRangeAlarmType >(type_);
}
inline void NodeRangeAlarmRequest::set_type(::alarmpb::NodeRangeAlarmType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.NodeRangeAlarmRequest.type)
}

// .alarmpb.RangeNoHeartbeatAlarm range_no_hb_alarm = 3;
inline bool NodeRangeAlarmRequest::has_range_no_hb_alarm() const {
  return this != internal_default_instance() && range_no_hb_alarm_ != NULL;
}
inline void NodeRangeAlarmRequest::clear_range_no_hb_alarm() {
  if (GetArenaNoVirtual() == NULL && range_no_hb_alarm_ != NULL) delete range_no_hb_alarm_;
  range_no_hb_alarm_ = NULL;
}
inline const ::alarmpb::RangeNoHeartbeatAlarm& NodeRangeAlarmRequest::range_no_hb_alarm() const {
  const ::alarmpb::RangeNoHeartbeatAlarm* p = range_no_hb_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.range_no_hb_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::RangeNoHeartbeatAlarm*>(
      &::alarmpb::_RangeNoHeartbeatAlarm_default_instance_);
}
inline ::alarmpb::RangeNoHeartbeatAlarm* NodeRangeAlarmRequest::mutable_range_no_hb_alarm() {
  
  if (range_no_hb_alarm_ == NULL) {
    range_no_hb_alarm_ = new ::alarmpb::RangeNoHeartbeatAlarm;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.range_no_hb_alarm)
  return range_no_hb_alarm_;
}
inline ::alarmpb::RangeNoHeartbeatAlarm* NodeRangeAlarmRequest::release_range_no_hb_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmRequest.range_no_hb_alarm)
  
  ::alarmpb::RangeNoHeartbeatAlarm* temp = range_no_hb_alarm_;
  range_no_hb_alarm_ = NULL;
  return temp;
}
inline void NodeRangeAlarmRequest::set_allocated_range_no_hb_alarm(::alarmpb::RangeNoHeartbeatAlarm* range_no_hb_alarm) {
  delete range_no_hb_alarm_;
  range_no_hb_alarm_ = range_no_hb_alarm;
  if (range_no_hb_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmRequest.range_no_hb_alarm)
}

// .alarmpb.NodeNoHeartbeatAlarm node_no_hb_alarm = 4;
inline bool NodeRangeAlarmRequest::has_node_no_hb_alarm() const {
  return this != internal_default_instance() && node_no_hb_alarm_ != NULL;
}
inline void NodeRangeAlarmRequest::clear_node_no_hb_alarm() {
  if (GetArenaNoVirtual() == NULL && node_no_hb_alarm_ != NULL) delete node_no_hb_alarm_;
  node_no_hb_alarm_ = NULL;
}
inline const ::alarmpb::NodeNoHeartbeatAlarm& NodeRangeAlarmRequest::node_no_hb_alarm() const {
  const ::alarmpb::NodeNoHeartbeatAlarm* p = node_no_hb_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.node_no_hb_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::NodeNoHeartbeatAlarm*>(
      &::alarmpb::_NodeNoHeartbeatAlarm_default_instance_);
}
inline ::alarmpb::NodeNoHeartbeatAlarm* NodeRangeAlarmRequest::mutable_node_no_hb_alarm() {
  
  if (node_no_hb_alarm_ == NULL) {
    node_no_hb_alarm_ = new ::alarmpb::NodeNoHeartbeatAlarm;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.node_no_hb_alarm)
  return node_no_hb_alarm_;
}
inline ::alarmpb::NodeNoHeartbeatAlarm* NodeRangeAlarmRequest::release_node_no_hb_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmRequest.node_no_hb_alarm)
  
  ::alarmpb::NodeNoHeartbeatAlarm* temp = node_no_hb_alarm_;
  node_no_hb_alarm_ = NULL;
  return temp;
}
inline void NodeRangeAlarmRequest::set_allocated_node_no_hb_alarm(::alarmpb::NodeNoHeartbeatAlarm* node_no_hb_alarm) {
  delete node_no_hb_alarm_;
  node_no_hb_alarm_ = node_no_hb_alarm;
  if (node_no_hb_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmRequest.node_no_hb_alarm)
}

// .alarmpb.NodeDiskSizeAlarm node_disk_size_alarm = 5;
inline bool NodeRangeAlarmRequest::has_node_disk_size_alarm() const {
  return this != internal_default_instance() && node_disk_size_alarm_ != NULL;
}
inline void NodeRangeAlarmRequest::clear_node_disk_size_alarm() {
  if (GetArenaNoVirtual() == NULL && node_disk_size_alarm_ != NULL) delete node_disk_size_alarm_;
  node_disk_size_alarm_ = NULL;
}
inline const ::alarmpb::NodeDiskSizeAlarm& NodeRangeAlarmRequest::node_disk_size_alarm() const {
  const ::alarmpb::NodeDiskSizeAlarm* p = node_disk_size_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.node_disk_size_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::NodeDiskSizeAlarm*>(
      &::alarmpb::_NodeDiskSizeAlarm_default_instance_);
}
inline ::alarmpb::NodeDiskSizeAlarm* NodeRangeAlarmRequest::mutable_node_disk_size_alarm() {
  
  if (node_disk_size_alarm_ == NULL) {
    node_disk_size_alarm_ = new ::alarmpb::NodeDiskSizeAlarm;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.node_disk_size_alarm)
  return node_disk_size_alarm_;
}
inline ::alarmpb::NodeDiskSizeAlarm* NodeRangeAlarmRequest::release_node_disk_size_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmRequest.node_disk_size_alarm)
  
  ::alarmpb::NodeDiskSizeAlarm* temp = node_disk_size_alarm_;
  node_disk_size_alarm_ = NULL;
  return temp;
}
inline void NodeRangeAlarmRequest::set_allocated_node_disk_size_alarm(::alarmpb::NodeDiskSizeAlarm* node_disk_size_alarm) {
  delete node_disk_size_alarm_;
  node_disk_size_alarm_ = node_disk_size_alarm;
  if (node_disk_size_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmRequest.node_disk_size_alarm)
}

// .alarmpb.NodeLeaderCountAlarm node_leader_count_alarm = 6;
inline bool NodeRangeAlarmRequest::has_node_leader_count_alarm() const {
  return this != internal_default_instance() && node_leader_count_alarm_ != NULL;
}
inline void NodeRangeAlarmRequest::clear_node_leader_count_alarm() {
  if (GetArenaNoVirtual() == NULL && node_leader_count_alarm_ != NULL) delete node_leader_count_alarm_;
  node_leader_count_alarm_ = NULL;
}
inline const ::alarmpb::NodeLeaderCountAlarm& NodeRangeAlarmRequest::node_leader_count_alarm() const {
  const ::alarmpb::NodeLeaderCountAlarm* p = node_leader_count_alarm_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.node_leader_count_alarm)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::NodeLeaderCountAlarm*>(
      &::alarmpb::_NodeLeaderCountAlarm_default_instance_);
}
inline ::alarmpb::NodeLeaderCountAlarm* NodeRangeAlarmRequest::mutable_node_leader_count_alarm() {
  
  if (node_leader_count_alarm_ == NULL) {
    node_leader_count_alarm_ = new ::alarmpb::NodeLeaderCountAlarm;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.node_leader_count_alarm)
  return node_leader_count_alarm_;
}
inline ::alarmpb::NodeLeaderCountAlarm* NodeRangeAlarmRequest::release_node_leader_count_alarm() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmRequest.node_leader_count_alarm)
  
  ::alarmpb::NodeLeaderCountAlarm* temp = node_leader_count_alarm_;
  node_leader_count_alarm_ = NULL;
  return temp;
}
inline void NodeRangeAlarmRequest::set_allocated_node_leader_count_alarm(::alarmpb::NodeLeaderCountAlarm* node_leader_count_alarm) {
  delete node_leader_count_alarm_;
  node_leader_count_alarm_ = node_leader_count_alarm;
  if (node_leader_count_alarm) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmRequest.node_leader_count_alarm)
}

// string Describe = 7;
inline void NodeRangeAlarmRequest::clear_describe() {
  describe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeRangeAlarmRequest::describe() const {
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.Describe)
  return describe_.GetNoArena();
}
inline void NodeRangeAlarmRequest::set_describe(const ::std::string& value) {
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.NodeRangeAlarmRequest.Describe)
}
#if LANG_CXX11
inline void NodeRangeAlarmRequest::set_describe(::std::string&& value) {
  
  describe_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.NodeRangeAlarmRequest.Describe)
}
#endif
inline void NodeRangeAlarmRequest::set_describe(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.NodeRangeAlarmRequest.Describe)
}
inline void NodeRangeAlarmRequest::set_describe(const char* value, size_t size) {
  
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.NodeRangeAlarmRequest.Describe)
}
inline ::std::string* NodeRangeAlarmRequest::mutable_describe() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.Describe)
  return describe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeRangeAlarmRequest::release_describe() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmRequest.Describe)
  
  return describe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRangeAlarmRequest::set_allocated_describe(::std::string* describe) {
  if (describe != NULL) {
    
  } else {
    
  }
  describe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), describe);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmRequest.Describe)
}

// repeated string sample_json = 10;
inline int NodeRangeAlarmRequest::sample_json_size() const {
  return sample_json_.size();
}
inline void NodeRangeAlarmRequest::clear_sample_json() {
  sample_json_.Clear();
}
inline const ::std::string& NodeRangeAlarmRequest::sample_json(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmRequest.sample_json)
  return sample_json_.Get(index);
}
inline ::std::string* NodeRangeAlarmRequest::mutable_sample_json(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmRequest.sample_json)
  return sample_json_.Mutable(index);
}
inline void NodeRangeAlarmRequest::set_sample_json(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb.NodeRangeAlarmRequest.sample_json)
  sample_json_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NodeRangeAlarmRequest::set_sample_json(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb.NodeRangeAlarmRequest.sample_json)
  sample_json_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NodeRangeAlarmRequest::set_sample_json(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb.NodeRangeAlarmRequest.sample_json)
}
inline void NodeRangeAlarmRequest::set_sample_json(int index, const char* value, size_t size) {
  sample_json_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb.NodeRangeAlarmRequest.sample_json)
}
inline ::std::string* NodeRangeAlarmRequest::add_sample_json() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb.NodeRangeAlarmRequest.sample_json)
  return sample_json_.Add();
}
inline void NodeRangeAlarmRequest::add_sample_json(const ::std::string& value) {
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb.NodeRangeAlarmRequest.sample_json)
}
#if LANG_CXX11
inline void NodeRangeAlarmRequest::add_sample_json(::std::string&& value) {
  sample_json_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb.NodeRangeAlarmRequest.sample_json)
}
#endif
inline void NodeRangeAlarmRequest::add_sample_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb.NodeRangeAlarmRequest.sample_json)
}
inline void NodeRangeAlarmRequest::add_sample_json(const char* value, size_t size) {
  sample_json_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb.NodeRangeAlarmRequest.sample_json)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NodeRangeAlarmRequest::sample_json() const {
  // @@protoc_insertion_point(field_list:alarmpb.NodeRangeAlarmRequest.sample_json)
  return sample_json_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NodeRangeAlarmRequest::mutable_sample_json() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb.NodeRangeAlarmRequest.sample_json)
  return &sample_json_;
}

// -------------------------------------------------------------------

// RangeNoHeartbeatAlarm

// .metapb.Range range = 1;
inline bool RangeNoHeartbeatAlarm::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void RangeNoHeartbeatAlarm::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::metapb::Range& RangeNoHeartbeatAlarm::range() const {
  const ::metapb::Range* p = range_;
  // @@protoc_insertion_point(field_get:alarmpb.RangeNoHeartbeatAlarm.range)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Range*>(
      &::metapb::_Range_default_instance_);
}
inline ::metapb::Range* RangeNoHeartbeatAlarm::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::metapb::Range;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.RangeNoHeartbeatAlarm.range)
  return range_;
}
inline ::metapb::Range* RangeNoHeartbeatAlarm::release_range() {
  // @@protoc_insertion_point(field_release:alarmpb.RangeNoHeartbeatAlarm.range)
  
  ::metapb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void RangeNoHeartbeatAlarm::set_allocated_range(::metapb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.RangeNoHeartbeatAlarm.range)
}

// string last_heartbeat_time = 2;
inline void RangeNoHeartbeatAlarm::clear_last_heartbeat_time() {
  last_heartbeat_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeNoHeartbeatAlarm::last_heartbeat_time() const {
  // @@protoc_insertion_point(field_get:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
  return last_heartbeat_time_.GetNoArena();
}
inline void RangeNoHeartbeatAlarm::set_last_heartbeat_time(const ::std::string& value) {
  
  last_heartbeat_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
}
#if LANG_CXX11
inline void RangeNoHeartbeatAlarm::set_last_heartbeat_time(::std::string&& value) {
  
  last_heartbeat_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
}
#endif
inline void RangeNoHeartbeatAlarm::set_last_heartbeat_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_heartbeat_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
}
inline void RangeNoHeartbeatAlarm::set_last_heartbeat_time(const char* value, size_t size) {
  
  last_heartbeat_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
}
inline ::std::string* RangeNoHeartbeatAlarm::mutable_last_heartbeat_time() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
  return last_heartbeat_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeNoHeartbeatAlarm::release_last_heartbeat_time() {
  // @@protoc_insertion_point(field_release:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
  
  return last_heartbeat_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeNoHeartbeatAlarm::set_allocated_last_heartbeat_time(::std::string* last_heartbeat_time) {
  if (last_heartbeat_time != NULL) {
    
  } else {
    
  }
  last_heartbeat_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_heartbeat_time);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.RangeNoHeartbeatAlarm.last_heartbeat_time)
}

// -------------------------------------------------------------------

// NodeNoHeartbeatAlarm

// .metapb.Node node = 1;
inline bool NodeNoHeartbeatAlarm::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void NodeNoHeartbeatAlarm::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::metapb::Node& NodeNoHeartbeatAlarm::node() const {
  const ::metapb::Node* p = node_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeNoHeartbeatAlarm.node)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Node*>(
      &::metapb::_Node_default_instance_);
}
inline ::metapb::Node* NodeNoHeartbeatAlarm::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::metapb::Node;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeNoHeartbeatAlarm.node)
  return node_;
}
inline ::metapb::Node* NodeNoHeartbeatAlarm::release_node() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeNoHeartbeatAlarm.node)
  
  ::metapb::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void NodeNoHeartbeatAlarm::set_allocated_node(::metapb::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeNoHeartbeatAlarm.node)
}

// string last_heartbeat_time = 2;
inline void NodeNoHeartbeatAlarm::clear_last_heartbeat_time() {
  last_heartbeat_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeNoHeartbeatAlarm::last_heartbeat_time() const {
  // @@protoc_insertion_point(field_get:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
  return last_heartbeat_time_.GetNoArena();
}
inline void NodeNoHeartbeatAlarm::set_last_heartbeat_time(const ::std::string& value) {
  
  last_heartbeat_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
}
#if LANG_CXX11
inline void NodeNoHeartbeatAlarm::set_last_heartbeat_time(::std::string&& value) {
  
  last_heartbeat_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
}
#endif
inline void NodeNoHeartbeatAlarm::set_last_heartbeat_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_heartbeat_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
}
inline void NodeNoHeartbeatAlarm::set_last_heartbeat_time(const char* value, size_t size) {
  
  last_heartbeat_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
}
inline ::std::string* NodeNoHeartbeatAlarm::mutable_last_heartbeat_time() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
  return last_heartbeat_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeNoHeartbeatAlarm::release_last_heartbeat_time() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
  
  return last_heartbeat_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeNoHeartbeatAlarm::set_allocated_last_heartbeat_time(::std::string* last_heartbeat_time) {
  if (last_heartbeat_time != NULL) {
    
  } else {
    
  }
  last_heartbeat_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_heartbeat_time);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeNoHeartbeatAlarm.last_heartbeat_time)
}

// -------------------------------------------------------------------

// NodeDiskSizeAlarm

// .metapb.Node node = 1;
inline bool NodeDiskSizeAlarm::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void NodeDiskSizeAlarm::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::metapb::Node& NodeDiskSizeAlarm::node() const {
  const ::metapb::Node* p = node_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeDiskSizeAlarm.node)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Node*>(
      &::metapb::_Node_default_instance_);
}
inline ::metapb::Node* NodeDiskSizeAlarm::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::metapb::Node;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeDiskSizeAlarm.node)
  return node_;
}
inline ::metapb::Node* NodeDiskSizeAlarm::release_node() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeDiskSizeAlarm.node)
  
  ::metapb::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void NodeDiskSizeAlarm::set_allocated_node(::metapb::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeDiskSizeAlarm.node)
}

// int64 disk_size = 2;
inline void NodeDiskSizeAlarm::clear_disk_size() {
  disk_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NodeDiskSizeAlarm::disk_size() const {
  // @@protoc_insertion_point(field_get:alarmpb.NodeDiskSizeAlarm.disk_size)
  return disk_size_;
}
inline void NodeDiskSizeAlarm::set_disk_size(::google::protobuf::int64 value) {
  
  disk_size_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.NodeDiskSizeAlarm.disk_size)
}

// -------------------------------------------------------------------

// NodeLeaderCountAlarm

// .metapb.Node node = 1;
inline bool NodeLeaderCountAlarm::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void NodeLeaderCountAlarm::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::metapb::Node& NodeLeaderCountAlarm::node() const {
  const ::metapb::Node* p = node_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeLeaderCountAlarm.node)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Node*>(
      &::metapb::_Node_default_instance_);
}
inline ::metapb::Node* NodeLeaderCountAlarm::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::metapb::Node;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeLeaderCountAlarm.node)
  return node_;
}
inline ::metapb::Node* NodeLeaderCountAlarm::release_node() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeLeaderCountAlarm.node)
  
  ::metapb::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void NodeLeaderCountAlarm::set_allocated_node(::metapb::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeLeaderCountAlarm.node)
}

// int64 leader_count = 2;
inline void NodeLeaderCountAlarm::clear_leader_count() {
  leader_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NodeLeaderCountAlarm::leader_count() const {
  // @@protoc_insertion_point(field_get:alarmpb.NodeLeaderCountAlarm.leader_count)
  return leader_count_;
}
inline void NodeLeaderCountAlarm::set_leader_count(::google::protobuf::int64 value) {
  
  leader_count_ = value;
  // @@protoc_insertion_point(field_set:alarmpb.NodeLeaderCountAlarm.leader_count)
}

// -------------------------------------------------------------------

// NodeRangeAlarmResponse

// .alarmpb.ResponseHeader head = 1;
inline bool NodeRangeAlarmResponse::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void NodeRangeAlarmResponse::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::ResponseHeader& NodeRangeAlarmResponse::head() const {
  const ::alarmpb::ResponseHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.NodeRangeAlarmResponse.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::ResponseHeader*>(
      &::alarmpb::_ResponseHeader_default_instance_);
}
inline ::alarmpb::ResponseHeader* NodeRangeAlarmResponse::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.NodeRangeAlarmResponse.head)
  return head_;
}
inline ::alarmpb::ResponseHeader* NodeRangeAlarmResponse::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.NodeRangeAlarmResponse.head)
  
  ::alarmpb::ResponseHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void NodeRangeAlarmResponse::set_allocated_head(::alarmpb::ResponseHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.NodeRangeAlarmResponse.head)
}

// -------------------------------------------------------------------

// AliveRequest

// .alarmpb.RequestHeader head = 1;
inline bool AliveRequest::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void AliveRequest::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::RequestHeader& AliveRequest::head() const {
  const ::alarmpb::RequestHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.AliveRequest.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::RequestHeader*>(
      &::alarmpb::_RequestHeader_default_instance_);
}
inline ::alarmpb::RequestHeader* AliveRequest::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.AliveRequest.head)
  return head_;
}
inline ::alarmpb::RequestHeader* AliveRequest::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.AliveRequest.head)
  
  ::alarmpb::RequestHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void AliveRequest::set_allocated_head(::alarmpb::RequestHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.AliveRequest.head)
}

// repeated string sample_json = 10;
inline int AliveRequest::sample_json_size() const {
  return sample_json_.size();
}
inline void AliveRequest::clear_sample_json() {
  sample_json_.Clear();
}
inline const ::std::string& AliveRequest::sample_json(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb.AliveRequest.sample_json)
  return sample_json_.Get(index);
}
inline ::std::string* AliveRequest::mutable_sample_json(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb.AliveRequest.sample_json)
  return sample_json_.Mutable(index);
}
inline void AliveRequest::set_sample_json(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb.AliveRequest.sample_json)
  sample_json_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AliveRequest::set_sample_json(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb.AliveRequest.sample_json)
  sample_json_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AliveRequest::set_sample_json(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb.AliveRequest.sample_json)
}
inline void AliveRequest::set_sample_json(int index, const char* value, size_t size) {
  sample_json_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb.AliveRequest.sample_json)
}
inline ::std::string* AliveRequest::add_sample_json() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb.AliveRequest.sample_json)
  return sample_json_.Add();
}
inline void AliveRequest::add_sample_json(const ::std::string& value) {
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb.AliveRequest.sample_json)
}
#if LANG_CXX11
inline void AliveRequest::add_sample_json(::std::string&& value) {
  sample_json_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb.AliveRequest.sample_json)
}
#endif
inline void AliveRequest::add_sample_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb.AliveRequest.sample_json)
}
inline void AliveRequest::add_sample_json(const char* value, size_t size) {
  sample_json_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb.AliveRequest.sample_json)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AliveRequest::sample_json() const {
  // @@protoc_insertion_point(field_list:alarmpb.AliveRequest.sample_json)
  return sample_json_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AliveRequest::mutable_sample_json() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb.AliveRequest.sample_json)
  return &sample_json_;
}

// -------------------------------------------------------------------

// AliveResponse

// .alarmpb.ResponseHeader head = 1;
inline bool AliveResponse::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void AliveResponse::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::ResponseHeader& AliveResponse::head() const {
  const ::alarmpb::ResponseHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.AliveResponse.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::ResponseHeader*>(
      &::alarmpb::_ResponseHeader_default_instance_);
}
inline ::alarmpb::ResponseHeader* AliveResponse::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.AliveResponse.head)
  return head_;
}
inline ::alarmpb::ResponseHeader* AliveResponse::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.AliveResponse.head)
  
  ::alarmpb::ResponseHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void AliveResponse::set_allocated_head(::alarmpb::ResponseHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.AliveResponse.head)
}

// -------------------------------------------------------------------

// SimpleRequest

// .alarmpb.RequestHeader head = 1;
inline bool SimpleRequest::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void SimpleRequest::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::RequestHeader& SimpleRequest::head() const {
  const ::alarmpb::RequestHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.SimpleRequest.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::RequestHeader*>(
      &::alarmpb::_RequestHeader_default_instance_);
}
inline ::alarmpb::RequestHeader* SimpleRequest::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleRequest.head)
  return head_;
}
inline ::alarmpb::RequestHeader* SimpleRequest::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleRequest.head)
  
  ::alarmpb::RequestHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void SimpleRequest::set_allocated_head(::alarmpb::RequestHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleRequest.head)
}

// string title = 2;
inline void SimpleRequest::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleRequest::title() const {
  // @@protoc_insertion_point(field_get:alarmpb.SimpleRequest.title)
  return title_.GetNoArena();
}
inline void SimpleRequest::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.SimpleRequest.title)
}
#if LANG_CXX11
inline void SimpleRequest::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.SimpleRequest.title)
}
#endif
inline void SimpleRequest::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.SimpleRequest.title)
}
inline void SimpleRequest::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.SimpleRequest.title)
}
inline ::std::string* SimpleRequest::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleRequest.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleRequest::release_title() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleRequest.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleRequest::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleRequest.title)
}

// string content = 3;
inline void SimpleRequest::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleRequest::content() const {
  // @@protoc_insertion_point(field_get:alarmpb.SimpleRequest.content)
  return content_.GetNoArena();
}
inline void SimpleRequest::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:alarmpb.SimpleRequest.content)
}
#if LANG_CXX11
inline void SimpleRequest::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:alarmpb.SimpleRequest.content)
}
#endif
inline void SimpleRequest::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:alarmpb.SimpleRequest.content)
}
inline void SimpleRequest::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:alarmpb.SimpleRequest.content)
}
inline ::std::string* SimpleRequest::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleRequest.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleRequest::release_content() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleRequest.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleRequest::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleRequest.content)
}

// repeated string sample_json = 10;
inline int SimpleRequest::sample_json_size() const {
  return sample_json_.size();
}
inline void SimpleRequest::clear_sample_json() {
  sample_json_.Clear();
}
inline const ::std::string& SimpleRequest::sample_json(int index) const {
  // @@protoc_insertion_point(field_get:alarmpb.SimpleRequest.sample_json)
  return sample_json_.Get(index);
}
inline ::std::string* SimpleRequest::mutable_sample_json(int index) {
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleRequest.sample_json)
  return sample_json_.Mutable(index);
}
inline void SimpleRequest::set_sample_json(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:alarmpb.SimpleRequest.sample_json)
  sample_json_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SimpleRequest::set_sample_json(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:alarmpb.SimpleRequest.sample_json)
  sample_json_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SimpleRequest::set_sample_json(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alarmpb.SimpleRequest.sample_json)
}
inline void SimpleRequest::set_sample_json(int index, const char* value, size_t size) {
  sample_json_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alarmpb.SimpleRequest.sample_json)
}
inline ::std::string* SimpleRequest::add_sample_json() {
  // @@protoc_insertion_point(field_add_mutable:alarmpb.SimpleRequest.sample_json)
  return sample_json_.Add();
}
inline void SimpleRequest::add_sample_json(const ::std::string& value) {
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alarmpb.SimpleRequest.sample_json)
}
#if LANG_CXX11
inline void SimpleRequest::add_sample_json(::std::string&& value) {
  sample_json_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alarmpb.SimpleRequest.sample_json)
}
#endif
inline void SimpleRequest::add_sample_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sample_json_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alarmpb.SimpleRequest.sample_json)
}
inline void SimpleRequest::add_sample_json(const char* value, size_t size) {
  sample_json_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alarmpb.SimpleRequest.sample_json)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SimpleRequest::sample_json() const {
  // @@protoc_insertion_point(field_list:alarmpb.SimpleRequest.sample_json)
  return sample_json_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SimpleRequest::mutable_sample_json() {
  // @@protoc_insertion_point(field_mutable_list:alarmpb.SimpleRequest.sample_json)
  return &sample_json_;
}

// -------------------------------------------------------------------

// SimpleResponse

// .alarmpb.ResponseHeader head = 1;
inline bool SimpleResponse::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void SimpleResponse::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) delete head_;
  head_ = NULL;
}
inline const ::alarmpb::ResponseHeader& SimpleResponse::head() const {
  const ::alarmpb::ResponseHeader* p = head_;
  // @@protoc_insertion_point(field_get:alarmpb.SimpleResponse.head)
  return p != NULL ? *p : *reinterpret_cast<const ::alarmpb::ResponseHeader*>(
      &::alarmpb::_ResponseHeader_default_instance_);
}
inline ::alarmpb::ResponseHeader* SimpleResponse::mutable_head() {
  
  if (head_ == NULL) {
    head_ = new ::alarmpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:alarmpb.SimpleResponse.head)
  return head_;
}
inline ::alarmpb::ResponseHeader* SimpleResponse::release_head() {
  // @@protoc_insertion_point(field_release:alarmpb.SimpleResponse.head)
  
  ::alarmpb::ResponseHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void SimpleResponse::set_allocated_head(::alarmpb::ResponseHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:alarmpb.SimpleResponse.head)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace alarmpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::alarmpb::TaskAlarmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::alarmpb::TaskAlarmType>() {
  return ::alarmpb::TaskAlarmType_descriptor();
}
template <> struct is_proto_enum< ::alarmpb::NodeRangeAlarmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::alarmpb::NodeRangeAlarmType>() {
  return ::alarmpb::NodeRangeAlarmType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_alarmpb_2eproto__INCLUDED
