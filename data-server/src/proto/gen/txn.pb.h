// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: txn.proto

#ifndef PROTOBUF_txn_2eproto__INCLUDED
#define PROTOBUF_txn_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "kvrpcpb.pb.h"
#include "metapb.pb.h"
// @@protoc_insertion_point(includes)
namespace txn {
class DecideRequest;
class DecideRequestDefaultTypeInternal;
extern DecideRequestDefaultTypeInternal _DecideRequest_default_instance_;
class DecideResponse;
class DecideResponseDefaultTypeInternal;
extern DecideResponseDefaultTypeInternal _DecideResponse_default_instance_;
class DsDecideRequest;
class DsDecideRequestDefaultTypeInternal;
extern DsDecideRequestDefaultTypeInternal _DsDecideRequest_default_instance_;
class DsDecideResponse;
class DsDecideResponseDefaultTypeInternal;
extern DsDecideResponseDefaultTypeInternal _DsDecideResponse_default_instance_;
class DsGetLockInfoRequest;
class DsGetLockInfoRequestDefaultTypeInternal;
extern DsGetLockInfoRequestDefaultTypeInternal _DsGetLockInfoRequest_default_instance_;
class DsGetLockInfoResponse;
class DsGetLockInfoResponseDefaultTypeInternal;
extern DsGetLockInfoResponseDefaultTypeInternal _DsGetLockInfoResponse_default_instance_;
class DsPrepareRequest;
class DsPrepareRequestDefaultTypeInternal;
extern DsPrepareRequestDefaultTypeInternal _DsPrepareRequest_default_instance_;
class DsPrepareResponse;
class DsPrepareResponseDefaultTypeInternal;
extern DsPrepareResponseDefaultTypeInternal _DsPrepareResponse_default_instance_;
class DsSelectRequest;
class DsSelectRequestDefaultTypeInternal;
extern DsSelectRequestDefaultTypeInternal _DsSelectRequest_default_instance_;
class DsSelectResponse;
class DsSelectResponseDefaultTypeInternal;
extern DsSelectResponseDefaultTypeInternal _DsSelectResponse_default_instance_;
class GetLockInfoRequest;
class GetLockInfoRequestDefaultTypeInternal;
extern GetLockInfoRequestDefaultTypeInternal _GetLockInfoRequest_default_instance_;
class GetLockInfoResponse;
class GetLockInfoResponseDefaultTypeInternal;
extern GetLockInfoResponseDefaultTypeInternal _GetLockInfoResponse_default_instance_;
class LockError;
class LockErrorDefaultTypeInternal;
extern LockErrorDefaultTypeInternal _LockError_default_instance_;
class LockInfo;
class LockInfoDefaultTypeInternal;
extern LockInfoDefaultTypeInternal _LockInfo_default_instance_;
class PrepareRequest;
class PrepareRequestDefaultTypeInternal;
extern PrepareRequestDefaultTypeInternal _PrepareRequest_default_instance_;
class PrepareResponse;
class PrepareResponseDefaultTypeInternal;
extern PrepareResponseDefaultTypeInternal _PrepareResponse_default_instance_;
class Row;
class RowDefaultTypeInternal;
extern RowDefaultTypeInternal _Row_default_instance_;
class RowIntent;
class RowIntentDefaultTypeInternal;
extern RowIntentDefaultTypeInternal _RowIntent_default_instance_;
class RowValue;
class RowValueDefaultTypeInternal;
extern RowValueDefaultTypeInternal _RowValue_default_instance_;
class SelectRequest;
class SelectRequestDefaultTypeInternal;
extern SelectRequestDefaultTypeInternal _SelectRequest_default_instance_;
class SelectResponse;
class SelectResponseDefaultTypeInternal;
extern SelectResponseDefaultTypeInternal _SelectResponse_default_instance_;
class StatusConflict;
class StatusConflictDefaultTypeInternal;
extern StatusConflictDefaultTypeInternal _StatusConflict_default_instance_;
class TxnError;
class TxnErrorDefaultTypeInternal;
extern TxnErrorDefaultTypeInternal _TxnError_default_instance_;
class TxnIntent;
class TxnIntentDefaultTypeInternal;
extern TxnIntentDefaultTypeInternal _TxnIntent_default_instance_;
class TxnValue;
class TxnValueDefaultTypeInternal;
extern TxnValueDefaultTypeInternal _TxnValue_default_instance_;
class UnexpectedVer;
class UnexpectedVerDefaultTypeInternal;
extern UnexpectedVerDefaultTypeInternal _UnexpectedVer_default_instance_;
}  // namespace txn

namespace txn {

namespace protobuf_txn_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_txn_2eproto

enum TxnError_ErrType {
  TxnError_ErrType_UNKNOWN = 0,
  TxnError_ErrType_LOCKED = 1,
  TxnError_ErrType_UNEXPECTED_VER = 2,
  TxnError_ErrType_STATUS_CONFLICT = 3,
  TxnError_ErrType_TxnError_ErrType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TxnError_ErrType_TxnError_ErrType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TxnError_ErrType_IsValid(int value);
const TxnError_ErrType TxnError_ErrType_ErrType_MIN = TxnError_ErrType_UNKNOWN;
const TxnError_ErrType TxnError_ErrType_ErrType_MAX = TxnError_ErrType_STATUS_CONFLICT;
const int TxnError_ErrType_ErrType_ARRAYSIZE = TxnError_ErrType_ErrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxnError_ErrType_descriptor();
inline const ::std::string& TxnError_ErrType_Name(TxnError_ErrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxnError_ErrType_descriptor(), value);
}
inline bool TxnError_ErrType_Parse(
    const ::std::string& name, TxnError_ErrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxnError_ErrType>(
    TxnError_ErrType_descriptor(), name, value);
}
enum OpType {
  INSERT = 0,
  DELETE = 1,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpType_IsValid(int value);
const OpType OpType_MIN = INSERT;
const OpType OpType_MAX = DELETE;
const int OpType_ARRAYSIZE = OpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OpType_descriptor();
inline const ::std::string& OpType_Name(OpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OpType_descriptor(), value);
}
inline bool OpType_Parse(
    const ::std::string& name, OpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpType>(
    OpType_descriptor(), name, value);
}
enum TxnStatus {
  INIT = 0,
  COMMITTED = 1,
  ABORTED = 2,
  TxnStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TxnStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TxnStatus_IsValid(int value);
const TxnStatus TxnStatus_MIN = INIT;
const TxnStatus TxnStatus_MAX = ABORTED;
const int TxnStatus_ARRAYSIZE = TxnStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxnStatus_descriptor();
inline const ::std::string& TxnStatus_Name(TxnStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxnStatus_descriptor(), value);
}
inline bool TxnStatus_Parse(
    const ::std::string& name, TxnStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxnStatus>(
    TxnStatus_descriptor(), name, value);
}
// ===================================================================

class TxnIntent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.TxnIntent) */ {
 public:
  TxnIntent();
  virtual ~TxnIntent();

  TxnIntent(const TxnIntent& from);

  inline TxnIntent& operator=(const TxnIntent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxnIntent(TxnIntent&& from) noexcept
    : TxnIntent() {
    *this = ::std::move(from);
  }

  inline TxnIntent& operator=(TxnIntent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxnIntent& default_instance();

  static inline const TxnIntent* internal_default_instance() {
    return reinterpret_cast<const TxnIntent*>(
               &_TxnIntent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TxnIntent* other);
  friend void swap(TxnIntent& a, TxnIntent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxnIntent* New() const PROTOBUF_FINAL { return New(NULL); }

  TxnIntent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxnIntent& from);
  void MergeFrom(const TxnIntent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxnIntent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .txn.OpType typ = 1;
  void clear_typ();
  static const int kTypFieldNumber = 1;
  ::txn::OpType typ() const;
  void set_typ(::txn::OpType value);

  // bool check_unique = 4;
  void clear_check_unique();
  static const int kCheckUniqueFieldNumber = 4;
  bool check_unique() const;
  void set_check_unique(bool value);

  // bool is_primary = 6;
  void clear_is_primary();
  static const int kIsPrimaryFieldNumber = 6;
  bool is_primary() const;
  void set_is_primary(bool value);

  // uint64 expected_ver = 5;
  void clear_expected_ver();
  static const int kExpectedVerFieldNumber = 5;
  ::google::protobuf::uint64 expected_ver() const;
  void set_expected_ver(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:txn.TxnIntent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int typ_;
  bool check_unique_;
  bool is_primary_;
  ::google::protobuf::uint64 expected_ver_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxnValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.TxnValue) */ {
 public:
  TxnValue();
  virtual ~TxnValue();

  TxnValue(const TxnValue& from);

  inline TxnValue& operator=(const TxnValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxnValue(TxnValue&& from) noexcept
    : TxnValue() {
    *this = ::std::move(from);
  }

  inline TxnValue& operator=(TxnValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxnValue& default_instance();

  static inline const TxnValue* internal_default_instance() {
    return reinterpret_cast<const TxnValue*>(
               &_TxnValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TxnValue* other);
  friend void swap(TxnValue& a, TxnValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxnValue* New() const PROTOBUF_FINAL { return New(NULL); }

  TxnValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxnValue& from);
  void MergeFrom(const TxnValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxnValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes secondary_keys = 11;
  int secondary_keys_size() const;
  void clear_secondary_keys();
  static const int kSecondaryKeysFieldNumber = 11;
  const ::std::string& secondary_keys(int index) const;
  ::std::string* mutable_secondary_keys(int index);
  void set_secondary_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_keys(int index, ::std::string&& value);
  #endif
  void set_secondary_keys(int index, const char* value);
  void set_secondary_keys(int index, const void* value, size_t size);
  ::std::string* add_secondary_keys();
  void add_secondary_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_secondary_keys(::std::string&& value);
  #endif
  void add_secondary_keys(const char* value);
  void add_secondary_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& secondary_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_secondary_keys();

  // string txn_id = 1;
  void clear_txn_id();
  static const int kTxnIdFieldNumber = 1;
  const ::std::string& txn_id() const;
  void set_txn_id(const ::std::string& value);
  #if LANG_CXX11
  void set_txn_id(::std::string&& value);
  #endif
  void set_txn_id(const char* value);
  void set_txn_id(const char* value, size_t size);
  ::std::string* mutable_txn_id();
  ::std::string* release_txn_id();
  void set_allocated_txn_id(::std::string* txn_id);

  // bytes primary_key = 3;
  void clear_primary_key();
  static const int kPrimaryKeyFieldNumber = 3;
  const ::std::string& primary_key() const;
  void set_primary_key(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_key(::std::string&& value);
  #endif
  void set_primary_key(const char* value);
  void set_primary_key(const void* value, size_t size);
  ::std::string* mutable_primary_key();
  ::std::string* release_primary_key();
  void set_allocated_primary_key(::std::string* primary_key);

  // .txn.TxnIntent intent = 2;
  bool has_intent() const;
  void clear_intent();
  static const int kIntentFieldNumber = 2;
  const ::txn::TxnIntent& intent() const;
  ::txn::TxnIntent* mutable_intent();
  ::txn::TxnIntent* release_intent();
  void set_allocated_intent(::txn::TxnIntent* intent);

  // uint64 expired_at = 4;
  void clear_expired_at();
  static const int kExpiredAtFieldNumber = 4;
  ::google::protobuf::uint64 expired_at() const;
  void set_expired_at(::google::protobuf::uint64 value);

  // .txn.TxnStatus txn_status = 10;
  void clear_txn_status();
  static const int kTxnStatusFieldNumber = 10;
  ::txn::TxnStatus txn_status() const;
  void set_txn_status(::txn::TxnStatus value);

  // @@protoc_insertion_point(class_scope:txn.TxnValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> secondary_keys_;
  ::google::protobuf::internal::ArenaStringPtr txn_id_;
  ::google::protobuf::internal::ArenaStringPtr primary_key_;
  ::txn::TxnIntent* intent_;
  ::google::protobuf::uint64 expired_at_;
  int txn_status_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.LockInfo) */ {
 public:
  LockInfo();
  virtual ~LockInfo();

  LockInfo(const LockInfo& from);

  inline LockInfo& operator=(const LockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockInfo(LockInfo&& from) noexcept
    : LockInfo() {
    *this = ::std::move(from);
  }

  inline LockInfo& operator=(LockInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInfo& default_instance();

  static inline const LockInfo* internal_default_instance() {
    return reinterpret_cast<const LockInfo*>(
               &_LockInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LockInfo* other);
  friend void swap(LockInfo& a, LockInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LockInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockInfo& from);
  void MergeFrom(const LockInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes secondary_keys = 13;
  int secondary_keys_size() const;
  void clear_secondary_keys();
  static const int kSecondaryKeysFieldNumber = 13;
  const ::std::string& secondary_keys(int index) const;
  ::std::string* mutable_secondary_keys(int index);
  void set_secondary_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_keys(int index, ::std::string&& value);
  #endif
  void set_secondary_keys(int index, const char* value);
  void set_secondary_keys(int index, const void* value, size_t size);
  ::std::string* add_secondary_keys();
  void add_secondary_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_secondary_keys(::std::string&& value);
  #endif
  void add_secondary_keys(const char* value);
  void add_secondary_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& secondary_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_secondary_keys();

  // string txn_id = 1;
  void clear_txn_id();
  static const int kTxnIdFieldNumber = 1;
  const ::std::string& txn_id() const;
  void set_txn_id(const ::std::string& value);
  #if LANG_CXX11
  void set_txn_id(::std::string&& value);
  #endif
  void set_txn_id(const char* value);
  void set_txn_id(const char* value, size_t size);
  ::std::string* mutable_txn_id();
  ::std::string* release_txn_id();
  void set_allocated_txn_id(::std::string* txn_id);

  // bytes primary_key = 11;
  void clear_primary_key();
  static const int kPrimaryKeyFieldNumber = 11;
  const ::std::string& primary_key() const;
  void set_primary_key(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_key(::std::string&& value);
  #endif
  void set_primary_key(const char* value);
  void set_primary_key(const void* value, size_t size);
  ::std::string* mutable_primary_key();
  ::std::string* release_primary_key();
  void set_allocated_primary_key(::std::string* primary_key);

  // bool timeout = 2;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  bool timeout() const;
  void set_timeout(bool value);

  // bool is_primary = 10;
  void clear_is_primary();
  static const int kIsPrimaryFieldNumber = 10;
  bool is_primary() const;
  void set_is_primary(bool value);

  // .txn.TxnStatus status = 12;
  void clear_status();
  static const int kStatusFieldNumber = 12;
  ::txn::TxnStatus status() const;
  void set_status(::txn::TxnStatus value);

  // @@protoc_insertion_point(class_scope:txn.LockInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> secondary_keys_;
  ::google::protobuf::internal::ArenaStringPtr txn_id_;
  ::google::protobuf::internal::ArenaStringPtr primary_key_;
  bool timeout_;
  bool is_primary_;
  int status_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.LockError) */ {
 public:
  LockError();
  virtual ~LockError();

  LockError(const LockError& from);

  inline LockError& operator=(const LockError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockError(LockError&& from) noexcept
    : LockError() {
    *this = ::std::move(from);
  }

  inline LockError& operator=(LockError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockError& default_instance();

  static inline const LockError* internal_default_instance() {
    return reinterpret_cast<const LockError*>(
               &_LockError_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LockError* other);
  friend void swap(LockError& a, LockError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockError* New() const PROTOBUF_FINAL { return New(NULL); }

  LockError* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockError& from);
  void MergeFrom(const LockError& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .txn.LockInfo info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::txn::LockInfo& info() const;
  ::txn::LockInfo* mutable_info();
  ::txn::LockInfo* release_info();
  void set_allocated_info(::txn::LockInfo* info);

  // @@protoc_insertion_point(class_scope:txn.LockError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::txn::LockInfo* info_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnexpectedVer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.UnexpectedVer) */ {
 public:
  UnexpectedVer();
  virtual ~UnexpectedVer();

  UnexpectedVer(const UnexpectedVer& from);

  inline UnexpectedVer& operator=(const UnexpectedVer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnexpectedVer(UnexpectedVer&& from) noexcept
    : UnexpectedVer() {
    *this = ::std::move(from);
  }

  inline UnexpectedVer& operator=(UnexpectedVer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnexpectedVer& default_instance();

  static inline const UnexpectedVer* internal_default_instance() {
    return reinterpret_cast<const UnexpectedVer*>(
               &_UnexpectedVer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(UnexpectedVer* other);
  friend void swap(UnexpectedVer& a, UnexpectedVer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnexpectedVer* New() const PROTOBUF_FINAL { return New(NULL); }

  UnexpectedVer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnexpectedVer& from);
  void MergeFrom(const UnexpectedVer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnexpectedVer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // uint64 expected_ver = 2;
  void clear_expected_ver();
  static const int kExpectedVerFieldNumber = 2;
  ::google::protobuf::uint64 expected_ver() const;
  void set_expected_ver(::google::protobuf::uint64 value);

  // uint64 actual_ver = 3;
  void clear_actual_ver();
  static const int kActualVerFieldNumber = 3;
  ::google::protobuf::uint64 actual_ver() const;
  void set_actual_ver(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:txn.UnexpectedVer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint64 expected_ver_;
  ::google::protobuf::uint64 actual_ver_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusConflict : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.StatusConflict) */ {
 public:
  StatusConflict();
  virtual ~StatusConflict();

  StatusConflict(const StatusConflict& from);

  inline StatusConflict& operator=(const StatusConflict& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusConflict(StatusConflict&& from) noexcept
    : StatusConflict() {
    *this = ::std::move(from);
  }

  inline StatusConflict& operator=(StatusConflict&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusConflict& default_instance();

  static inline const StatusConflict* internal_default_instance() {
    return reinterpret_cast<const StatusConflict*>(
               &_StatusConflict_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(StatusConflict* other);
  friend void swap(StatusConflict& a, StatusConflict& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusConflict* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusConflict* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusConflict& from);
  void MergeFrom(const StatusConflict& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusConflict* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .txn.TxnStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::txn::TxnStatus status() const;
  void set_status(::txn::TxnStatus value);

  // @@protoc_insertion_point(class_scope:txn.StatusConflict)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int status_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxnError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.TxnError) */ {
 public:
  TxnError();
  virtual ~TxnError();

  TxnError(const TxnError& from);

  inline TxnError& operator=(const TxnError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxnError(TxnError&& from) noexcept
    : TxnError() {
    *this = ::std::move(from);
  }

  inline TxnError& operator=(TxnError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxnError& default_instance();

  static inline const TxnError* internal_default_instance() {
    return reinterpret_cast<const TxnError*>(
               &_TxnError_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TxnError* other);
  friend void swap(TxnError& a, TxnError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxnError* New() const PROTOBUF_FINAL { return New(NULL); }

  TxnError* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxnError& from);
  void MergeFrom(const TxnError& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxnError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TxnError_ErrType ErrType;
  static const ErrType UNKNOWN =
    TxnError_ErrType_UNKNOWN;
  static const ErrType LOCKED =
    TxnError_ErrType_LOCKED;
  static const ErrType UNEXPECTED_VER =
    TxnError_ErrType_UNEXPECTED_VER;
  static const ErrType STATUS_CONFLICT =
    TxnError_ErrType_STATUS_CONFLICT;
  static inline bool ErrType_IsValid(int value) {
    return TxnError_ErrType_IsValid(value);
  }
  static const ErrType ErrType_MIN =
    TxnError_ErrType_ErrType_MIN;
  static const ErrType ErrType_MAX =
    TxnError_ErrType_ErrType_MAX;
  static const int ErrType_ARRAYSIZE =
    TxnError_ErrType_ErrType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrType_descriptor() {
    return TxnError_ErrType_descriptor();
  }
  static inline const ::std::string& ErrType_Name(ErrType value) {
    return TxnError_ErrType_Name(value);
  }
  static inline bool ErrType_Parse(const ::std::string& name,
      ErrType* value) {
    return TxnError_ErrType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .txn.LockError lock_err = 2;
  bool has_lock_err() const;
  void clear_lock_err();
  static const int kLockErrFieldNumber = 2;
  const ::txn::LockError& lock_err() const;
  ::txn::LockError* mutable_lock_err();
  ::txn::LockError* release_lock_err();
  void set_allocated_lock_err(::txn::LockError* lock_err);

  // .txn.UnexpectedVer unexpected_ver = 3;
  bool has_unexpected_ver() const;
  void clear_unexpected_ver();
  static const int kUnexpectedVerFieldNumber = 3;
  const ::txn::UnexpectedVer& unexpected_ver() const;
  ::txn::UnexpectedVer* mutable_unexpected_ver();
  ::txn::UnexpectedVer* release_unexpected_ver();
  void set_allocated_unexpected_ver(::txn::UnexpectedVer* unexpected_ver);

  // .txn.StatusConflict status_conflict = 4;
  bool has_status_conflict() const;
  void clear_status_conflict();
  static const int kStatusConflictFieldNumber = 4;
  const ::txn::StatusConflict& status_conflict() const;
  ::txn::StatusConflict* mutable_status_conflict();
  ::txn::StatusConflict* release_status_conflict();
  void set_allocated_status_conflict(::txn::StatusConflict* status_conflict);

  // .txn.TxnError.ErrType err_type = 1;
  void clear_err_type();
  static const int kErrTypeFieldNumber = 1;
  ::txn::TxnError_ErrType err_type() const;
  void set_err_type(::txn::TxnError_ErrType value);

  // @@protoc_insertion_point(class_scope:txn.TxnError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::txn::LockError* lock_err_;
  ::txn::UnexpectedVer* unexpected_ver_;
  ::txn::StatusConflict* status_conflict_;
  int err_type_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrepareRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.PrepareRequest) */ {
 public:
  PrepareRequest();
  virtual ~PrepareRequest();

  PrepareRequest(const PrepareRequest& from);

  inline PrepareRequest& operator=(const PrepareRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrepareRequest(PrepareRequest&& from) noexcept
    : PrepareRequest() {
    *this = ::std::move(from);
  }

  inline PrepareRequest& operator=(PrepareRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareRequest& default_instance();

  static inline const PrepareRequest* internal_default_instance() {
    return reinterpret_cast<const PrepareRequest*>(
               &_PrepareRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(PrepareRequest* other);
  friend void swap(PrepareRequest& a, PrepareRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrepareRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PrepareRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PrepareRequest& from);
  void MergeFrom(const PrepareRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PrepareRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .txn.TxnIntent intents = 3;
  int intents_size() const;
  void clear_intents();
  static const int kIntentsFieldNumber = 3;
  const ::txn::TxnIntent& intents(int index) const;
  ::txn::TxnIntent* mutable_intents(int index);
  ::txn::TxnIntent* add_intents();
  ::google::protobuf::RepeatedPtrField< ::txn::TxnIntent >*
      mutable_intents();
  const ::google::protobuf::RepeatedPtrField< ::txn::TxnIntent >&
      intents() const;

  // repeated bytes secondary_keys = 6;
  int secondary_keys_size() const;
  void clear_secondary_keys();
  static const int kSecondaryKeysFieldNumber = 6;
  const ::std::string& secondary_keys(int index) const;
  ::std::string* mutable_secondary_keys(int index);
  void set_secondary_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_keys(int index, ::std::string&& value);
  #endif
  void set_secondary_keys(int index, const char* value);
  void set_secondary_keys(int index, const void* value, size_t size);
  ::std::string* add_secondary_keys();
  void add_secondary_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_secondary_keys(::std::string&& value);
  #endif
  void add_secondary_keys(const char* value);
  void add_secondary_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& secondary_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_secondary_keys();

  // string txn_id = 1;
  void clear_txn_id();
  static const int kTxnIdFieldNumber = 1;
  const ::std::string& txn_id() const;
  void set_txn_id(const ::std::string& value);
  #if LANG_CXX11
  void set_txn_id(::std::string&& value);
  #endif
  void set_txn_id(const char* value);
  void set_txn_id(const char* value, size_t size);
  ::std::string* mutable_txn_id();
  ::std::string* release_txn_id();
  void set_allocated_txn_id(::std::string* txn_id);

  // bytes primary_key = 4;
  void clear_primary_key();
  static const int kPrimaryKeyFieldNumber = 4;
  const ::std::string& primary_key() const;
  void set_primary_key(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_key(::std::string&& value);
  #endif
  void set_primary_key(const char* value);
  void set_primary_key(const void* value, size_t size);
  ::std::string* mutable_primary_key();
  ::std::string* release_primary_key();
  void set_allocated_primary_key(::std::string* primary_key);

  // uint64 lock_ttl = 5;
  void clear_lock_ttl();
  static const int kLockTtlFieldNumber = 5;
  ::google::protobuf::uint64 lock_ttl() const;
  void set_lock_ttl(::google::protobuf::uint64 value);

  // bool local = 2;
  void clear_local();
  static const int kLocalFieldNumber = 2;
  bool local() const;
  void set_local(bool value);

  // bool strict_check = 16;
  void clear_strict_check();
  static const int kStrictCheckFieldNumber = 16;
  bool strict_check() const;
  void set_strict_check(bool value);

  // @@protoc_insertion_point(class_scope:txn.PrepareRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::txn::TxnIntent > intents_;
  ::google::protobuf::RepeatedPtrField< ::std::string> secondary_keys_;
  ::google::protobuf::internal::ArenaStringPtr txn_id_;
  ::google::protobuf::internal::ArenaStringPtr primary_key_;
  ::google::protobuf::uint64 lock_ttl_;
  bool local_;
  bool strict_check_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrepareResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.PrepareResponse) */ {
 public:
  PrepareResponse();
  virtual ~PrepareResponse();

  PrepareResponse(const PrepareResponse& from);

  inline PrepareResponse& operator=(const PrepareResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrepareResponse(PrepareResponse&& from) noexcept
    : PrepareResponse() {
    *this = ::std::move(from);
  }

  inline PrepareResponse& operator=(PrepareResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareResponse& default_instance();

  static inline const PrepareResponse* internal_default_instance() {
    return reinterpret_cast<const PrepareResponse*>(
               &_PrepareResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PrepareResponse* other);
  friend void swap(PrepareResponse& a, PrepareResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrepareResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PrepareResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PrepareResponse& from);
  void MergeFrom(const PrepareResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PrepareResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .txn.TxnError errors = 1;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 1;
  const ::txn::TxnError& errors(int index) const;
  ::txn::TxnError* mutable_errors(int index);
  ::txn::TxnError* add_errors();
  ::google::protobuf::RepeatedPtrField< ::txn::TxnError >*
      mutable_errors();
  const ::google::protobuf::RepeatedPtrField< ::txn::TxnError >&
      errors() const;

  // @@protoc_insertion_point(class_scope:txn.PrepareResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::txn::TxnError > errors_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsPrepareRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsPrepareRequest) */ {
 public:
  DsPrepareRequest();
  virtual ~DsPrepareRequest();

  DsPrepareRequest(const DsPrepareRequest& from);

  inline DsPrepareRequest& operator=(const DsPrepareRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsPrepareRequest(DsPrepareRequest&& from) noexcept
    : DsPrepareRequest() {
    *this = ::std::move(from);
  }

  inline DsPrepareRequest& operator=(DsPrepareRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsPrepareRequest& default_instance();

  static inline const DsPrepareRequest* internal_default_instance() {
    return reinterpret_cast<const DsPrepareRequest*>(
               &_DsPrepareRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DsPrepareRequest* other);
  friend void swap(DsPrepareRequest& a, DsPrepareRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsPrepareRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsPrepareRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsPrepareRequest& from);
  void MergeFrom(const DsPrepareRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsPrepareRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .txn.PrepareRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::txn::PrepareRequest& req() const;
  ::txn::PrepareRequest* mutable_req();
  ::txn::PrepareRequest* release_req();
  void set_allocated_req(::txn::PrepareRequest* req);

  // @@protoc_insertion_point(class_scope:txn.DsPrepareRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::txn::PrepareRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsPrepareResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsPrepareResponse) */ {
 public:
  DsPrepareResponse();
  virtual ~DsPrepareResponse();

  DsPrepareResponse(const DsPrepareResponse& from);

  inline DsPrepareResponse& operator=(const DsPrepareResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsPrepareResponse(DsPrepareResponse&& from) noexcept
    : DsPrepareResponse() {
    *this = ::std::move(from);
  }

  inline DsPrepareResponse& operator=(DsPrepareResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsPrepareResponse& default_instance();

  static inline const DsPrepareResponse* internal_default_instance() {
    return reinterpret_cast<const DsPrepareResponse*>(
               &_DsPrepareResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DsPrepareResponse* other);
  friend void swap(DsPrepareResponse& a, DsPrepareResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsPrepareResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsPrepareResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsPrepareResponse& from);
  void MergeFrom(const DsPrepareResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsPrepareResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .txn.PrepareResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::txn::PrepareResponse& resp() const;
  ::txn::PrepareResponse* mutable_resp();
  ::txn::PrepareResponse* release_resp();
  void set_allocated_resp(::txn::PrepareResponse* resp);

  // @@protoc_insertion_point(class_scope:txn.DsPrepareResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::txn::PrepareResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecideRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DecideRequest) */ {
 public:
  DecideRequest();
  virtual ~DecideRequest();

  DecideRequest(const DecideRequest& from);

  inline DecideRequest& operator=(const DecideRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecideRequest(DecideRequest&& from) noexcept
    : DecideRequest() {
    *this = ::std::move(from);
  }

  inline DecideRequest& operator=(DecideRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DecideRequest& default_instance();

  static inline const DecideRequest* internal_default_instance() {
    return reinterpret_cast<const DecideRequest*>(
               &_DecideRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DecideRequest* other);
  friend void swap(DecideRequest& a, DecideRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecideRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DecideRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DecideRequest& from);
  void MergeFrom(const DecideRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DecideRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // string txn_id = 1;
  void clear_txn_id();
  static const int kTxnIdFieldNumber = 1;
  const ::std::string& txn_id() const;
  void set_txn_id(const ::std::string& value);
  #if LANG_CXX11
  void set_txn_id(::std::string&& value);
  #endif
  void set_txn_id(const char* value);
  void set_txn_id(const char* value, size_t size);
  ::std::string* mutable_txn_id();
  ::std::string* release_txn_id();
  void set_allocated_txn_id(::std::string* txn_id);

  // .txn.TxnStatus status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::txn::TxnStatus status() const;
  void set_status(::txn::TxnStatus value);

  // bool clear_up = 4;
  void clear_clear_up();
  static const int kClearUpFieldNumber = 4;
  bool clear_up() const;
  void set_clear_up(bool value);

  // @@protoc_insertion_point(class_scope:txn.DecideRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr txn_id_;
  int status_;
  bool clear_up_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecideResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DecideResponse) */ {
 public:
  DecideResponse();
  virtual ~DecideResponse();

  DecideResponse(const DecideResponse& from);

  inline DecideResponse& operator=(const DecideResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecideResponse(DecideResponse&& from) noexcept
    : DecideResponse() {
    *this = ::std::move(from);
  }

  inline DecideResponse& operator=(DecideResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DecideResponse& default_instance();

  static inline const DecideResponse* internal_default_instance() {
    return reinterpret_cast<const DecideResponse*>(
               &_DecideResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DecideResponse* other);
  friend void swap(DecideResponse& a, DecideResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecideResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DecideResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DecideResponse& from);
  void MergeFrom(const DecideResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DecideResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .txn.TxnError errors = 1;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 1;
  const ::txn::TxnError& errors(int index) const;
  ::txn::TxnError* mutable_errors(int index);
  ::txn::TxnError* add_errors();
  ::google::protobuf::RepeatedPtrField< ::txn::TxnError >*
      mutable_errors();
  const ::google::protobuf::RepeatedPtrField< ::txn::TxnError >&
      errors() const;

  // @@protoc_insertion_point(class_scope:txn.DecideResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::txn::TxnError > errors_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsDecideRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsDecideRequest) */ {
 public:
  DsDecideRequest();
  virtual ~DsDecideRequest();

  DsDecideRequest(const DsDecideRequest& from);

  inline DsDecideRequest& operator=(const DsDecideRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsDecideRequest(DsDecideRequest&& from) noexcept
    : DsDecideRequest() {
    *this = ::std::move(from);
  }

  inline DsDecideRequest& operator=(DsDecideRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsDecideRequest& default_instance();

  static inline const DsDecideRequest* internal_default_instance() {
    return reinterpret_cast<const DsDecideRequest*>(
               &_DsDecideRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DsDecideRequest* other);
  friend void swap(DsDecideRequest& a, DsDecideRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsDecideRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsDecideRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsDecideRequest& from);
  void MergeFrom(const DsDecideRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsDecideRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .txn.DecideRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::txn::DecideRequest& req() const;
  ::txn::DecideRequest* mutable_req();
  ::txn::DecideRequest* release_req();
  void set_allocated_req(::txn::DecideRequest* req);

  // @@protoc_insertion_point(class_scope:txn.DsDecideRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::txn::DecideRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsDecideResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsDecideResponse) */ {
 public:
  DsDecideResponse();
  virtual ~DsDecideResponse();

  DsDecideResponse(const DsDecideResponse& from);

  inline DsDecideResponse& operator=(const DsDecideResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsDecideResponse(DsDecideResponse&& from) noexcept
    : DsDecideResponse() {
    *this = ::std::move(from);
  }

  inline DsDecideResponse& operator=(DsDecideResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsDecideResponse& default_instance();

  static inline const DsDecideResponse* internal_default_instance() {
    return reinterpret_cast<const DsDecideResponse*>(
               &_DsDecideResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DsDecideResponse* other);
  friend void swap(DsDecideResponse& a, DsDecideResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsDecideResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsDecideResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsDecideResponse& from);
  void MergeFrom(const DsDecideResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsDecideResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .txn.DecideResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::txn::DecideResponse& resp() const;
  ::txn::DecideResponse* mutable_resp();
  ::txn::DecideResponse* release_resp();
  void set_allocated_resp(::txn::DecideResponse* resp);

  // @@protoc_insertion_point(class_scope:txn.DsDecideResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::txn::DecideResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLockInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.GetLockInfoRequest) */ {
 public:
  GetLockInfoRequest();
  virtual ~GetLockInfoRequest();

  GetLockInfoRequest(const GetLockInfoRequest& from);

  inline GetLockInfoRequest& operator=(const GetLockInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLockInfoRequest(GetLockInfoRequest&& from) noexcept
    : GetLockInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetLockInfoRequest& operator=(GetLockInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLockInfoRequest& default_instance();

  static inline const GetLockInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetLockInfoRequest*>(
               &_GetLockInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GetLockInfoRequest* other);
  friend void swap(GetLockInfoRequest& a, GetLockInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLockInfoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLockInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLockInfoRequest& from);
  void MergeFrom(const GetLockInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLockInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string txn_id = 2;
  void clear_txn_id();
  static const int kTxnIdFieldNumber = 2;
  const ::std::string& txn_id() const;
  void set_txn_id(const ::std::string& value);
  #if LANG_CXX11
  void set_txn_id(::std::string&& value);
  #endif
  void set_txn_id(const char* value);
  void set_txn_id(const char* value, size_t size);
  ::std::string* mutable_txn_id();
  ::std::string* release_txn_id();
  void set_allocated_txn_id(::std::string* txn_id);

  // @@protoc_insertion_point(class_scope:txn.GetLockInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr txn_id_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLockInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.GetLockInfoResponse) */ {
 public:
  GetLockInfoResponse();
  virtual ~GetLockInfoResponse();

  GetLockInfoResponse(const GetLockInfoResponse& from);

  inline GetLockInfoResponse& operator=(const GetLockInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLockInfoResponse(GetLockInfoResponse&& from) noexcept
    : GetLockInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetLockInfoResponse& operator=(GetLockInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLockInfoResponse& default_instance();

  static inline const GetLockInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetLockInfoResponse*>(
               &_GetLockInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetLockInfoResponse* other);
  friend void swap(GetLockInfoResponse& a, GetLockInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLockInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLockInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLockInfoResponse& from);
  void MergeFrom(const GetLockInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLockInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .txn.LockInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::txn::LockInfo& info() const;
  ::txn::LockInfo* mutable_info();
  ::txn::LockInfo* release_info();
  void set_allocated_info(::txn::LockInfo* info);

  // @@protoc_insertion_point(class_scope:txn.GetLockInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::txn::LockInfo* info_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsGetLockInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsGetLockInfoRequest) */ {
 public:
  DsGetLockInfoRequest();
  virtual ~DsGetLockInfoRequest();

  DsGetLockInfoRequest(const DsGetLockInfoRequest& from);

  inline DsGetLockInfoRequest& operator=(const DsGetLockInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsGetLockInfoRequest(DsGetLockInfoRequest&& from) noexcept
    : DsGetLockInfoRequest() {
    *this = ::std::move(from);
  }

  inline DsGetLockInfoRequest& operator=(DsGetLockInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsGetLockInfoRequest& default_instance();

  static inline const DsGetLockInfoRequest* internal_default_instance() {
    return reinterpret_cast<const DsGetLockInfoRequest*>(
               &_DsGetLockInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DsGetLockInfoRequest* other);
  friend void swap(DsGetLockInfoRequest& a, DsGetLockInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsGetLockInfoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsGetLockInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsGetLockInfoRequest& from);
  void MergeFrom(const DsGetLockInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsGetLockInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .txn.GetLockInfoRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::txn::GetLockInfoRequest& req() const;
  ::txn::GetLockInfoRequest* mutable_req();
  ::txn::GetLockInfoRequest* release_req();
  void set_allocated_req(::txn::GetLockInfoRequest* req);

  // @@protoc_insertion_point(class_scope:txn.DsGetLockInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::txn::GetLockInfoRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsGetLockInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsGetLockInfoResponse) */ {
 public:
  DsGetLockInfoResponse();
  virtual ~DsGetLockInfoResponse();

  DsGetLockInfoResponse(const DsGetLockInfoResponse& from);

  inline DsGetLockInfoResponse& operator=(const DsGetLockInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsGetLockInfoResponse(DsGetLockInfoResponse&& from) noexcept
    : DsGetLockInfoResponse() {
    *this = ::std::move(from);
  }

  inline DsGetLockInfoResponse& operator=(DsGetLockInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsGetLockInfoResponse& default_instance();

  static inline const DsGetLockInfoResponse* internal_default_instance() {
    return reinterpret_cast<const DsGetLockInfoResponse*>(
               &_DsGetLockInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(DsGetLockInfoResponse* other);
  friend void swap(DsGetLockInfoResponse& a, DsGetLockInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsGetLockInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsGetLockInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsGetLockInfoResponse& from);
  void MergeFrom(const DsGetLockInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsGetLockInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .txn.GetLockInfoResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::txn::GetLockInfoResponse& resp() const;
  ::txn::GetLockInfoResponse* mutable_resp();
  ::txn::GetLockInfoResponse* release_resp();
  void set_allocated_resp(::txn::GetLockInfoResponse* resp);

  // @@protoc_insertion_point(class_scope:txn.DsGetLockInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::txn::GetLockInfoResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.SelectRequest) */ {
 public:
  SelectRequest();
  virtual ~SelectRequest();

  SelectRequest(const SelectRequest& from);

  inline SelectRequest& operator=(const SelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectRequest(SelectRequest&& from) noexcept
    : SelectRequest() {
    *this = ::std::move(from);
  }

  inline SelectRequest& operator=(SelectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectRequest& default_instance();

  static inline const SelectRequest* internal_default_instance() {
    return reinterpret_cast<const SelectRequest*>(
               &_SelectRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(SelectRequest* other);
  friend void swap(SelectRequest& a, SelectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectRequest& from);
  void MergeFrom(const SelectRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.SelectField field_list = 3;
  int field_list_size() const;
  void clear_field_list();
  static const int kFieldListFieldNumber = 3;
  const ::kvrpcpb::SelectField& field_list(int index) const;
  ::kvrpcpb::SelectField* mutable_field_list(int index);
  ::kvrpcpb::SelectField* add_field_list();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >*
      mutable_field_list();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >&
      field_list() const;

  // repeated .kvrpcpb.Match where_filters = 4;
  int where_filters_size() const;
  void clear_where_filters();
  static const int kWhereFiltersFieldNumber = 4;
  const ::kvrpcpb::Match& where_filters(int index) const;
  ::kvrpcpb::Match* mutable_where_filters(int index);
  ::kvrpcpb::Match* add_where_filters();
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
      mutable_where_filters();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
      where_filters() const;

  // repeated .metapb.Column group_bys = 5;
  int group_bys_size() const;
  void clear_group_bys();
  static const int kGroupBysFieldNumber = 5;
  const ::metapb::Column& group_bys(int index) const;
  ::metapb::Column* mutable_group_bys(int index);
  ::metapb::Column* add_group_bys();
  ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
      mutable_group_bys();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
      group_bys() const;

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Scope scope = 2;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  const ::kvrpcpb::Scope& scope() const;
  ::kvrpcpb::Scope* mutable_scope();
  ::kvrpcpb::Scope* release_scope();
  void set_allocated_scope(::kvrpcpb::Scope* scope);

  // .kvrpcpb.Limit limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  const ::kvrpcpb::Limit& limit() const;
  ::kvrpcpb::Limit* mutable_limit();
  ::kvrpcpb::Limit* release_limit();
  void set_allocated_limit(::kvrpcpb::Limit* limit);

  // @@protoc_insertion_point(class_scope:txn.SelectRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField > field_list_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match > where_filters_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Column > group_bys_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Scope* scope_;
  ::kvrpcpb::Limit* limit_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RowValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.RowValue) */ {
 public:
  RowValue();
  virtual ~RowValue();

  RowValue(const RowValue& from);

  inline RowValue& operator=(const RowValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RowValue(RowValue&& from) noexcept
    : RowValue() {
    *this = ::std::move(from);
  }

  inline RowValue& operator=(RowValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RowValue& default_instance();

  static inline const RowValue* internal_default_instance() {
    return reinterpret_cast<const RowValue*>(
               &_RowValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(RowValue* other);
  friend void swap(RowValue& a, RowValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RowValue* New() const PROTOBUF_FINAL { return New(NULL); }

  RowValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RowValue& from);
  void MergeFrom(const RowValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RowValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 aggred_counts = 2;
  int aggred_counts_size() const;
  void clear_aggred_counts();
  static const int kAggredCountsFieldNumber = 2;
  ::google::protobuf::int64 aggred_counts(int index) const;
  void set_aggred_counts(int index, ::google::protobuf::int64 value);
  void add_aggred_counts(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      aggred_counts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_aggred_counts();

  // bytes fields = 1;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  const ::std::string& fields() const;
  void set_fields(const ::std::string& value);
  #if LANG_CXX11
  void set_fields(::std::string&& value);
  #endif
  void set_fields(const char* value);
  void set_fields(const void* value, size_t size);
  ::std::string* mutable_fields();
  ::std::string* release_fields();
  void set_allocated_fields(::std::string* fields);

  // uint64 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:txn.RowValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > aggred_counts_;
  mutable int _aggred_counts_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr fields_;
  ::google::protobuf::uint64 version_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RowIntent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.RowIntent) */ {
 public:
  RowIntent();
  virtual ~RowIntent();

  RowIntent(const RowIntent& from);

  inline RowIntent& operator=(const RowIntent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RowIntent(RowIntent&& from) noexcept
    : RowIntent() {
    *this = ::std::move(from);
  }

  inline RowIntent& operator=(RowIntent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RowIntent& default_instance();

  static inline const RowIntent* internal_default_instance() {
    return reinterpret_cast<const RowIntent*>(
               &_RowIntent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(RowIntent* other);
  friend void swap(RowIntent& a, RowIntent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RowIntent* New() const PROTOBUF_FINAL { return New(NULL); }

  RowIntent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RowIntent& from);
  void MergeFrom(const RowIntent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RowIntent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string txn_id = 1;
  void clear_txn_id();
  static const int kTxnIdFieldNumber = 1;
  const ::std::string& txn_id() const;
  void set_txn_id(const ::std::string& value);
  #if LANG_CXX11
  void set_txn_id(::std::string&& value);
  #endif
  void set_txn_id(const char* value);
  void set_txn_id(const char* value, size_t size);
  ::std::string* mutable_txn_id();
  ::std::string* release_txn_id();
  void set_allocated_txn_id(::std::string* txn_id);

  // bytes primary_key = 2;
  void clear_primary_key();
  static const int kPrimaryKeyFieldNumber = 2;
  const ::std::string& primary_key() const;
  void set_primary_key(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_key(::std::string&& value);
  #endif
  void set_primary_key(const char* value);
  void set_primary_key(const void* value, size_t size);
  ::std::string* mutable_primary_key();
  ::std::string* release_primary_key();
  void set_allocated_primary_key(::std::string* primary_key);

  // .txn.RowValue value = 10;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 10;
  const ::txn::RowValue& value() const;
  ::txn::RowValue* mutable_value();
  ::txn::RowValue* release_value();
  void set_allocated_value(::txn::RowValue* value);

  // @@protoc_insertion_point(class_scope:txn.RowIntent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txn_id_;
  ::google::protobuf::internal::ArenaStringPtr primary_key_;
  ::txn::RowValue* value_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Row : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.Row) */ {
 public:
  Row();
  virtual ~Row();

  Row(const Row& from);

  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Row(Row&& from) noexcept
    : Row() {
    *this = ::std::move(from);
  }

  inline Row& operator=(Row&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Row& default_instance();

  static inline const Row* internal_default_instance() {
    return reinterpret_cast<const Row*>(
               &_Row_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Row* other);
  friend void swap(Row& a, Row& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Row* New() const PROTOBUF_FINAL { return New(NULL); }

  Row* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Row& from);
  void MergeFrom(const Row& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Row* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .txn.RowValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::txn::RowValue& value() const;
  ::txn::RowValue* mutable_value();
  ::txn::RowValue* release_value();
  void set_allocated_value(::txn::RowValue* value);

  // .txn.RowIntent intent = 3;
  bool has_intent() const;
  void clear_intent();
  static const int kIntentFieldNumber = 3;
  const ::txn::RowIntent& intent() const;
  ::txn::RowIntent* mutable_intent();
  ::txn::RowIntent* release_intent();
  void set_allocated_intent(::txn::RowIntent* intent);

  // @@protoc_insertion_point(class_scope:txn.Row)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::txn::RowValue* value_;
  ::txn::RowIntent* intent_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.SelectResponse) */ {
 public:
  SelectResponse();
  virtual ~SelectResponse();

  SelectResponse(const SelectResponse& from);

  inline SelectResponse& operator=(const SelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectResponse(SelectResponse&& from) noexcept
    : SelectResponse() {
    *this = ::std::move(from);
  }

  inline SelectResponse& operator=(SelectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectResponse& default_instance();

  static inline const SelectResponse* internal_default_instance() {
    return reinterpret_cast<const SelectResponse*>(
               &_SelectResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(SelectResponse* other);
  friend void swap(SelectResponse& a, SelectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectResponse& from);
  void MergeFrom(const SelectResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .txn.Row rows = 2;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  const ::txn::Row& rows(int index) const;
  ::txn::Row* mutable_rows(int index);
  ::txn::Row* add_rows();
  ::google::protobuf::RepeatedPtrField< ::txn::Row >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::txn::Row >&
      rows() const;

  // uint64 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:txn.SelectResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::txn::Row > rows_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsSelectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsSelectRequest) */ {
 public:
  DsSelectRequest();
  virtual ~DsSelectRequest();

  DsSelectRequest(const DsSelectRequest& from);

  inline DsSelectRequest& operator=(const DsSelectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsSelectRequest(DsSelectRequest&& from) noexcept
    : DsSelectRequest() {
    *this = ::std::move(from);
  }

  inline DsSelectRequest& operator=(DsSelectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsSelectRequest& default_instance();

  static inline const DsSelectRequest* internal_default_instance() {
    return reinterpret_cast<const DsSelectRequest*>(
               &_DsSelectRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(DsSelectRequest* other);
  friend void swap(DsSelectRequest& a, DsSelectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsSelectRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DsSelectRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsSelectRequest& from);
  void MergeFrom(const DsSelectRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsSelectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::RequestHeader& header() const;
  ::kvrpcpb::RequestHeader* mutable_header();
  ::kvrpcpb::RequestHeader* release_header();
  void set_allocated_header(::kvrpcpb::RequestHeader* header);

  // .txn.SelectRequest req = 2;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 2;
  const ::txn::SelectRequest& req() const;
  ::txn::SelectRequest* mutable_req();
  ::txn::SelectRequest* release_req();
  void set_allocated_req(::txn::SelectRequest* req);

  // @@protoc_insertion_point(class_scope:txn.DsSelectRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::RequestHeader* header_;
  ::txn::SelectRequest* req_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DsSelectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:txn.DsSelectResponse) */ {
 public:
  DsSelectResponse();
  virtual ~DsSelectResponse();

  DsSelectResponse(const DsSelectResponse& from);

  inline DsSelectResponse& operator=(const DsSelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DsSelectResponse(DsSelectResponse&& from) noexcept
    : DsSelectResponse() {
    *this = ::std::move(from);
  }

  inline DsSelectResponse& operator=(DsSelectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DsSelectResponse& default_instance();

  static inline const DsSelectResponse* internal_default_instance() {
    return reinterpret_cast<const DsSelectResponse*>(
               &_DsSelectResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(DsSelectResponse* other);
  friend void swap(DsSelectResponse& a, DsSelectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DsSelectResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DsSelectResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DsSelectResponse& from);
  void MergeFrom(const DsSelectResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DsSelectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::kvrpcpb::ResponseHeader& header() const;
  ::kvrpcpb::ResponseHeader* mutable_header();
  ::kvrpcpb::ResponseHeader* release_header();
  void set_allocated_header(::kvrpcpb::ResponseHeader* header);

  // .txn.SelectResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::txn::SelectResponse& resp() const;
  ::txn::SelectResponse* mutable_resp();
  ::txn::SelectResponse* release_resp();
  void set_allocated_resp(::txn::SelectResponse* resp);

  // @@protoc_insertion_point(class_scope:txn.DsSelectResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ResponseHeader* header_;
  ::txn::SelectResponse* resp_;
  mutable int _cached_size_;
  friend struct protobuf_txn_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TxnIntent

// .txn.OpType typ = 1;
inline void TxnIntent::clear_typ() {
  typ_ = 0;
}
inline ::txn::OpType TxnIntent::typ() const {
  // @@protoc_insertion_point(field_get:txn.TxnIntent.typ)
  return static_cast< ::txn::OpType >(typ_);
}
inline void TxnIntent::set_typ(::txn::OpType value) {
  
  typ_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnIntent.typ)
}

// bytes key = 2;
inline void TxnIntent::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxnIntent::key() const {
  // @@protoc_insertion_point(field_get:txn.TxnIntent.key)
  return key_.GetNoArena();
}
inline void TxnIntent::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.TxnIntent.key)
}
#if LANG_CXX11
inline void TxnIntent::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.TxnIntent.key)
}
#endif
inline void TxnIntent::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.TxnIntent.key)
}
inline void TxnIntent::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.TxnIntent.key)
}
inline ::std::string* TxnIntent::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.TxnIntent.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxnIntent::release_key() {
  // @@protoc_insertion_point(field_release:txn.TxnIntent.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxnIntent::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:txn.TxnIntent.key)
}

// bytes value = 3;
inline void TxnIntent::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxnIntent::value() const {
  // @@protoc_insertion_point(field_get:txn.TxnIntent.value)
  return value_.GetNoArena();
}
inline void TxnIntent::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.TxnIntent.value)
}
#if LANG_CXX11
inline void TxnIntent::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.TxnIntent.value)
}
#endif
inline void TxnIntent::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.TxnIntent.value)
}
inline void TxnIntent::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.TxnIntent.value)
}
inline ::std::string* TxnIntent::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:txn.TxnIntent.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxnIntent::release_value() {
  // @@protoc_insertion_point(field_release:txn.TxnIntent.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxnIntent::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:txn.TxnIntent.value)
}

// bool check_unique = 4;
inline void TxnIntent::clear_check_unique() {
  check_unique_ = false;
}
inline bool TxnIntent::check_unique() const {
  // @@protoc_insertion_point(field_get:txn.TxnIntent.check_unique)
  return check_unique_;
}
inline void TxnIntent::set_check_unique(bool value) {
  
  check_unique_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnIntent.check_unique)
}

// uint64 expected_ver = 5;
inline void TxnIntent::clear_expected_ver() {
  expected_ver_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxnIntent::expected_ver() const {
  // @@protoc_insertion_point(field_get:txn.TxnIntent.expected_ver)
  return expected_ver_;
}
inline void TxnIntent::set_expected_ver(::google::protobuf::uint64 value) {
  
  expected_ver_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnIntent.expected_ver)
}

// bool is_primary = 6;
inline void TxnIntent::clear_is_primary() {
  is_primary_ = false;
}
inline bool TxnIntent::is_primary() const {
  // @@protoc_insertion_point(field_get:txn.TxnIntent.is_primary)
  return is_primary_;
}
inline void TxnIntent::set_is_primary(bool value) {
  
  is_primary_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnIntent.is_primary)
}

// -------------------------------------------------------------------

// TxnValue

// string txn_id = 1;
inline void TxnValue::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxnValue::txn_id() const {
  // @@protoc_insertion_point(field_get:txn.TxnValue.txn_id)
  return txn_id_.GetNoArena();
}
inline void TxnValue::set_txn_id(const ::std::string& value) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.TxnValue.txn_id)
}
#if LANG_CXX11
inline void TxnValue::set_txn_id(::std::string&& value) {
  
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.TxnValue.txn_id)
}
#endif
inline void TxnValue::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.TxnValue.txn_id)
}
inline void TxnValue::set_txn_id(const char* value, size_t size) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.TxnValue.txn_id)
}
inline ::std::string* TxnValue::mutable_txn_id() {
  
  // @@protoc_insertion_point(field_mutable:txn.TxnValue.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxnValue::release_txn_id() {
  // @@protoc_insertion_point(field_release:txn.TxnValue.txn_id)
  
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxnValue::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    
  } else {
    
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:txn.TxnValue.txn_id)
}

// .txn.TxnIntent intent = 2;
inline bool TxnValue::has_intent() const {
  return this != internal_default_instance() && intent_ != NULL;
}
inline void TxnValue::clear_intent() {
  if (GetArenaNoVirtual() == NULL && intent_ != NULL) delete intent_;
  intent_ = NULL;
}
inline const ::txn::TxnIntent& TxnValue::intent() const {
  const ::txn::TxnIntent* p = intent_;
  // @@protoc_insertion_point(field_get:txn.TxnValue.intent)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::TxnIntent*>(
      &::txn::_TxnIntent_default_instance_);
}
inline ::txn::TxnIntent* TxnValue::mutable_intent() {
  
  if (intent_ == NULL) {
    intent_ = new ::txn::TxnIntent;
  }
  // @@protoc_insertion_point(field_mutable:txn.TxnValue.intent)
  return intent_;
}
inline ::txn::TxnIntent* TxnValue::release_intent() {
  // @@protoc_insertion_point(field_release:txn.TxnValue.intent)
  
  ::txn::TxnIntent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline void TxnValue::set_allocated_intent(::txn::TxnIntent* intent) {
  delete intent_;
  intent_ = intent;
  if (intent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.TxnValue.intent)
}

// bytes primary_key = 3;
inline void TxnValue::clear_primary_key() {
  primary_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxnValue::primary_key() const {
  // @@protoc_insertion_point(field_get:txn.TxnValue.primary_key)
  return primary_key_.GetNoArena();
}
inline void TxnValue::set_primary_key(const ::std::string& value) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.TxnValue.primary_key)
}
#if LANG_CXX11
inline void TxnValue::set_primary_key(::std::string&& value) {
  
  primary_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.TxnValue.primary_key)
}
#endif
inline void TxnValue::set_primary_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.TxnValue.primary_key)
}
inline void TxnValue::set_primary_key(const void* value, size_t size) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.TxnValue.primary_key)
}
inline ::std::string* TxnValue::mutable_primary_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.TxnValue.primary_key)
  return primary_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxnValue::release_primary_key() {
  // @@protoc_insertion_point(field_release:txn.TxnValue.primary_key)
  
  return primary_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxnValue::set_allocated_primary_key(::std::string* primary_key) {
  if (primary_key != NULL) {
    
  } else {
    
  }
  primary_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_key);
  // @@protoc_insertion_point(field_set_allocated:txn.TxnValue.primary_key)
}

// uint64 expired_at = 4;
inline void TxnValue::clear_expired_at() {
  expired_at_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxnValue::expired_at() const {
  // @@protoc_insertion_point(field_get:txn.TxnValue.expired_at)
  return expired_at_;
}
inline void TxnValue::set_expired_at(::google::protobuf::uint64 value) {
  
  expired_at_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnValue.expired_at)
}

// .txn.TxnStatus txn_status = 10;
inline void TxnValue::clear_txn_status() {
  txn_status_ = 0;
}
inline ::txn::TxnStatus TxnValue::txn_status() const {
  // @@protoc_insertion_point(field_get:txn.TxnValue.txn_status)
  return static_cast< ::txn::TxnStatus >(txn_status_);
}
inline void TxnValue::set_txn_status(::txn::TxnStatus value) {
  
  txn_status_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnValue.txn_status)
}

// repeated bytes secondary_keys = 11;
inline int TxnValue::secondary_keys_size() const {
  return secondary_keys_.size();
}
inline void TxnValue::clear_secondary_keys() {
  secondary_keys_.Clear();
}
inline const ::std::string& TxnValue::secondary_keys(int index) const {
  // @@protoc_insertion_point(field_get:txn.TxnValue.secondary_keys)
  return secondary_keys_.Get(index);
}
inline ::std::string* TxnValue::mutable_secondary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:txn.TxnValue.secondary_keys)
  return secondary_keys_.Mutable(index);
}
inline void TxnValue::set_secondary_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:txn.TxnValue.secondary_keys)
  secondary_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TxnValue::set_secondary_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:txn.TxnValue.secondary_keys)
  secondary_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TxnValue::set_secondary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  secondary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:txn.TxnValue.secondary_keys)
}
inline void TxnValue::set_secondary_keys(int index, const void* value, size_t size) {
  secondary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:txn.TxnValue.secondary_keys)
}
inline ::std::string* TxnValue::add_secondary_keys() {
  // @@protoc_insertion_point(field_add_mutable:txn.TxnValue.secondary_keys)
  return secondary_keys_.Add();
}
inline void TxnValue::add_secondary_keys(const ::std::string& value) {
  secondary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:txn.TxnValue.secondary_keys)
}
#if LANG_CXX11
inline void TxnValue::add_secondary_keys(::std::string&& value) {
  secondary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:txn.TxnValue.secondary_keys)
}
#endif
inline void TxnValue::add_secondary_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  secondary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:txn.TxnValue.secondary_keys)
}
inline void TxnValue::add_secondary_keys(const void* value, size_t size) {
  secondary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:txn.TxnValue.secondary_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TxnValue::secondary_keys() const {
  // @@protoc_insertion_point(field_list:txn.TxnValue.secondary_keys)
  return secondary_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TxnValue::mutable_secondary_keys() {
  // @@protoc_insertion_point(field_mutable_list:txn.TxnValue.secondary_keys)
  return &secondary_keys_;
}

// -------------------------------------------------------------------

// LockInfo

// string txn_id = 1;
inline void LockInfo::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockInfo::txn_id() const {
  // @@protoc_insertion_point(field_get:txn.LockInfo.txn_id)
  return txn_id_.GetNoArena();
}
inline void LockInfo::set_txn_id(const ::std::string& value) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.LockInfo.txn_id)
}
#if LANG_CXX11
inline void LockInfo::set_txn_id(::std::string&& value) {
  
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.LockInfo.txn_id)
}
#endif
inline void LockInfo::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.LockInfo.txn_id)
}
inline void LockInfo::set_txn_id(const char* value, size_t size) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.LockInfo.txn_id)
}
inline ::std::string* LockInfo::mutable_txn_id() {
  
  // @@protoc_insertion_point(field_mutable:txn.LockInfo.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockInfo::release_txn_id() {
  // @@protoc_insertion_point(field_release:txn.LockInfo.txn_id)
  
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockInfo::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    
  } else {
    
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:txn.LockInfo.txn_id)
}

// bool timeout = 2;
inline void LockInfo::clear_timeout() {
  timeout_ = false;
}
inline bool LockInfo::timeout() const {
  // @@protoc_insertion_point(field_get:txn.LockInfo.timeout)
  return timeout_;
}
inline void LockInfo::set_timeout(bool value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:txn.LockInfo.timeout)
}

// bool is_primary = 10;
inline void LockInfo::clear_is_primary() {
  is_primary_ = false;
}
inline bool LockInfo::is_primary() const {
  // @@protoc_insertion_point(field_get:txn.LockInfo.is_primary)
  return is_primary_;
}
inline void LockInfo::set_is_primary(bool value) {
  
  is_primary_ = value;
  // @@protoc_insertion_point(field_set:txn.LockInfo.is_primary)
}

// bytes primary_key = 11;
inline void LockInfo::clear_primary_key() {
  primary_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockInfo::primary_key() const {
  // @@protoc_insertion_point(field_get:txn.LockInfo.primary_key)
  return primary_key_.GetNoArena();
}
inline void LockInfo::set_primary_key(const ::std::string& value) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.LockInfo.primary_key)
}
#if LANG_CXX11
inline void LockInfo::set_primary_key(::std::string&& value) {
  
  primary_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.LockInfo.primary_key)
}
#endif
inline void LockInfo::set_primary_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.LockInfo.primary_key)
}
inline void LockInfo::set_primary_key(const void* value, size_t size) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.LockInfo.primary_key)
}
inline ::std::string* LockInfo::mutable_primary_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.LockInfo.primary_key)
  return primary_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockInfo::release_primary_key() {
  // @@protoc_insertion_point(field_release:txn.LockInfo.primary_key)
  
  return primary_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockInfo::set_allocated_primary_key(::std::string* primary_key) {
  if (primary_key != NULL) {
    
  } else {
    
  }
  primary_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_key);
  // @@protoc_insertion_point(field_set_allocated:txn.LockInfo.primary_key)
}

// .txn.TxnStatus status = 12;
inline void LockInfo::clear_status() {
  status_ = 0;
}
inline ::txn::TxnStatus LockInfo::status() const {
  // @@protoc_insertion_point(field_get:txn.LockInfo.status)
  return static_cast< ::txn::TxnStatus >(status_);
}
inline void LockInfo::set_status(::txn::TxnStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:txn.LockInfo.status)
}

// repeated bytes secondary_keys = 13;
inline int LockInfo::secondary_keys_size() const {
  return secondary_keys_.size();
}
inline void LockInfo::clear_secondary_keys() {
  secondary_keys_.Clear();
}
inline const ::std::string& LockInfo::secondary_keys(int index) const {
  // @@protoc_insertion_point(field_get:txn.LockInfo.secondary_keys)
  return secondary_keys_.Get(index);
}
inline ::std::string* LockInfo::mutable_secondary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:txn.LockInfo.secondary_keys)
  return secondary_keys_.Mutable(index);
}
inline void LockInfo::set_secondary_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:txn.LockInfo.secondary_keys)
  secondary_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LockInfo::set_secondary_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:txn.LockInfo.secondary_keys)
  secondary_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LockInfo::set_secondary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  secondary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:txn.LockInfo.secondary_keys)
}
inline void LockInfo::set_secondary_keys(int index, const void* value, size_t size) {
  secondary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:txn.LockInfo.secondary_keys)
}
inline ::std::string* LockInfo::add_secondary_keys() {
  // @@protoc_insertion_point(field_add_mutable:txn.LockInfo.secondary_keys)
  return secondary_keys_.Add();
}
inline void LockInfo::add_secondary_keys(const ::std::string& value) {
  secondary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:txn.LockInfo.secondary_keys)
}
#if LANG_CXX11
inline void LockInfo::add_secondary_keys(::std::string&& value) {
  secondary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:txn.LockInfo.secondary_keys)
}
#endif
inline void LockInfo::add_secondary_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  secondary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:txn.LockInfo.secondary_keys)
}
inline void LockInfo::add_secondary_keys(const void* value, size_t size) {
  secondary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:txn.LockInfo.secondary_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LockInfo::secondary_keys() const {
  // @@protoc_insertion_point(field_list:txn.LockInfo.secondary_keys)
  return secondary_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LockInfo::mutable_secondary_keys() {
  // @@protoc_insertion_point(field_mutable_list:txn.LockInfo.secondary_keys)
  return &secondary_keys_;
}

// -------------------------------------------------------------------

// LockError

// bytes key = 1;
inline void LockError::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockError::key() const {
  // @@protoc_insertion_point(field_get:txn.LockError.key)
  return key_.GetNoArena();
}
inline void LockError::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.LockError.key)
}
#if LANG_CXX11
inline void LockError::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.LockError.key)
}
#endif
inline void LockError::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.LockError.key)
}
inline void LockError::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.LockError.key)
}
inline ::std::string* LockError::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.LockError.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockError::release_key() {
  // @@protoc_insertion_point(field_release:txn.LockError.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockError::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:txn.LockError.key)
}

// .txn.LockInfo info = 2;
inline bool LockError::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void LockError::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::txn::LockInfo& LockError::info() const {
  const ::txn::LockInfo* p = info_;
  // @@protoc_insertion_point(field_get:txn.LockError.info)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::LockInfo*>(
      &::txn::_LockInfo_default_instance_);
}
inline ::txn::LockInfo* LockError::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::txn::LockInfo;
  }
  // @@protoc_insertion_point(field_mutable:txn.LockError.info)
  return info_;
}
inline ::txn::LockInfo* LockError::release_info() {
  // @@protoc_insertion_point(field_release:txn.LockError.info)
  
  ::txn::LockInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void LockError::set_allocated_info(::txn::LockInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.LockError.info)
}

// -------------------------------------------------------------------

// UnexpectedVer

// bytes key = 1;
inline void UnexpectedVer::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnexpectedVer::key() const {
  // @@protoc_insertion_point(field_get:txn.UnexpectedVer.key)
  return key_.GetNoArena();
}
inline void UnexpectedVer::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.UnexpectedVer.key)
}
#if LANG_CXX11
inline void UnexpectedVer::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.UnexpectedVer.key)
}
#endif
inline void UnexpectedVer::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.UnexpectedVer.key)
}
inline void UnexpectedVer::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.UnexpectedVer.key)
}
inline ::std::string* UnexpectedVer::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.UnexpectedVer.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnexpectedVer::release_key() {
  // @@protoc_insertion_point(field_release:txn.UnexpectedVer.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnexpectedVer::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:txn.UnexpectedVer.key)
}

// uint64 expected_ver = 2;
inline void UnexpectedVer::clear_expected_ver() {
  expected_ver_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UnexpectedVer::expected_ver() const {
  // @@protoc_insertion_point(field_get:txn.UnexpectedVer.expected_ver)
  return expected_ver_;
}
inline void UnexpectedVer::set_expected_ver(::google::protobuf::uint64 value) {
  
  expected_ver_ = value;
  // @@protoc_insertion_point(field_set:txn.UnexpectedVer.expected_ver)
}

// uint64 actual_ver = 3;
inline void UnexpectedVer::clear_actual_ver() {
  actual_ver_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UnexpectedVer::actual_ver() const {
  // @@protoc_insertion_point(field_get:txn.UnexpectedVer.actual_ver)
  return actual_ver_;
}
inline void UnexpectedVer::set_actual_ver(::google::protobuf::uint64 value) {
  
  actual_ver_ = value;
  // @@protoc_insertion_point(field_set:txn.UnexpectedVer.actual_ver)
}

// -------------------------------------------------------------------

// StatusConflict

// .txn.TxnStatus status = 1;
inline void StatusConflict::clear_status() {
  status_ = 0;
}
inline ::txn::TxnStatus StatusConflict::status() const {
  // @@protoc_insertion_point(field_get:txn.StatusConflict.status)
  return static_cast< ::txn::TxnStatus >(status_);
}
inline void StatusConflict::set_status(::txn::TxnStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:txn.StatusConflict.status)
}

// -------------------------------------------------------------------

// TxnError

// .txn.TxnError.ErrType err_type = 1;
inline void TxnError::clear_err_type() {
  err_type_ = 0;
}
inline ::txn::TxnError_ErrType TxnError::err_type() const {
  // @@protoc_insertion_point(field_get:txn.TxnError.err_type)
  return static_cast< ::txn::TxnError_ErrType >(err_type_);
}
inline void TxnError::set_err_type(::txn::TxnError_ErrType value) {
  
  err_type_ = value;
  // @@protoc_insertion_point(field_set:txn.TxnError.err_type)
}

// .txn.LockError lock_err = 2;
inline bool TxnError::has_lock_err() const {
  return this != internal_default_instance() && lock_err_ != NULL;
}
inline void TxnError::clear_lock_err() {
  if (GetArenaNoVirtual() == NULL && lock_err_ != NULL) delete lock_err_;
  lock_err_ = NULL;
}
inline const ::txn::LockError& TxnError::lock_err() const {
  const ::txn::LockError* p = lock_err_;
  // @@protoc_insertion_point(field_get:txn.TxnError.lock_err)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::LockError*>(
      &::txn::_LockError_default_instance_);
}
inline ::txn::LockError* TxnError::mutable_lock_err() {
  
  if (lock_err_ == NULL) {
    lock_err_ = new ::txn::LockError;
  }
  // @@protoc_insertion_point(field_mutable:txn.TxnError.lock_err)
  return lock_err_;
}
inline ::txn::LockError* TxnError::release_lock_err() {
  // @@protoc_insertion_point(field_release:txn.TxnError.lock_err)
  
  ::txn::LockError* temp = lock_err_;
  lock_err_ = NULL;
  return temp;
}
inline void TxnError::set_allocated_lock_err(::txn::LockError* lock_err) {
  delete lock_err_;
  lock_err_ = lock_err;
  if (lock_err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.TxnError.lock_err)
}

// .txn.UnexpectedVer unexpected_ver = 3;
inline bool TxnError::has_unexpected_ver() const {
  return this != internal_default_instance() && unexpected_ver_ != NULL;
}
inline void TxnError::clear_unexpected_ver() {
  if (GetArenaNoVirtual() == NULL && unexpected_ver_ != NULL) delete unexpected_ver_;
  unexpected_ver_ = NULL;
}
inline const ::txn::UnexpectedVer& TxnError::unexpected_ver() const {
  const ::txn::UnexpectedVer* p = unexpected_ver_;
  // @@protoc_insertion_point(field_get:txn.TxnError.unexpected_ver)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::UnexpectedVer*>(
      &::txn::_UnexpectedVer_default_instance_);
}
inline ::txn::UnexpectedVer* TxnError::mutable_unexpected_ver() {
  
  if (unexpected_ver_ == NULL) {
    unexpected_ver_ = new ::txn::UnexpectedVer;
  }
  // @@protoc_insertion_point(field_mutable:txn.TxnError.unexpected_ver)
  return unexpected_ver_;
}
inline ::txn::UnexpectedVer* TxnError::release_unexpected_ver() {
  // @@protoc_insertion_point(field_release:txn.TxnError.unexpected_ver)
  
  ::txn::UnexpectedVer* temp = unexpected_ver_;
  unexpected_ver_ = NULL;
  return temp;
}
inline void TxnError::set_allocated_unexpected_ver(::txn::UnexpectedVer* unexpected_ver) {
  delete unexpected_ver_;
  unexpected_ver_ = unexpected_ver;
  if (unexpected_ver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.TxnError.unexpected_ver)
}

// .txn.StatusConflict status_conflict = 4;
inline bool TxnError::has_status_conflict() const {
  return this != internal_default_instance() && status_conflict_ != NULL;
}
inline void TxnError::clear_status_conflict() {
  if (GetArenaNoVirtual() == NULL && status_conflict_ != NULL) delete status_conflict_;
  status_conflict_ = NULL;
}
inline const ::txn::StatusConflict& TxnError::status_conflict() const {
  const ::txn::StatusConflict* p = status_conflict_;
  // @@protoc_insertion_point(field_get:txn.TxnError.status_conflict)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::StatusConflict*>(
      &::txn::_StatusConflict_default_instance_);
}
inline ::txn::StatusConflict* TxnError::mutable_status_conflict() {
  
  if (status_conflict_ == NULL) {
    status_conflict_ = new ::txn::StatusConflict;
  }
  // @@protoc_insertion_point(field_mutable:txn.TxnError.status_conflict)
  return status_conflict_;
}
inline ::txn::StatusConflict* TxnError::release_status_conflict() {
  // @@protoc_insertion_point(field_release:txn.TxnError.status_conflict)
  
  ::txn::StatusConflict* temp = status_conflict_;
  status_conflict_ = NULL;
  return temp;
}
inline void TxnError::set_allocated_status_conflict(::txn::StatusConflict* status_conflict) {
  delete status_conflict_;
  status_conflict_ = status_conflict;
  if (status_conflict) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.TxnError.status_conflict)
}

// -------------------------------------------------------------------

// PrepareRequest

// string txn_id = 1;
inline void PrepareRequest::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrepareRequest::txn_id() const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.txn_id)
  return txn_id_.GetNoArena();
}
inline void PrepareRequest::set_txn_id(const ::std::string& value) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.txn_id)
}
#if LANG_CXX11
inline void PrepareRequest::set_txn_id(::std::string&& value) {
  
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.PrepareRequest.txn_id)
}
#endif
inline void PrepareRequest::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.PrepareRequest.txn_id)
}
inline void PrepareRequest::set_txn_id(const char* value, size_t size) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.PrepareRequest.txn_id)
}
inline ::std::string* PrepareRequest::mutable_txn_id() {
  
  // @@protoc_insertion_point(field_mutable:txn.PrepareRequest.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrepareRequest::release_txn_id() {
  // @@protoc_insertion_point(field_release:txn.PrepareRequest.txn_id)
  
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrepareRequest::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    
  } else {
    
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:txn.PrepareRequest.txn_id)
}

// bool local = 2;
inline void PrepareRequest::clear_local() {
  local_ = false;
}
inline bool PrepareRequest::local() const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.local)
  return local_;
}
inline void PrepareRequest::set_local(bool value) {
  
  local_ = value;
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.local)
}

// repeated .txn.TxnIntent intents = 3;
inline int PrepareRequest::intents_size() const {
  return intents_.size();
}
inline void PrepareRequest::clear_intents() {
  intents_.Clear();
}
inline const ::txn::TxnIntent& PrepareRequest::intents(int index) const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.intents)
  return intents_.Get(index);
}
inline ::txn::TxnIntent* PrepareRequest::mutable_intents(int index) {
  // @@protoc_insertion_point(field_mutable:txn.PrepareRequest.intents)
  return intents_.Mutable(index);
}
inline ::txn::TxnIntent* PrepareRequest::add_intents() {
  // @@protoc_insertion_point(field_add:txn.PrepareRequest.intents)
  return intents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::txn::TxnIntent >*
PrepareRequest::mutable_intents() {
  // @@protoc_insertion_point(field_mutable_list:txn.PrepareRequest.intents)
  return &intents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::txn::TxnIntent >&
PrepareRequest::intents() const {
  // @@protoc_insertion_point(field_list:txn.PrepareRequest.intents)
  return intents_;
}

// bytes primary_key = 4;
inline void PrepareRequest::clear_primary_key() {
  primary_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrepareRequest::primary_key() const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.primary_key)
  return primary_key_.GetNoArena();
}
inline void PrepareRequest::set_primary_key(const ::std::string& value) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.primary_key)
}
#if LANG_CXX11
inline void PrepareRequest::set_primary_key(::std::string&& value) {
  
  primary_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.PrepareRequest.primary_key)
}
#endif
inline void PrepareRequest::set_primary_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.PrepareRequest.primary_key)
}
inline void PrepareRequest::set_primary_key(const void* value, size_t size) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.PrepareRequest.primary_key)
}
inline ::std::string* PrepareRequest::mutable_primary_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.PrepareRequest.primary_key)
  return primary_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrepareRequest::release_primary_key() {
  // @@protoc_insertion_point(field_release:txn.PrepareRequest.primary_key)
  
  return primary_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrepareRequest::set_allocated_primary_key(::std::string* primary_key) {
  if (primary_key != NULL) {
    
  } else {
    
  }
  primary_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_key);
  // @@protoc_insertion_point(field_set_allocated:txn.PrepareRequest.primary_key)
}

// uint64 lock_ttl = 5;
inline void PrepareRequest::clear_lock_ttl() {
  lock_ttl_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PrepareRequest::lock_ttl() const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.lock_ttl)
  return lock_ttl_;
}
inline void PrepareRequest::set_lock_ttl(::google::protobuf::uint64 value) {
  
  lock_ttl_ = value;
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.lock_ttl)
}

// repeated bytes secondary_keys = 6;
inline int PrepareRequest::secondary_keys_size() const {
  return secondary_keys_.size();
}
inline void PrepareRequest::clear_secondary_keys() {
  secondary_keys_.Clear();
}
inline const ::std::string& PrepareRequest::secondary_keys(int index) const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.secondary_keys)
  return secondary_keys_.Get(index);
}
inline ::std::string* PrepareRequest::mutable_secondary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:txn.PrepareRequest.secondary_keys)
  return secondary_keys_.Mutable(index);
}
inline void PrepareRequest::set_secondary_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.secondary_keys)
  secondary_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PrepareRequest::set_secondary_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.secondary_keys)
  secondary_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PrepareRequest::set_secondary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  secondary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:txn.PrepareRequest.secondary_keys)
}
inline void PrepareRequest::set_secondary_keys(int index, const void* value, size_t size) {
  secondary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:txn.PrepareRequest.secondary_keys)
}
inline ::std::string* PrepareRequest::add_secondary_keys() {
  // @@protoc_insertion_point(field_add_mutable:txn.PrepareRequest.secondary_keys)
  return secondary_keys_.Add();
}
inline void PrepareRequest::add_secondary_keys(const ::std::string& value) {
  secondary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:txn.PrepareRequest.secondary_keys)
}
#if LANG_CXX11
inline void PrepareRequest::add_secondary_keys(::std::string&& value) {
  secondary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:txn.PrepareRequest.secondary_keys)
}
#endif
inline void PrepareRequest::add_secondary_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  secondary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:txn.PrepareRequest.secondary_keys)
}
inline void PrepareRequest::add_secondary_keys(const void* value, size_t size) {
  secondary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:txn.PrepareRequest.secondary_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrepareRequest::secondary_keys() const {
  // @@protoc_insertion_point(field_list:txn.PrepareRequest.secondary_keys)
  return secondary_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrepareRequest::mutable_secondary_keys() {
  // @@protoc_insertion_point(field_mutable_list:txn.PrepareRequest.secondary_keys)
  return &secondary_keys_;
}

// bool strict_check = 16;
inline void PrepareRequest::clear_strict_check() {
  strict_check_ = false;
}
inline bool PrepareRequest::strict_check() const {
  // @@protoc_insertion_point(field_get:txn.PrepareRequest.strict_check)
  return strict_check_;
}
inline void PrepareRequest::set_strict_check(bool value) {
  
  strict_check_ = value;
  // @@protoc_insertion_point(field_set:txn.PrepareRequest.strict_check)
}

// -------------------------------------------------------------------

// PrepareResponse

// repeated .txn.TxnError errors = 1;
inline int PrepareResponse::errors_size() const {
  return errors_.size();
}
inline void PrepareResponse::clear_errors() {
  errors_.Clear();
}
inline const ::txn::TxnError& PrepareResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:txn.PrepareResponse.errors)
  return errors_.Get(index);
}
inline ::txn::TxnError* PrepareResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:txn.PrepareResponse.errors)
  return errors_.Mutable(index);
}
inline ::txn::TxnError* PrepareResponse::add_errors() {
  // @@protoc_insertion_point(field_add:txn.PrepareResponse.errors)
  return errors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::txn::TxnError >*
PrepareResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:txn.PrepareResponse.errors)
  return &errors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::txn::TxnError >&
PrepareResponse::errors() const {
  // @@protoc_insertion_point(field_list:txn.PrepareResponse.errors)
  return errors_;
}

// -------------------------------------------------------------------

// DsPrepareRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsPrepareRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsPrepareRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsPrepareRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsPrepareRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsPrepareRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsPrepareRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsPrepareRequest::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsPrepareRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsPrepareRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsPrepareRequest.header)
}

// .txn.PrepareRequest req = 2;
inline bool DsPrepareRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsPrepareRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::txn::PrepareRequest& DsPrepareRequest::req() const {
  const ::txn::PrepareRequest* p = req_;
  // @@protoc_insertion_point(field_get:txn.DsPrepareRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::PrepareRequest*>(
      &::txn::_PrepareRequest_default_instance_);
}
inline ::txn::PrepareRequest* DsPrepareRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::txn::PrepareRequest;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsPrepareRequest.req)
  return req_;
}
inline ::txn::PrepareRequest* DsPrepareRequest::release_req() {
  // @@protoc_insertion_point(field_release:txn.DsPrepareRequest.req)
  
  ::txn::PrepareRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsPrepareRequest::set_allocated_req(::txn::PrepareRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsPrepareRequest.req)
}

// -------------------------------------------------------------------

// DsPrepareResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsPrepareResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsPrepareResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsPrepareResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsPrepareResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsPrepareResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsPrepareResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsPrepareResponse::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsPrepareResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsPrepareResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsPrepareResponse.header)
}

// .txn.PrepareResponse resp = 2;
inline bool DsPrepareResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsPrepareResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::txn::PrepareResponse& DsPrepareResponse::resp() const {
  const ::txn::PrepareResponse* p = resp_;
  // @@protoc_insertion_point(field_get:txn.DsPrepareResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::PrepareResponse*>(
      &::txn::_PrepareResponse_default_instance_);
}
inline ::txn::PrepareResponse* DsPrepareResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::txn::PrepareResponse;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsPrepareResponse.resp)
  return resp_;
}
inline ::txn::PrepareResponse* DsPrepareResponse::release_resp() {
  // @@protoc_insertion_point(field_release:txn.DsPrepareResponse.resp)
  
  ::txn::PrepareResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsPrepareResponse::set_allocated_resp(::txn::PrepareResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsPrepareResponse.resp)
}

// -------------------------------------------------------------------

// DecideRequest

// string txn_id = 1;
inline void DecideRequest::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DecideRequest::txn_id() const {
  // @@protoc_insertion_point(field_get:txn.DecideRequest.txn_id)
  return txn_id_.GetNoArena();
}
inline void DecideRequest::set_txn_id(const ::std::string& value) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.DecideRequest.txn_id)
}
#if LANG_CXX11
inline void DecideRequest::set_txn_id(::std::string&& value) {
  
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.DecideRequest.txn_id)
}
#endif
inline void DecideRequest::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.DecideRequest.txn_id)
}
inline void DecideRequest::set_txn_id(const char* value, size_t size) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.DecideRequest.txn_id)
}
inline ::std::string* DecideRequest::mutable_txn_id() {
  
  // @@protoc_insertion_point(field_mutable:txn.DecideRequest.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecideRequest::release_txn_id() {
  // @@protoc_insertion_point(field_release:txn.DecideRequest.txn_id)
  
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecideRequest::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    
  } else {
    
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:txn.DecideRequest.txn_id)
}

// .txn.TxnStatus status = 2;
inline void DecideRequest::clear_status() {
  status_ = 0;
}
inline ::txn::TxnStatus DecideRequest::status() const {
  // @@protoc_insertion_point(field_get:txn.DecideRequest.status)
  return static_cast< ::txn::TxnStatus >(status_);
}
inline void DecideRequest::set_status(::txn::TxnStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:txn.DecideRequest.status)
}

// repeated bytes keys = 3;
inline int DecideRequest::keys_size() const {
  return keys_.size();
}
inline void DecideRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& DecideRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:txn.DecideRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* DecideRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:txn.DecideRequest.keys)
  return keys_.Mutable(index);
}
inline void DecideRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:txn.DecideRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DecideRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:txn.DecideRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DecideRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:txn.DecideRequest.keys)
}
inline void DecideRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:txn.DecideRequest.keys)
}
inline ::std::string* DecideRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:txn.DecideRequest.keys)
  return keys_.Add();
}
inline void DecideRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:txn.DecideRequest.keys)
}
#if LANG_CXX11
inline void DecideRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:txn.DecideRequest.keys)
}
#endif
inline void DecideRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:txn.DecideRequest.keys)
}
inline void DecideRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:txn.DecideRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DecideRequest::keys() const {
  // @@protoc_insertion_point(field_list:txn.DecideRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DecideRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:txn.DecideRequest.keys)
  return &keys_;
}

// bool clear_up = 4;
inline void DecideRequest::clear_clear_up() {
  clear_up_ = false;
}
inline bool DecideRequest::clear_up() const {
  // @@protoc_insertion_point(field_get:txn.DecideRequest.clear_up)
  return clear_up_;
}
inline void DecideRequest::set_clear_up(bool value) {
  
  clear_up_ = value;
  // @@protoc_insertion_point(field_set:txn.DecideRequest.clear_up)
}

// -------------------------------------------------------------------

// DecideResponse

// repeated .txn.TxnError errors = 1;
inline int DecideResponse::errors_size() const {
  return errors_.size();
}
inline void DecideResponse::clear_errors() {
  errors_.Clear();
}
inline const ::txn::TxnError& DecideResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:txn.DecideResponse.errors)
  return errors_.Get(index);
}
inline ::txn::TxnError* DecideResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:txn.DecideResponse.errors)
  return errors_.Mutable(index);
}
inline ::txn::TxnError* DecideResponse::add_errors() {
  // @@protoc_insertion_point(field_add:txn.DecideResponse.errors)
  return errors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::txn::TxnError >*
DecideResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:txn.DecideResponse.errors)
  return &errors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::txn::TxnError >&
DecideResponse::errors() const {
  // @@protoc_insertion_point(field_list:txn.DecideResponse.errors)
  return errors_;
}

// -------------------------------------------------------------------

// DsDecideRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsDecideRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsDecideRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsDecideRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsDecideRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsDecideRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsDecideRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsDecideRequest::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsDecideRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsDecideRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsDecideRequest.header)
}

// .txn.DecideRequest req = 2;
inline bool DsDecideRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsDecideRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::txn::DecideRequest& DsDecideRequest::req() const {
  const ::txn::DecideRequest* p = req_;
  // @@protoc_insertion_point(field_get:txn.DsDecideRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::DecideRequest*>(
      &::txn::_DecideRequest_default_instance_);
}
inline ::txn::DecideRequest* DsDecideRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::txn::DecideRequest;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsDecideRequest.req)
  return req_;
}
inline ::txn::DecideRequest* DsDecideRequest::release_req() {
  // @@protoc_insertion_point(field_release:txn.DsDecideRequest.req)
  
  ::txn::DecideRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsDecideRequest::set_allocated_req(::txn::DecideRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsDecideRequest.req)
}

// -------------------------------------------------------------------

// DsDecideResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsDecideResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsDecideResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsDecideResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsDecideResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsDecideResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsDecideResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsDecideResponse::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsDecideResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsDecideResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsDecideResponse.header)
}

// .txn.DecideResponse resp = 2;
inline bool DsDecideResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsDecideResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::txn::DecideResponse& DsDecideResponse::resp() const {
  const ::txn::DecideResponse* p = resp_;
  // @@protoc_insertion_point(field_get:txn.DsDecideResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::DecideResponse*>(
      &::txn::_DecideResponse_default_instance_);
}
inline ::txn::DecideResponse* DsDecideResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::txn::DecideResponse;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsDecideResponse.resp)
  return resp_;
}
inline ::txn::DecideResponse* DsDecideResponse::release_resp() {
  // @@protoc_insertion_point(field_release:txn.DsDecideResponse.resp)
  
  ::txn::DecideResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsDecideResponse::set_allocated_resp(::txn::DecideResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsDecideResponse.resp)
}

// -------------------------------------------------------------------

// GetLockInfoRequest

// bytes key = 1;
inline void GetLockInfoRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetLockInfoRequest::key() const {
  // @@protoc_insertion_point(field_get:txn.GetLockInfoRequest.key)
  return key_.GetNoArena();
}
inline void GetLockInfoRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.GetLockInfoRequest.key)
}
#if LANG_CXX11
inline void GetLockInfoRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.GetLockInfoRequest.key)
}
#endif
inline void GetLockInfoRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.GetLockInfoRequest.key)
}
inline void GetLockInfoRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.GetLockInfoRequest.key)
}
inline ::std::string* GetLockInfoRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.GetLockInfoRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLockInfoRequest::release_key() {
  // @@protoc_insertion_point(field_release:txn.GetLockInfoRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLockInfoRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:txn.GetLockInfoRequest.key)
}

// string txn_id = 2;
inline void GetLockInfoRequest::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetLockInfoRequest::txn_id() const {
  // @@protoc_insertion_point(field_get:txn.GetLockInfoRequest.txn_id)
  return txn_id_.GetNoArena();
}
inline void GetLockInfoRequest::set_txn_id(const ::std::string& value) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.GetLockInfoRequest.txn_id)
}
#if LANG_CXX11
inline void GetLockInfoRequest::set_txn_id(::std::string&& value) {
  
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.GetLockInfoRequest.txn_id)
}
#endif
inline void GetLockInfoRequest::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.GetLockInfoRequest.txn_id)
}
inline void GetLockInfoRequest::set_txn_id(const char* value, size_t size) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.GetLockInfoRequest.txn_id)
}
inline ::std::string* GetLockInfoRequest::mutable_txn_id() {
  
  // @@protoc_insertion_point(field_mutable:txn.GetLockInfoRequest.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLockInfoRequest::release_txn_id() {
  // @@protoc_insertion_point(field_release:txn.GetLockInfoRequest.txn_id)
  
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLockInfoRequest::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    
  } else {
    
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:txn.GetLockInfoRequest.txn_id)
}

// -------------------------------------------------------------------

// GetLockInfoResponse

// .txn.LockInfo info = 1;
inline bool GetLockInfoResponse::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void GetLockInfoResponse::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::txn::LockInfo& GetLockInfoResponse::info() const {
  const ::txn::LockInfo* p = info_;
  // @@protoc_insertion_point(field_get:txn.GetLockInfoResponse.info)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::LockInfo*>(
      &::txn::_LockInfo_default_instance_);
}
inline ::txn::LockInfo* GetLockInfoResponse::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::txn::LockInfo;
  }
  // @@protoc_insertion_point(field_mutable:txn.GetLockInfoResponse.info)
  return info_;
}
inline ::txn::LockInfo* GetLockInfoResponse::release_info() {
  // @@protoc_insertion_point(field_release:txn.GetLockInfoResponse.info)
  
  ::txn::LockInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GetLockInfoResponse::set_allocated_info(::txn::LockInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.GetLockInfoResponse.info)
}

// -------------------------------------------------------------------

// DsGetLockInfoRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsGetLockInfoRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsGetLockInfoRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsGetLockInfoRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsGetLockInfoRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsGetLockInfoRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsGetLockInfoRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsGetLockInfoRequest::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsGetLockInfoRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsGetLockInfoRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsGetLockInfoRequest.header)
}

// .txn.GetLockInfoRequest req = 2;
inline bool DsGetLockInfoRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsGetLockInfoRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::txn::GetLockInfoRequest& DsGetLockInfoRequest::req() const {
  const ::txn::GetLockInfoRequest* p = req_;
  // @@protoc_insertion_point(field_get:txn.DsGetLockInfoRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::GetLockInfoRequest*>(
      &::txn::_GetLockInfoRequest_default_instance_);
}
inline ::txn::GetLockInfoRequest* DsGetLockInfoRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::txn::GetLockInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsGetLockInfoRequest.req)
  return req_;
}
inline ::txn::GetLockInfoRequest* DsGetLockInfoRequest::release_req() {
  // @@protoc_insertion_point(field_release:txn.DsGetLockInfoRequest.req)
  
  ::txn::GetLockInfoRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsGetLockInfoRequest::set_allocated_req(::txn::GetLockInfoRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsGetLockInfoRequest.req)
}

// -------------------------------------------------------------------

// DsGetLockInfoResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsGetLockInfoResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsGetLockInfoResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsGetLockInfoResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsGetLockInfoResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsGetLockInfoResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsGetLockInfoResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsGetLockInfoResponse::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsGetLockInfoResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsGetLockInfoResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsGetLockInfoResponse.header)
}

// .txn.GetLockInfoResponse resp = 2;
inline bool DsGetLockInfoResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsGetLockInfoResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::txn::GetLockInfoResponse& DsGetLockInfoResponse::resp() const {
  const ::txn::GetLockInfoResponse* p = resp_;
  // @@protoc_insertion_point(field_get:txn.DsGetLockInfoResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::GetLockInfoResponse*>(
      &::txn::_GetLockInfoResponse_default_instance_);
}
inline ::txn::GetLockInfoResponse* DsGetLockInfoResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::txn::GetLockInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsGetLockInfoResponse.resp)
  return resp_;
}
inline ::txn::GetLockInfoResponse* DsGetLockInfoResponse::release_resp() {
  // @@protoc_insertion_point(field_release:txn.DsGetLockInfoResponse.resp)
  
  ::txn::GetLockInfoResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsGetLockInfoResponse::set_allocated_resp(::txn::GetLockInfoResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsGetLockInfoResponse.resp)
}

// -------------------------------------------------------------------

// SelectRequest

// bytes key = 1;
inline void SelectRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectRequest::key() const {
  // @@protoc_insertion_point(field_get:txn.SelectRequest.key)
  return key_.GetNoArena();
}
inline void SelectRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.SelectRequest.key)
}
#if LANG_CXX11
inline void SelectRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.SelectRequest.key)
}
#endif
inline void SelectRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.SelectRequest.key)
}
inline void SelectRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.SelectRequest.key)
}
inline ::std::string* SelectRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.SelectRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectRequest::release_key() {
  // @@protoc_insertion_point(field_release:txn.SelectRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:txn.SelectRequest.key)
}

// .kvrpcpb.Scope scope = 2;
inline bool SelectRequest::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void SelectRequest::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) delete scope_;
  scope_ = NULL;
}
inline const ::kvrpcpb::Scope& SelectRequest::scope() const {
  const ::kvrpcpb::Scope* p = scope_;
  // @@protoc_insertion_point(field_get:txn.SelectRequest.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Scope*>(
      &::kvrpcpb::_Scope_default_instance_);
}
inline ::kvrpcpb::Scope* SelectRequest::mutable_scope() {
  
  if (scope_ == NULL) {
    scope_ = new ::kvrpcpb::Scope;
  }
  // @@protoc_insertion_point(field_mutable:txn.SelectRequest.scope)
  return scope_;
}
inline ::kvrpcpb::Scope* SelectRequest::release_scope() {
  // @@protoc_insertion_point(field_release:txn.SelectRequest.scope)
  
  ::kvrpcpb::Scope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_scope(::kvrpcpb::Scope* scope) {
  delete scope_;
  scope_ = scope;
  if (scope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.SelectRequest.scope)
}

// repeated .kvrpcpb.SelectField field_list = 3;
inline int SelectRequest::field_list_size() const {
  return field_list_.size();
}
inline void SelectRequest::clear_field_list() {
  field_list_.Clear();
}
inline const ::kvrpcpb::SelectField& SelectRequest::field_list(int index) const {
  // @@protoc_insertion_point(field_get:txn.SelectRequest.field_list)
  return field_list_.Get(index);
}
inline ::kvrpcpb::SelectField* SelectRequest::mutable_field_list(int index) {
  // @@protoc_insertion_point(field_mutable:txn.SelectRequest.field_list)
  return field_list_.Mutable(index);
}
inline ::kvrpcpb::SelectField* SelectRequest::add_field_list() {
  // @@protoc_insertion_point(field_add:txn.SelectRequest.field_list)
  return field_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >*
SelectRequest::mutable_field_list() {
  // @@protoc_insertion_point(field_mutable_list:txn.SelectRequest.field_list)
  return &field_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::SelectField >&
SelectRequest::field_list() const {
  // @@protoc_insertion_point(field_list:txn.SelectRequest.field_list)
  return field_list_;
}

// repeated .kvrpcpb.Match where_filters = 4;
inline int SelectRequest::where_filters_size() const {
  return where_filters_.size();
}
inline void SelectRequest::clear_where_filters() {
  where_filters_.Clear();
}
inline const ::kvrpcpb::Match& SelectRequest::where_filters(int index) const {
  // @@protoc_insertion_point(field_get:txn.SelectRequest.where_filters)
  return where_filters_.Get(index);
}
inline ::kvrpcpb::Match* SelectRequest::mutable_where_filters(int index) {
  // @@protoc_insertion_point(field_mutable:txn.SelectRequest.where_filters)
  return where_filters_.Mutable(index);
}
inline ::kvrpcpb::Match* SelectRequest::add_where_filters() {
  // @@protoc_insertion_point(field_add:txn.SelectRequest.where_filters)
  return where_filters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >*
SelectRequest::mutable_where_filters() {
  // @@protoc_insertion_point(field_mutable_list:txn.SelectRequest.where_filters)
  return &where_filters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Match >&
SelectRequest::where_filters() const {
  // @@protoc_insertion_point(field_list:txn.SelectRequest.where_filters)
  return where_filters_;
}

// repeated .metapb.Column group_bys = 5;
inline int SelectRequest::group_bys_size() const {
  return group_bys_.size();
}
inline void SelectRequest::clear_group_bys() {
  group_bys_.Clear();
}
inline const ::metapb::Column& SelectRequest::group_bys(int index) const {
  // @@protoc_insertion_point(field_get:txn.SelectRequest.group_bys)
  return group_bys_.Get(index);
}
inline ::metapb::Column* SelectRequest::mutable_group_bys(int index) {
  // @@protoc_insertion_point(field_mutable:txn.SelectRequest.group_bys)
  return group_bys_.Mutable(index);
}
inline ::metapb::Column* SelectRequest::add_group_bys() {
  // @@protoc_insertion_point(field_add:txn.SelectRequest.group_bys)
  return group_bys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Column >*
SelectRequest::mutable_group_bys() {
  // @@protoc_insertion_point(field_mutable_list:txn.SelectRequest.group_bys)
  return &group_bys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Column >&
SelectRequest::group_bys() const {
  // @@protoc_insertion_point(field_list:txn.SelectRequest.group_bys)
  return group_bys_;
}

// .kvrpcpb.Limit limit = 6;
inline bool SelectRequest::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void SelectRequest::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) delete limit_;
  limit_ = NULL;
}
inline const ::kvrpcpb::Limit& SelectRequest::limit() const {
  const ::kvrpcpb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:txn.SelectRequest.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Limit*>(
      &::kvrpcpb::_Limit_default_instance_);
}
inline ::kvrpcpb::Limit* SelectRequest::mutable_limit() {
  
  if (limit_ == NULL) {
    limit_ = new ::kvrpcpb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:txn.SelectRequest.limit)
  return limit_;
}
inline ::kvrpcpb::Limit* SelectRequest::release_limit() {
  // @@protoc_insertion_point(field_release:txn.SelectRequest.limit)
  
  ::kvrpcpb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void SelectRequest::set_allocated_limit(::kvrpcpb::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.SelectRequest.limit)
}

// -------------------------------------------------------------------

// RowValue

// bytes fields = 1;
inline void RowValue::clear_fields() {
  fields_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RowValue::fields() const {
  // @@protoc_insertion_point(field_get:txn.RowValue.fields)
  return fields_.GetNoArena();
}
inline void RowValue::set_fields(const ::std::string& value) {
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.RowValue.fields)
}
#if LANG_CXX11
inline void RowValue::set_fields(::std::string&& value) {
  
  fields_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.RowValue.fields)
}
#endif
inline void RowValue::set_fields(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.RowValue.fields)
}
inline void RowValue::set_fields(const void* value, size_t size) {
  
  fields_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.RowValue.fields)
}
inline ::std::string* RowValue::mutable_fields() {
  
  // @@protoc_insertion_point(field_mutable:txn.RowValue.fields)
  return fields_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RowValue::release_fields() {
  // @@protoc_insertion_point(field_release:txn.RowValue.fields)
  
  return fields_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RowValue::set_allocated_fields(::std::string* fields) {
  if (fields != NULL) {
    
  } else {
    
  }
  fields_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fields);
  // @@protoc_insertion_point(field_set_allocated:txn.RowValue.fields)
}

// repeated int64 aggred_counts = 2;
inline int RowValue::aggred_counts_size() const {
  return aggred_counts_.size();
}
inline void RowValue::clear_aggred_counts() {
  aggred_counts_.Clear();
}
inline ::google::protobuf::int64 RowValue::aggred_counts(int index) const {
  // @@protoc_insertion_point(field_get:txn.RowValue.aggred_counts)
  return aggred_counts_.Get(index);
}
inline void RowValue::set_aggred_counts(int index, ::google::protobuf::int64 value) {
  aggred_counts_.Set(index, value);
  // @@protoc_insertion_point(field_set:txn.RowValue.aggred_counts)
}
inline void RowValue::add_aggred_counts(::google::protobuf::int64 value) {
  aggred_counts_.Add(value);
  // @@protoc_insertion_point(field_add:txn.RowValue.aggred_counts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
RowValue::aggred_counts() const {
  // @@protoc_insertion_point(field_list:txn.RowValue.aggred_counts)
  return aggred_counts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
RowValue::mutable_aggred_counts() {
  // @@protoc_insertion_point(field_mutable_list:txn.RowValue.aggred_counts)
  return &aggred_counts_;
}

// uint64 version = 3;
inline void RowValue::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RowValue::version() const {
  // @@protoc_insertion_point(field_get:txn.RowValue.version)
  return version_;
}
inline void RowValue::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:txn.RowValue.version)
}

// -------------------------------------------------------------------

// RowIntent

// string txn_id = 1;
inline void RowIntent::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RowIntent::txn_id() const {
  // @@protoc_insertion_point(field_get:txn.RowIntent.txn_id)
  return txn_id_.GetNoArena();
}
inline void RowIntent::set_txn_id(const ::std::string& value) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.RowIntent.txn_id)
}
#if LANG_CXX11
inline void RowIntent::set_txn_id(::std::string&& value) {
  
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.RowIntent.txn_id)
}
#endif
inline void RowIntent::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.RowIntent.txn_id)
}
inline void RowIntent::set_txn_id(const char* value, size_t size) {
  
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.RowIntent.txn_id)
}
inline ::std::string* RowIntent::mutable_txn_id() {
  
  // @@protoc_insertion_point(field_mutable:txn.RowIntent.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RowIntent::release_txn_id() {
  // @@protoc_insertion_point(field_release:txn.RowIntent.txn_id)
  
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RowIntent::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    
  } else {
    
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:txn.RowIntent.txn_id)
}

// bytes primary_key = 2;
inline void RowIntent::clear_primary_key() {
  primary_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RowIntent::primary_key() const {
  // @@protoc_insertion_point(field_get:txn.RowIntent.primary_key)
  return primary_key_.GetNoArena();
}
inline void RowIntent::set_primary_key(const ::std::string& value) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.RowIntent.primary_key)
}
#if LANG_CXX11
inline void RowIntent::set_primary_key(::std::string&& value) {
  
  primary_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.RowIntent.primary_key)
}
#endif
inline void RowIntent::set_primary_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.RowIntent.primary_key)
}
inline void RowIntent::set_primary_key(const void* value, size_t size) {
  
  primary_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.RowIntent.primary_key)
}
inline ::std::string* RowIntent::mutable_primary_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.RowIntent.primary_key)
  return primary_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RowIntent::release_primary_key() {
  // @@protoc_insertion_point(field_release:txn.RowIntent.primary_key)
  
  return primary_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RowIntent::set_allocated_primary_key(::std::string* primary_key) {
  if (primary_key != NULL) {
    
  } else {
    
  }
  primary_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_key);
  // @@protoc_insertion_point(field_set_allocated:txn.RowIntent.primary_key)
}

// .txn.RowValue value = 10;
inline bool RowIntent::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void RowIntent::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::txn::RowValue& RowIntent::value() const {
  const ::txn::RowValue* p = value_;
  // @@protoc_insertion_point(field_get:txn.RowIntent.value)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::RowValue*>(
      &::txn::_RowValue_default_instance_);
}
inline ::txn::RowValue* RowIntent::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::txn::RowValue;
  }
  // @@protoc_insertion_point(field_mutable:txn.RowIntent.value)
  return value_;
}
inline ::txn::RowValue* RowIntent::release_value() {
  // @@protoc_insertion_point(field_release:txn.RowIntent.value)
  
  ::txn::RowValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void RowIntent::set_allocated_value(::txn::RowValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.RowIntent.value)
}

// -------------------------------------------------------------------

// Row

// bytes key = 1;
inline void Row::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Row::key() const {
  // @@protoc_insertion_point(field_get:txn.Row.key)
  return key_.GetNoArena();
}
inline void Row::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:txn.Row.key)
}
#if LANG_CXX11
inline void Row::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:txn.Row.key)
}
#endif
inline void Row::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:txn.Row.key)
}
inline void Row::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:txn.Row.key)
}
inline ::std::string* Row::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:txn.Row.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Row::release_key() {
  // @@protoc_insertion_point(field_release:txn.Row.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Row::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:txn.Row.key)
}

// .txn.RowValue value = 2;
inline bool Row::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Row::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::txn::RowValue& Row::value() const {
  const ::txn::RowValue* p = value_;
  // @@protoc_insertion_point(field_get:txn.Row.value)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::RowValue*>(
      &::txn::_RowValue_default_instance_);
}
inline ::txn::RowValue* Row::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::txn::RowValue;
  }
  // @@protoc_insertion_point(field_mutable:txn.Row.value)
  return value_;
}
inline ::txn::RowValue* Row::release_value() {
  // @@protoc_insertion_point(field_release:txn.Row.value)
  
  ::txn::RowValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Row::set_allocated_value(::txn::RowValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.Row.value)
}

// .txn.RowIntent intent = 3;
inline bool Row::has_intent() const {
  return this != internal_default_instance() && intent_ != NULL;
}
inline void Row::clear_intent() {
  if (GetArenaNoVirtual() == NULL && intent_ != NULL) delete intent_;
  intent_ = NULL;
}
inline const ::txn::RowIntent& Row::intent() const {
  const ::txn::RowIntent* p = intent_;
  // @@protoc_insertion_point(field_get:txn.Row.intent)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::RowIntent*>(
      &::txn::_RowIntent_default_instance_);
}
inline ::txn::RowIntent* Row::mutable_intent() {
  
  if (intent_ == NULL) {
    intent_ = new ::txn::RowIntent;
  }
  // @@protoc_insertion_point(field_mutable:txn.Row.intent)
  return intent_;
}
inline ::txn::RowIntent* Row::release_intent() {
  // @@protoc_insertion_point(field_release:txn.Row.intent)
  
  ::txn::RowIntent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline void Row::set_allocated_intent(::txn::RowIntent* intent) {
  delete intent_;
  intent_ = intent;
  if (intent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.Row.intent)
}

// -------------------------------------------------------------------

// SelectResponse

// int32 code = 1;
inline void SelectResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 SelectResponse::code() const {
  // @@protoc_insertion_point(field_get:txn.SelectResponse.code)
  return code_;
}
inline void SelectResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:txn.SelectResponse.code)
}

// repeated .txn.Row rows = 2;
inline int SelectResponse::rows_size() const {
  return rows_.size();
}
inline void SelectResponse::clear_rows() {
  rows_.Clear();
}
inline const ::txn::Row& SelectResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:txn.SelectResponse.rows)
  return rows_.Get(index);
}
inline ::txn::Row* SelectResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:txn.SelectResponse.rows)
  return rows_.Mutable(index);
}
inline ::txn::Row* SelectResponse::add_rows() {
  // @@protoc_insertion_point(field_add:txn.SelectResponse.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::txn::Row >*
SelectResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:txn.SelectResponse.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::txn::Row >&
SelectResponse::rows() const {
  // @@protoc_insertion_point(field_list:txn.SelectResponse.rows)
  return rows_;
}

// uint64 offset = 3;
inline void SelectResponse::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SelectResponse::offset() const {
  // @@protoc_insertion_point(field_get:txn.SelectResponse.offset)
  return offset_;
}
inline void SelectResponse::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:txn.SelectResponse.offset)
}

// -------------------------------------------------------------------

// DsSelectRequest

// .kvrpcpb.RequestHeader header = 1;
inline bool DsSelectRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsSelectRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::RequestHeader& DsSelectRequest::header() const {
  const ::kvrpcpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsSelectRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::RequestHeader*>(
      &::kvrpcpb::_RequestHeader_default_instance_);
}
inline ::kvrpcpb::RequestHeader* DsSelectRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsSelectRequest.header)
  return header_;
}
inline ::kvrpcpb::RequestHeader* DsSelectRequest::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsSelectRequest.header)
  
  ::kvrpcpb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsSelectRequest::set_allocated_header(::kvrpcpb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsSelectRequest.header)
}

// .txn.SelectRequest req = 2;
inline bool DsSelectRequest::has_req() const {
  return this != internal_default_instance() && req_ != NULL;
}
inline void DsSelectRequest::clear_req() {
  if (GetArenaNoVirtual() == NULL && req_ != NULL) delete req_;
  req_ = NULL;
}
inline const ::txn::SelectRequest& DsSelectRequest::req() const {
  const ::txn::SelectRequest* p = req_;
  // @@protoc_insertion_point(field_get:txn.DsSelectRequest.req)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::SelectRequest*>(
      &::txn::_SelectRequest_default_instance_);
}
inline ::txn::SelectRequest* DsSelectRequest::mutable_req() {
  
  if (req_ == NULL) {
    req_ = new ::txn::SelectRequest;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsSelectRequest.req)
  return req_;
}
inline ::txn::SelectRequest* DsSelectRequest::release_req() {
  // @@protoc_insertion_point(field_release:txn.DsSelectRequest.req)
  
  ::txn::SelectRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline void DsSelectRequest::set_allocated_req(::txn::SelectRequest* req) {
  delete req_;
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsSelectRequest.req)
}

// -------------------------------------------------------------------

// DsSelectResponse

// .kvrpcpb.ResponseHeader header = 1;
inline bool DsSelectResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DsSelectResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::kvrpcpb::ResponseHeader& DsSelectResponse::header() const {
  const ::kvrpcpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:txn.DsSelectResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ResponseHeader*>(
      &::kvrpcpb::_ResponseHeader_default_instance_);
}
inline ::kvrpcpb::ResponseHeader* DsSelectResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::kvrpcpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsSelectResponse.header)
  return header_;
}
inline ::kvrpcpb::ResponseHeader* DsSelectResponse::release_header() {
  // @@protoc_insertion_point(field_release:txn.DsSelectResponse.header)
  
  ::kvrpcpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DsSelectResponse::set_allocated_header(::kvrpcpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsSelectResponse.header)
}

// .txn.SelectResponse resp = 2;
inline bool DsSelectResponse::has_resp() const {
  return this != internal_default_instance() && resp_ != NULL;
}
inline void DsSelectResponse::clear_resp() {
  if (GetArenaNoVirtual() == NULL && resp_ != NULL) delete resp_;
  resp_ = NULL;
}
inline const ::txn::SelectResponse& DsSelectResponse::resp() const {
  const ::txn::SelectResponse* p = resp_;
  // @@protoc_insertion_point(field_get:txn.DsSelectResponse.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::txn::SelectResponse*>(
      &::txn::_SelectResponse_default_instance_);
}
inline ::txn::SelectResponse* DsSelectResponse::mutable_resp() {
  
  if (resp_ == NULL) {
    resp_ = new ::txn::SelectResponse;
  }
  // @@protoc_insertion_point(field_mutable:txn.DsSelectResponse.resp)
  return resp_;
}
inline ::txn::SelectResponse* DsSelectResponse::release_resp() {
  // @@protoc_insertion_point(field_release:txn.DsSelectResponse.resp)
  
  ::txn::SelectResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void DsSelectResponse::set_allocated_resp(::txn::SelectResponse* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:txn.DsSelectResponse.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace txn

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::txn::TxnError_ErrType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::txn::TxnError_ErrType>() {
  return ::txn::TxnError_ErrType_descriptor();
}
template <> struct is_proto_enum< ::txn::OpType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::txn::OpType>() {
  return ::txn::OpType_descriptor();
}
template <> struct is_proto_enum< ::txn::TxnStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::txn::TxnStatus>() {
  return ::txn::TxnStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_txn_2eproto__INCLUDED
